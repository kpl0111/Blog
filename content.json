[{"title":"C++中STL常用库函数","date":"2022-06-17T09:40:03.000Z","path":"2022/06b47eaf04.html","text":"总结下C++中STL常用函数 sort()快排 reverse()逆置 unique()去重 二分查找函数 字符串查找函数 vector pair&lt;int, int&gt; string，字符串 queue, 队列 priority_queue stack, 栈 deque, 双端队列 sort()快排 函数原型：sort(起始地址, 末尾地址, cmp),其中cmp是可以自己定义的函数名,默认递增排列 cmp函数示例: bool cmp(int &amp;a, int &amp;b){ return a &gt; b; } reverse()逆置 函数原型：reverse(起始地址, 末尾地址) unique()去重 函数原型：unique(起始地址, 末尾地址, fun);其中fun为自定义的函数名。 注意：unique函数去重并不是真正的去重，它是不断的将后面不重复的元素覆盖前面重复的元素，最后返回最后一个不重复的元素的地址。 二分查找函数 lower_bound(起始地址, 末尾地址, target)：查找第一个大于等于target目标值的位置 upper_bound(起始地址, 末尾地址, target)：查找第一个大于target目标值的位置 binary_search(起始地址, 末尾地址, target)：查找target是否存在于数组或vector中，找到返回true，否则返回false 字符串查找函数 s1.find(s2)：在s1字符串中查找s2，查找到返回第一个字符的位置，查找失败返回s1.npos set.count(a)：本来是计算a出现的次数，但是由于集合中是没有重复元素的，于是count函数也就被作为查找函数了，因为a只能出现1次或者0次，查找成功，返回1；查找失败返回0. map.find()：主要用于查找key是否存在map中，不存在返回map.end()，用法和set一样 vector vector, 变长数组，倍增的思想 函数 功能 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() 访问第一个元素/最后一个元素 push_back()/pop_back() 插入/弹出最后一个元素 begin()/end() 开始元素迭代器/结尾元素迭代器 pair&lt;int, int&gt; 函数 功能 first 第一个元素 second 第二个元素 string，字符串 函数 功能 size()/length() 返回字符串长度 empty() 返回是否为空 clear() 清空 substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 函数 功能 size() 返回队列长度 empty() 返回是否为空 push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue 优先队列，默认是大根堆 函数 功能 size() 返回队列长度 empty() 返回是否为空 push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式： priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; stack, 栈 函数 功能 size() 返回栈长度 empty() 返回是否为空 push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 函数 功能 size() 返回队列长度 empty() 返回是否为空 clear() 清空队列 front()/back() 返回队头元素 push_back()/pop_back() 插入/弹出最后一个元素 push_front()/pop_front() 插入/弹出第一个元素 begin()/end() 开始元素迭代器/结尾元素迭代器","tags":[{"name":"STL","slug":"STL","permalink":"https://kpl0111.github.io/blog/tags/STL/"},{"name":"C++","slug":"C","permalink":"https://kpl0111.github.io/blog/tags/C/"}]},{"title":"添加公式渲染功能","date":"2022-06-16T13:27:50.000Z","path":"2022/06c538da4.html","text":"主题添加公式渲染功能 本文以 Hexo 主题 one-paper (其他博客理论上都可以使用这种方法配置)为例，介绍如何添加对数学公式的显示支持。 配置过程 安装渲染插件 首先执行以下命令卸载掉hexo默认的渲染插件hexo-renderer-marked ，替换为hexo-renderer-markdown-it-plus 。 npm un hexo-renderer-marked --save npm i hexo-renderer-markdown-it-plus --save 修改文章模板 修改hexo_root/scaffolds/post.md 文件，在末尾添加一行 math: true。 之后当你执行hexo new title生成一篇新的文章时，文章内部默认配置如下所示： 这样公式渲染默认是开启的，我们直接编写文章正文即可，如果想关闭数学公式支持，将true修改为false即可。 修改主题布局模板 有以下两种选择： 阅读全文后启用支持 编辑hexo_root/themes/landscape/layout/_partial/article.ejs ，在 &lt;/article&gt; (即article标签结束前)前加入一行代码，添加后效果如下： &lt;% if (!index &amp;&amp; post.math){ %&gt; &lt;script&gt; var assetsString = '&lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;' var pHead = document.getElementsByTagName('head')[0]; pHead.innerHTML = pHead.innerHTML + assetsString; &lt;/script&gt; &lt;% } %&gt; &lt;/article&gt; 故需将 &lt;!--more--&gt; 放在公式之前。 直接全部启用支持(推荐使用) 编辑 hexo_root/themes/landscape/layout/_partial/head.ejs ，在 &lt;/head&gt; (即head标签结束前)前加入一行代码，添加后效果如下： &lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;/head&gt; 编辑配置文件 在根目录下配置站点配置文件 _config.yml，在最后面加入如下配置： markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight 测试效果 整行 $$sin^2\\theta + cos^2\\theta = 1$$ sin2θ+cos2θ=1sin^2\\theta + cos^2\\theta = 1 sin2θ+cos2θ=1 行内 这是一个行内公式： $sin^2\\theta + cos^2\\theta = 1$ 效果： 这是一个行内公式： sin2θ+cos2θ=1sin^2\\theta + cos^2\\theta = 1sin2θ+cos2θ=1 数学公式测试 $$ \\begin{aligned} f_Y(y) &amp; = f_X[h(y)]|h'(y)| \\\\[2ex] &amp; = f_X[h(y)]h'(y) \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{x}{\\theta}}[\\frac{dx}{dy}(-\\frac{\\theta}{ln(1-y)})] \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{-\\frac{\\theta}{ln(1-y)}}{\\theta}}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{ln(1-y)}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1-y}{\\theta}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = 1 \\end{aligned} \\tag{1} $$ 效果： fY(y)=fX[h(y)]∣h′(y)∣=fX[h(y)]h′(y)=1θe−xθ[dxdy(−θln(1−y))]=1θe−−θln(1−y)θθ1−y=1θeln(1−y)θ1−y=1−yθθ1−y=1(1)\\begin{aligned} f_Y(y) &amp; = f_X[h(y)]|h'(y)| \\\\[2ex] &amp; = f_X[h(y)]h'(y) \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{x}{\\theta}}[\\frac{dx}{dy}(-\\frac{\\theta}{ln(1-y)})] \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{-\\frac{\\theta}{ln(1-y)}}{\\theta}}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{ln(1-y)}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1-y}{\\theta}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = 1 \\end{aligned} \\tag{1} fY​(y)​=fX​[h(y)]∣h′(y)∣=fX​[h(y)]h′(y)=θ1​e−θx​[dydx​(−ln(1−y)θ​)]=θ1​e−θ−ln(1−y)θ​​1−yθ​=θ1​eln(1−y)1−yθ​=θ1−y​1−yθ​=1​(1) $$ \\frac{1}{\\sigma} \\tag{this is a test} $$ 效果： 1σ(this&nbsp;is&nbsp;a&nbsp;test)\\frac{1}{\\sigma} \\tag{this is a test} σ1​(this&nbsp;is&nbsp;a&nbsp;test) Latex语法测试 $$\\underline{给这条语句加一个下划线}$$ 效果： 给这条语句加一个下划线‾\\underline{给这条语句加一个下划线} 给这条语句加一个下划线​ 参考：Hexo 博客启用对数学公式的支持","tags":[]},{"title":"公式渲染测试","date":"2022-06-16T13:16:17.000Z","path":"2022/06784dd132.html","text":"主题添加公式渲染功能，测试 整行： $$sin^2\\theta + cos^2\\theta = 1$$ sin2θ+cos2θ=1sin^2\\theta + cos^2\\theta = 1 sin2θ+cos2θ=1 行内： 这是一个行内公式： $sin^2\\theta + cos^2\\theta = 1$ 效果： 这是一个行内公式： sin2θ+cos2θ=1sin^2\\theta + cos^2\\theta = 1sin2θ+cos2θ=1 数学公式测试： $$ \\begin{aligned} f_Y(y) &amp; = f_X[h(y)]|h'(y)| \\\\[2ex] &amp; = f_X[h(y)]h'(y) \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{x}{\\theta}}[\\frac{dx}{dy}(-\\frac{\\theta}{ln(1-y)})] \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{-\\frac{\\theta}{ln(1-y)}}{\\theta}}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{ln(1-y)}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1-y}{\\theta}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = 1 \\end{aligned} \\tag{1} $$ 效果： fY(y)=fX[h(y)]∣h′(y)∣=fX[h(y)]h′(y)=1θe−xθ[dxdy(−θln(1−y))]=1θe−−θln(1−y)θθ1−y=1θeln(1−y)θ1−y=1−yθθ1−y=1(1)\\begin{aligned} f_Y(y) &amp; = f_X[h(y)]|h'(y)| \\\\[2ex] &amp; = f_X[h(y)]h'(y) \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{x}{\\theta}}[\\frac{dx}{dy}(-\\frac{\\theta}{ln(1-y)})] \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{-\\frac{\\theta}{ln(1-y)}}{\\theta}}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{ln(1-y)}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1-y}{\\theta}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = 1 \\end{aligned} \\tag{1} fY​(y)​=fX​[h(y)]∣h′(y)∣=fX​[h(y)]h′(y)=θ1​e−θx​[dydx​(−ln(1−y)θ​)]=θ1​e−θ−ln(1−y)θ​​1−yθ​=θ1​eln(1−y)1−yθ​=θ1−y​1−yθ​=1​(1) $$ \\frac{1}{\\sigma} \\tag{this is a test} $$ 效果： 1σ(this&nbsp;is&nbsp;a&nbsp;test)\\frac{1}{\\sigma} \\tag{this is a test} σ1​(this&nbsp;is&nbsp;a&nbsp;test) Latex语法测试： $$\\underline{给这条语句加一个下划线}$$ 效果： 给这条语句加一个下划线‾\\underline{给这条语句加一个下划线} 给这条语句加一个下划线​","tags":[]},{"title":"LeetCode笔记-栈和队列","date":"2022-06-16T06:37:39.000Z","path":"2022/0638ccdfc.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 基础知识 用栈模拟实现队列 用队列模拟实现栈 有效括号问题 栈和队列不为人知的一面 栈是先进后出，队列是先进先出： 基础知识栈先进后出，提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。 所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。 那么问题来了，STL 中栈是用什么容器实现的？ 从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。 常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。 deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。 SGI STL中 队列底层实现缺省情况下一样使用deque实现的。 也可以指定vector为栈的底层实现，初始化语句如下： std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 使用vector为底层容器的栈 对应的队列的情况是一样的。 队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。 也可以指定list 为起底层实现，初始化queue的语句如下： std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列 所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。 用栈模拟实现队列class MyQueue { public: stack&lt;int&gt; stIn; stack&lt;int&gt; stOut; /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { stIn.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据） if (stOut.empty()) { // 从stIn导入数据直到stIn为空 while(!stIn.empty()) { stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } /** Get the front element. */ int peek() { int res = this-&gt;pop(); // 直接使用已有的pop函数 stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去 return res; } /** Returns whether the queue is empty. */ bool empty() { return stIn.empty() &amp;&amp; stOut.empty(); } }; 用队列模拟实现栈class MyStack { public: queue&lt;int&gt; que1; queue&lt;int&gt; que2; MyStack() { } void push(int x) { que1.push(x); } int pop() { if (!this-&gt;empty()) { while (que1.size() &gt; 1) { que2.push(que1.front()); que1.pop(); } int result = que1.front(); que1.pop(); while (!que2.empty()) { que1.push(que2.front()); que2.pop(); } return result; } return 0; } int top() { return que1.back(); } bool empty() { return que1.empty() &amp;&amp; que2.empty(); } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 有效括号问题class Solution { public: bool isValid(string s) { stack&lt;char&gt; sta; for (int i = 0; i &lt; s.size(); i++) { if (s[i] == '(') sta.push(')'); else if (s[i] == '[') sta.push(']'); else if (s[i] == '{') sta.push('}'); else if (sta.empty() || sta.top() != s[i]) return false; else sta.pop(); } return sta.empty(); } };","tags":[]},{"title":"LeetCode笔记-双指针大法","date":"2022-06-15T10:15:41.000Z","path":"2022/06c54e8d28.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 双指针法非常实用，但是他并不隶属于任何一种数据结构。 双指针法在数组原地反转，双重循环降低时间复杂度一般都有很好的效果。","tags":[]},{"title":"LeetCode笔记-字符串","date":"2022-06-15T10:15:24.000Z","path":"2022/063572401b.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 什么是字符串 双指针法 KMP 什么是字符串字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定。 在C语言中，把一个字符串存入一个数组时，也把结束符 ‘\\0’存入数组，并以此作为该字符串是否结束的标志。 例如这段代码： char a[5] = \"asd\"; for (int i = 0; a[i] != '\\0'; i++) { } 在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用’\\0’来判断是否结束。 例如这段代码: string a = \"asd\"; for (int i = 0; i &lt; a.size(); i++) { } 那么vector&lt; char &gt; 和 string 又有什么区别呢？ 其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。 所以想处理字符串，我们还是会定义一个string类型。 双指针法双指针法在数组，链表和字符串中很常用。其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。 KMPKMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 KMP的精髓所在就是前缀表 前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。 那么使用KMP可以解决两类经典问题： 匹配问题：28. 实现 strStr() 重复子串问题：459.重复的子字符串 再一次强调了什么是前缀，什么是后缀，什么又是最长相等前后缀。 前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。 后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。 然后针对前缀表到底要不要减一，这其实是不同KMP实现的方式，在KMP精讲 中针对之前两个问题，分别给出了两个不同版本的的KMP实现。 其中主要理解j=next[x]这一步最为关键！","tags":[]},{"title":"LeetCode笔记-KMP","date":"2022-06-13T13:30:27.000Z","path":"2022/063572401b.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 实现strStr() 摘要 构造next数组 使用next数组来做匹配 前缀表统一减一 C++代码实现 字符串操作主要考虑格式的转换。 实现strStr()LeetCode题目链接 KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 KMP精讲文字版 KMP精讲视频 摘要构造next数组 next数组的本质就是前缀后缀相同的字符位数表实现方式常见的有减一、右移和保持不变三种，但是本质都是一样的，只在细微地方有区别，本文采用减一方式，其他方式代码详见前缀表（不减一）C++实现 我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下： void getNext(int* next, const string&amp; s) 构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步： 初始化 处理前后缀不相同的情况 处理前后缀相同的情况 接下来我们详解详解一下。 初始化：定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。 然后还要对next数组进行初始化赋值，如下： int j = -1; next[0] = j; j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。 next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j） 所以初始化next[0] = j 。 处理前后缀不相同的情况因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。 所以遍历模式串s的循环下标i 要从 1开始，代码如下： for (int i = 1; i &lt; s.size(); i++) { 如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。 怎么回退呢？ next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。 那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。 所以，处理前后缀不相同的情况代码如下： while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } 处理前后缀相同的情况如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。 代码如下： if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; 最后整体构建next数组的函数代码如下： void getNext(int* next, const string&amp; s){ int j = -1; next[0] = j; for(int i = 1; i &lt; s.size(); i++) { // 注意i从1开始 while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] } } 代码构造next数组的逻辑流程动画如下： 得到了next数组之后，就要用这个来做匹配了。 使用next数组来做匹配在文本串s里 找是否出现过模式串t。 定义两个下标j 指向模式串起始位置，i指向文本串起始位置。 那么j初始值依然为-1，为什么呢？ 依然因为next数组里记录的起始位置为-1。 i就从0开始，遍历文本串，代码如下： for (int i = 0; i &lt; s.size(); i++) 接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。 如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。 代码如下： while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) { j = next[j]; } 如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下： if (s[i] == t[j + 1]) { j++; // i的增加在for循环里 } 如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。 本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。 代码如下： if (j == (t.size() - 1) ) { return (i - t.size() + 1); } 那么使用next数组，用模式串匹配文本串的整体代码如下： int j = -1; // 因为next数组里记录的起始位置为-1 for (int i = 0; i &lt; s.size(); i++) { // 注意i就从0开始 while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t return (i - t.size() + 1); } } 此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下： 前缀表统一减一 C++代码实现class Solution { public: void getNext(int* next, const string&amp; s) { int j = -1; next[0] = j; for(int i = 1; i &lt; s.size(); i++) { // 注意i从1开始 while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] } } int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } int next[needle.size()]; getNext(next, needle); int j = -1; // // 因为next数组里记录的起始位置为-1 for (int i = 0; i &lt; haystack.size(); i++) { // 注意i就从0开始 while(j &gt;= 0 &amp;&amp; haystack[i] != needle[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t return (i - needle.size() + 1); } } return -1; } };","tags":[]},{"title":"LeetCode笔记-哈希表","date":"2022-06-12T10:19:48.000Z","path":"2022/064cfc9b66.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 哈希表 哈希碰撞 常见的三种哈希结构 三种数据结构的选择 哈希表 哈希表是根据关键码的值而直接进行访问的数据结构。一般哈希表都是用来快速判断一个元素是否出现在集合里。 哈希碰撞两个元素同时映射到哈希表中同一位置，这一现象叫做哈希碰撞，如下例： 一般处理方法有两种，拉链法和线性探测法。 拉链法其实拉链法就是要选择合适的哈希表大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间 线性探测法使用线性探测法，一定要保证tablesize大于datasize，需要依靠哈希表中的空位来解决碰撞问题。 常见的三种哈希结构当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。 数组 set （集合） map(映射) 在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。 那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 三种数据结构的选择 数据量给定而且没有太大需求的可以直接选择数组。 数据量未知而且如果哈希值比较少、特别分散、跨度非常大，使用set，使用数组就造成空间的极大浪费 直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的，所以可以用数组的优先选择数组 map是采用了key-value的方式，一般可以用来保存一一对应的键值对","tags":[]},{"title":"LeetCode笔记-链表","date":"2022-06-12T10:19:16.000Z","path":"2022/064d5af563.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 链表 性能分析 C++示例 关于环形链表和入口问题 链表链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链接的入口节点称为链表的头结点也就是head。 双链表： 循环链表：循环链表可用来解决约瑟夫环问题 链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。 // 单链表 struct ListNode { int val; // 节点上存储的元素 ListNode *next; // 指向下一个节点的指针 // ListNode *prev; //指向前一个元素 双链表，记得构造函数初始化 ListNode(int x) : val(x), next(NULL) {} // 节点的构造函数 }; 性能分析 插入/删除 查询 适用场景 数组 O(n) O(1) 数据量固定，频繁查询，较少增删 链表 O(1) O(n) 数据量不固定，频繁增删，较少查询 单链表的删除操作一般有两类： 设置虚拟头，将头节点当作普通节点处理，最后在删除虚拟头 头节点和其他节点分开处理 Pyhton、Java等语言可以自动释放内存，C++记得要手动释放内存节约空间。 C++示例class MyLinkedList { public: // 定义链表节点结构体 struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点 _size = 0; } // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点 int get(int index) { if (index &gt; (_size - 1) || index &lt; 0) { return -1; } LinkedNode* cur = _dummyHead-&gt;next; while(index--){ // 如果--index 就会陷入死循环 cur = cur-&gt;next; } return cur-&gt;val; } // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点 void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-&gt;next = _dummyHead-&gt;next; _dummyHead-&gt;next = newNode; _size++; } // 在链表最后面添加一个节点 void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(cur-&gt;next != nullptr){ cur = cur-&gt;next; } cur-&gt;next = newNode; _size++; } // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。 // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点 // 如果index大于链表的长度，则返回空 void addAtIndex(int index, int val) { if (index &gt; _size) { return; } LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(index--) { cur = cur-&gt;next; } newNode-&gt;next = cur-&gt;next; cur-&gt;next = newNode; _size++; } // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的 void deleteAtIndex(int index) { if (index &gt;= _size || index &lt; 0) { return; } LinkedNode* cur = _dummyHead; while(index--) { cur = cur -&gt;next; } LinkedNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; _size--; } // 打印链表 void printLinkedList() { LinkedNode* cur = _dummyHead; while (cur-&gt;next != nullptr) { cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; \" \"; cur = cur-&gt;next; } cout &lt;&lt; endl; } private: int _size; LinkedNode* _dummyHead; }; 关于环形链表和入口问题链表是否存在环可以用双指针快速判定，fast每次移动两个节点，slow一个节点，如果相遇（即fast == slow），则必定存在环 环的入口可以这样求：在相遇位置设置tmp1，在链表头结点处设置tmp2，每次走一个节点，相遇位置即为环入口节点 理论比较简单，详细可参见链表：环找到了，那入口呢？,dalao写的非常详细","tags":[]},{"title":"智能电灯","date":"2022-06-03T02:53:20.000Z","path":"2022/06373cfef8.html","text":"ESP8266实现智能电灯 实验原理 实验步骤 演示 Esp32实现光照传感器 原理 实验步骤 验证光照传感器 Esp32的网关实现 部署 设置场景联动 源代码 智能电灯 光照传感器 esp32的网关实现 ESP8266实现智能电灯本实验目的是要通过腾讯云服务器和ESP8266芯片实现远程操纵一个LED灯的颜色和亮度 实验原理首先在腾讯云物联网开发平台注册一个项目，并设置一个电灯产品，采用Wifi通信，然后在芯片上编写代码实现对LED灯的控制以及对信号的接收，然后用腾讯云配套小程序即可实现远程控制。 实验步骤 使用一根提供USB数据线将NodeMCU开发板和电脑连接起来，在命令行执行指令pip install esptool,然后执行esptool read_mac·查看开发板信息图中红框内即为使用的接口，如果缺少驱动可以通过驱动精灵下载 烧录固件，首先执行esptool --port COM9 erase_flash擦除flash芯片，接口名称要更换为自己的设备名称，然后执行esptool --port COM9 write_flash --flash_size=detect 0 esp8266-20220117-v1.18.bin重新烧录固件,之后重启即可 在腾讯云物联网开发平台注册一个项目，命名为智能家居 进入项目创建一个新产品’智能电灯’，设置几个参数 产品品类：直接选择“智能生活”–&gt;“电工照明”–&gt;“灯” 认证方式：选择密钥认证，这个比较简单，而且适合我们的开发板 NodeMCU。 通信方式：选择 Wi-Fi。 数据协议：选择物模型来解析数据。 设置完成后其他默认配置就可以，这样即可生成一个新产品，之后再测试设备列表里面可以查看我们的设备信息记录下设备名称、设备密钥、和产品ID，然后在调试标签页点击下图中二维码然后利用腾讯连连小程序添加该设备即可 代码部分我们需要将产品信息的三元组和利用password生成器生成的Username和Password替换main文件里面对应部分，并完善Button.py和LED.py文件实现NodeMCU开发板引脚和LED灯的绑定 实现远程控制需要在 NodeMCU 开发板上安装一个 MQTT 客户端代码库 umqtt.simple 库。它来自MicroPython 官方维护的非内核标准库 micropython-lib 使用Putty，协议选择Serial，频率设置为115200,流控制选择None即可使用Putty来连接开发板，执行以下指令连接WiFi并安装库 import network wifi = network.WLAN(network.STA_IF) wifi.active(True) wifi.scan() #扫描WIFI列表 wifi.isconnected() #查看当前连接状态，理论上应该是False wifi.connect('Wi-Fi的SSID', 'Wi-Fi密码') # 连接对应WiFi wifi.isconnected() #再次查看状态，应该是True import upip upip.install('micropython-umqtt.simple') 烧写代码，执行ampy --port COM9 --baud 115200 --delay 0.5 put main.py烧写main文件,同样方式烧写其他三个文件，烧写完成之后重启即可实现远程控制 按照下图连接LED灯和开发板要注意面包板的正负极，连接好如下图所示 打开小程序即可操控LED灯 演示见演示视频Esp8266.mp4 Esp32实现光照传感器原理因为光照传感器设备的部署位置比较灵活，不太可能像智能电灯一样连接房间里的电源线，所以我们要用一种比 Wi-Fi 功耗更低的通信技术。这样的话，就算使用电池供电，也可以长时间（一年以上）持续工作。因此选择 BLE 低功耗蓝牙技术。 BLE 设备可以在 4 种模式下工作： 广播模式（Broadcaster），这里特指单纯的广播模式。这种模式下设备不可以被连接，只能够以一定的时间间隔把数据广播出来，供其他设备使用，比如手机扫描处理。蓝牙 Beacon 设备就是工作在这种模式。 从机模式（Peripheral），这种模式下设备仍然可以广播数据，同时也可以被连接。建立连接后，双方可以进行双向通信。比如你用手机连接一个具有蓝牙功能的体温计，这时体温计就是从机（Peripheral）。 主机模式（Central），这种模式下设备不进行广播，但是可以扫描周围的蓝牙广播包，发现其他设备，然后主动对这些设备发起连接。还是刚才那个例子，主动连接蓝牙体温计的手机就是主机（Central）角色。 观察者模式（Observer），这种模式下设备像主机模式一样，也不进行广播，而是扫描周围的蓝牙广播包，但是不同的地方是，它不会与从机设备建立连接。一般收集蓝牙设备广播包的网关就是在这种模式下工作的，它会将收集的广播数据通过网线、Wi-Fi 或者 4G 等蜂窝网络上传到云平台。 实验步骤 用面包板连接NodeMCU和感光元件，如下图所示： 基于 PT550 环保型光敏二极管的光照传感器元器件，它的灵敏度更高，测量范围是 0Lux～6000Lux。这个元器件通过信号管脚输出模拟量，我们读取 NodeMCU ESP32 的 ADC 模数转换器（ADC0，对应GPIO36）的数值，就可以得到光照强度。这个数值越大，表示光照强度越大。因为 ADC 支持的最大位数是 12bit，所以这个数值范围是 0~4095 之间。这里我们粗略地按照线性关系做一个转换,代码如下： class LightSensor(): def __init__(self, pin): self.light = ADC(Pin(pin)) def value(self): value = self.light.read() print(\"Light ADC value:\",value) return int(value / 4095 * 6000) 和Esp8266一样，擦除固件，然后重装固件，将补充好的代码文件写入开发板 esptool --chip esp32 --port COM9 erase_flash #擦除固件 esptool --chip esp32 --port COM9 write_flash -z 0x1000 esp32-20220117-v1.18.bin #烧写固件 验证光照传感器使用nRF Connect，扫描到开发板如下： Esp32的网关实现NodeMCU ESP32 开发板是蓝牙设备，本身无法直接联网上报数据，因此需要借助网关来实现联网的目的。 网关的主要功能是协议转换，一方面它需要接收低功耗蓝牙技术的光照传感器的广播数据，另一方面，它需要把解析的数据上传到云平台：配置完虚拟机环境之后，虚拟机即充当了树莓派的作用 在腾讯云物联网开发平台同样按照上述方式配置一个Lightsensor_1部件，把光照值在智能联动配置里面设置为联动值，后面要用到光照值为灯泡提供光照数据，记录下三元组。 接下来补充gateway.py缺失部分代码，把三元组替换为我们的生成的三元组以及username和password,中间光照的loop函数调用bles成员函数读取扫描到的光照强度数值并上传扫描到的光照强度数值，代码如下： 部署接下来就是可以让程序作为后台服务运行，首先打开虚拟机，执行以下几条命令,为虚拟机增添Pi Gateway服务 $ sudo cp /home/pi/pi-gateway/pi-gateway.service /etc/systemd/system/ $ sudo systemctl daemon-reload $ sudo systemctl start pi-gateway $ sudo systemctl status pi-gateway $ sudo systemctl enable pi-gateway 执行之后，网关程序就在虚拟机上运行起来了，在腾讯云平台上可以看到，光照传感器变为在线状态。 设置场景联动我们希望实现的联动场景是，基于环境的光照强度自动控制电灯的开和关。具体来说，这个目标可以拆解为 3 个自动触发任务： 当光照强度大于 1024Lux 时，关闭电灯。 当光照强度小于 1024Lux 时，打开电灯。 至于光照强度等于 1024Lux 时，也打开电灯。 在腾讯连连小程序上面添加上述三个场景 源代码智能电灯# main.py from LED import Led from Button import Button from Relay import Relay import time import uasyncio import network import ujson from umqtt.simple import MQTTClient \"\"\" Wi-Fi Gateway : SSID and Password \"\"\" WIFI_AP_SSID = \"Xiaomi_301\" WIFI_AP_PSW = \"76780211\" \"\"\" QCloud Device Info \"\"\" DEVICE_NAME = \"Led_1\" PRODUCT_ID = \"XICW4V8C51\" DEVICE_KEY = \"sBgj/K/mb+/F01FYk5IJcw==\" \"\"\" MQTT topic \"\"\" MQTT_CONTROL_TOPIC = \"$thing/down/property/\"+PRODUCT_ID+\"/\"+DEVICE_NAME MQTT_CONTROL_REPLY_TOPIC = \"$thing/up/property/\"+PRODUCT_ID+\"/\"+DEVICE_NAME led = Led(5, 4, 0) relay = Relay(16) button = Button(14) mqtt_client = None color = 0 #enum 0=red, 1=green, 2=blue name= \"\" #light name. it is optional brightness = 100 # 0%~100% light_changed = False async def wifi_connect(ssid, pwd): sta = network.WLAN(network.STA_IF) sta.active(True) sta.connect(ssid, pwd) while not sta.isconnected(): print(\"Wi-Fi Connecting...\") time.sleep_ms(500) def mqtt_callback(topic, msg): global led, relay, button global color, name, brightness, light_changed print((topic, msg)) msg_json = ujson.loads(msg) if msg_json['method'] == 'control': params = msg_json['params'] power_switch_tmp = params.get('power_switch') if power_switch_tmp is not None: power_switch = power_switch_tmp relay.set_state(power_switch) brightness_tmp = params.get('brightness') if brightness_tmp is not None: brightness = brightness_tmp color_tmp = params.get('color') if color_tmp is not None: color = color_tmp name_tmp = params.get('name') if name_tmp is not None: name = name_tmp if brightness_tmp is not None or color_tmp is not None: light_changed = True async def mqtt_connect(): global mqtt_client MQTT_SERVER = PRODUCT_ID + \".iotcloud.tencentdevices.com\" MQTT_PORT = 1883 MQTT_CLIENT_ID = PRODUCT_ID+DEVICE_NAME MQTT_USER_NAME = \"XICW4V8C51Led_1;12010126;DUQ2I;1655185098\" MQTTT_PASSWORD = \"c8e0d3a2c3b568091747e5eba7de4a6edb6280dd20d1dade64efa6debd3492cd;hmacsha256\" mqtt_client = MQTTClient(MQTT_CLIENT_ID, MQTT_SERVER, MQTT_PORT,MQTT_USER_NAME, MQTTT_PASSWORD, 60) mqtt_client.set_callback(mqtt_callback) mqtt_client.connect() def mqtt_report(client, color, name, switch, brightness): msg = { \"method\": \"report\", \"clientToken\": \"clientToken-2444532211\", \"params\": { \"color\": color, \"color_temp\": 0, \"name\": name, \"power_switch\": switch, \"brightness\": brightness } } client.publish(MQTT_CONTROL_REPLY_TOPIC.encode(), ujson.dumps(msg).encode()) async def light_loop(): global led, relay, button global color, name, brightness, light_changed switch_status_last = 1 LED_status = 0 color = 2 #blue brightness = 100 #here 100% == 1 led.rgb_light(0, 0, 255, brightness/100.0) # 该循环为测试LED等的开闭循环 # while True: # relay.set_on() # await uasyncio.sleep_ms(2000) # relay.set_off() # await uasyncio.sleep_ms(2000) time_cnt = 0 mqtt_client.subscribe(MQTT_CONTROL_TOPIC.encode()) while True: mqtt_client.check_msg() switch_status = button.state() LED_status = relay.state() if switch_status != switch_status_last: if switch_status == 0 and switch_status_last == 1: LED_status = 0 if LED_status else 1 relay.set_state(LED_status) switch_status_last = switch_status if light_changed: light_changed = False led.rgb_light(255 if color==0 else 0, 255 if color==1 else 0, 255 if color==2 else 0, brightness/100.0) # 调整为0.02*100=2秒上报一次 if time_cnt &gt;= 100: mqtt_report(mqtt_client, color, name, LED_status, brightness) time_cnt = 0 time_cnt = time_cnt+1 await uasyncio.sleep_ms(20)# 时间间隔最好别超过50ms，否则按钮按下时间在休眠期间的话会无效，导致按钮很不好操作 async def main(): global mqtt_client # Wi-Fi connection try: await uasyncio.wait_for(wifi_connect(WIFI_AP_SSID, WIFI_AP_PSW), 20) except uasyncio.TimeoutError: print(\"wifi connected timeout!\") # MQTT connection try: await uasyncio.wait_for(mqtt_connect(), 20) except uasyncio.TimeoutError: print(\"mqtt connected timeout!\") await uasyncio.gather(light_loop()) uasyncio.run(main()) # Relay.py from machine import ADC from machine import Pin, Signal class Relay(): def __init__(self, pin): self.relaypin = Pin(pin, Pin.OUT) self.relayled = Signal(self.relaypin, invert=True) # 将信号置反, 实现开与关和输入信号对应 #self.last_status = 1 def set_state(self, state): self.relayled.value(state) #self.relaypin.value(state) #self.last_status = state def set_on(self): #self.relaypin.on() value: 1 but light is off self.relayled.value(1) print('Relay on value: ' + str(self.relayled.value())) def set_off(self): # self.relaypin.off() value: 0 but light is on self.relayled.value(0) print('Relay off value: ' + str(self.relayled.value())) def state(self): return self.relayled.value() #LED.py from machine import PWM from machine import Pin class Led(): \"\"\" 创建LED类 \"\"\" def __init__(self, rpin, gpin, bpin, sfreq=1000): \"\"\" 构造函数 :param pin: 接LED的管脚，必须支持PWM :param freq: PWM的默认频率是1000 \"\"\" #以rpin, gpin, bpin为参数，使用Pin和PWM来绑定三个引脚来控制led灯的红黄蓝的三个PWM信号 self.led_red = PWM(Pin(rpin), freq = sfreq) self.led_green = PWM(Pin(gpin), freq = sfreq) self.led_blue = PWM(Pin(bpin), freq = sfreq) def rgb_light(self, red, green, blue, brightness): #red green blue的范围在range(256)内，brightness的范围在[0,1]内，如果取值不在正确范围内，什么也不做 #调用duty成员函数来设置三种颜色的占空比 if brightness &gt;= 0 and brightness &lt;= 1: if red in range(256): self.led_red.duty(int(red/255*brightness*1023)) if green in range(256): self.led_green.duty(int(green/255*brightness*1023)) if blue in range(256): self.led_blue.duty(int(blue/255*brightness*1023)) def deinit(self): \"\"\" 析构函数 \"\"\" self.led_red.deinit() self.led_green.deinit() self.led_blue.deinit() # Button.py from machine import ADC from machine import Pin class Button(): def __init__(self, pin): self.button = Pin(pin, Pin.IN) def state(self): return self.button.value() 光照传感器# main.py from ble_lightsensor import BLELightSensor from lightsensor import LightSensor import time import bluetooth def main(): ble = bluetooth.BLE() ble.active(True) ble_light = BLELightSensor(ble) light = LightSensor(36) light_density = light.value() i = 0 while True: # Write every second, notify every 10 seconds. i = (i + 1) % 10 ble_light.set_light(light_density, notify=i == 0) print(\"Light Lux:\", light_density) light_density = light.value() time.sleep_ms(1000) if __name__ == \"__main__\": main() # ble_advertising.py # Helpers for generating BLE advertising payloads. from micropython import const import struct import bluetooth # Advertising payloads are repeated packets of the following form: # 1 byte data length (N + 1) # 1 byte type (see constants below) # N bytes type-specific data _ADV_TYPE_FLAGS = const(0x01) _ADV_TYPE_NAME = const(0x09) _ADV_TYPE_UUID16_COMPLETE = const(0x3) _ADV_TYPE_UUID32_COMPLETE = const(0x5) _ADV_TYPE_UUID128_COMPLETE = const(0x7) _ADV_TYPE_UUID16_MORE = const(0x2) _ADV_TYPE_UUID32_MORE = const(0x4) _ADV_TYPE_UUID128_MORE = const(0x6) _ADV_TYPE_APPEARANCE = const(0x19) _ADV_TYPE_SERVICE_DATA = const(0x16) # Generate a payload to be passed to gap_advertise(adv_data=...). def advertising_payload(limited_disc=False, br_edr=False, name=None, services=None, appearance=0, service_data = None): payload = bytearray() def _append(adv_type, value): nonlocal payload payload += struct.pack(\"BB\", len(value) + 1, adv_type) + value _append( _ADV_TYPE_FLAGS, struct.pack(\"B\", (0x01 if limited_disc else 0x02) + (0x18 if br_edr else 0x04)), ) if name: _append(_ADV_TYPE_NAME, name) if services: for uuid in services: b = bytes(uuid) if len(b) == 2: _append(_ADV_TYPE_UUID16_COMPLETE, b) elif len(b) == 4: _append(_ADV_TYPE_UUID32_COMPLETE, b) elif len(b) == 16: _append(_ADV_TYPE_UUID128_COMPLETE, b) # See org.bluetooth.characteristic.gap.appearance.xml if appearance: _append(_ADV_TYPE_APPEARANCE, struct.pack(\"&lt;h\", appearance)) if service_data: _append(_ADV_TYPE_SERVICE_DATA, service_data) return payload def decode_field(payload, adv_type): i = 0 result = [] while i + 1 &lt; len(payload): if payload[i + 1] == adv_type: result.append(payload[i + 2 : i + payload[i] + 1]) i += 1 + payload[i] return result def decode_name(payload): n = decode_field(payload, _ADV_TYPE_NAME) return str(n[0], \"utf-8\") if n else \"\" def decode_services(payload): services = [] for u in decode_field(payload, _ADV_TYPE_UUID16_COMPLETE): services.append(bluetooth.UUID(struct.unpack(\"&lt;h\", u)[0])) for u in decode_field(payload, _ADV_TYPE_UUID32_COMPLETE): services.append(bluetooth.UUID(struct.unpack(\"&lt;d\", u)[0])) for u in decode_field(payload, _ADV_TYPE_UUID128_COMPLETE): services.append(bluetooth.UUID(u)) return services def demo(): payload = advertising_payload( name=\"micropython\", services=[bluetooth.UUID(0x181A), bluetooth.UUID(\"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\")], ) print(payload) print(decode_name(payload)) print(decode_services(payload)) if __name__ == \"__main__\": demo() # ble_lightsensor.py import bluetooth import struct import time from ble_advertising import advertising_payload from micropython import const _IRQ_CENTRAL_CONNECT = const(1) _IRQ_CENTRAL_DISCONNECT = const(2) _IRQ_GATTS_INDICATE_DONE = const(20) _FLAG_READ = const(0x0002) _FLAG_NOTIFY = const(0x0010) _ADV_SERVICE_DATA_UUID = 0xFE95 _SERVICE_UUID_ENV_SENSE = 0x181A _CHAR_UUID_AMBIENT_LIGHT = 'FEC66B35-937E-4938-9F8D-6E44BBD533EE' # Service environmental sensing _ENV_SENSE_UUID = bluetooth.UUID(_SERVICE_UUID_ENV_SENSE) # Characteristic ambient light density _AMBIENT_LIGHT_CHAR = ( bluetooth.UUID(_CHAR_UUID_AMBIENT_LIGHT), _FLAG_READ | _FLAG_NOTIFY , ) _ENV_SENSE_SERVICE = ( _ENV_SENSE_UUID, (_AMBIENT_LIGHT_CHAR,), ) # https://specificationrefs.bluetooth.com/assigned-values/Appearance%20Values.pdf _ADV_APPEARANCE_GENERIC_AMBIENT_LIGHT = const(1344) class BLELightSensor: def __init__(self, ble, name='Nodemcu'): self._ble = ble self._ble.active(True) self._ble.irq(self._irq) ((self._handle,),) = self._ble.gatts_register_services((_ENV_SENSE_SERVICE,)) self._connections = set() time.sleep_ms(500) self._payload = advertising_payload( name=name, services=[_ENV_SENSE_UUID], appearance=_ADV_APPEARANCE_GENERIC_AMBIENT_LIGHT ) self._sd_adv = None self._advertise() def _irq(self, event, data): # Track connections so we can send notifications. if event == _IRQ_CENTRAL_CONNECT: conn_handle, _, _ = data self._connections.add(conn_handle) elif event == _IRQ_CENTRAL_DISCONNECT: conn_handle, _, _ = data self._connections.remove(conn_handle) # Start advertising again to allow a new connection. self._advertise() elif event == _IRQ_GATTS_INDICATE_DONE: conn_handle, value_handle, status = data def set_light(self, light_den, notify=False): self._ble.gatts_write(self._handle, struct.pack(\"!h\", int(light_den))) self._sd_adv = self.build_mi_sdadv(light_den) self._advertise() if notify: for conn_handle in self._connections: if notify: # Notify connected centrals. self._ble.gatts_notify(conn_handle, self._handle) def build_mi_sdadv(self, density): uuid = 0xFE95 fc = 0x0010 pid = 0x0002 fcnt = 0x01 mac = self._ble.config('mac') objid = 0x1007 objlen = 0x03 objval = density #service_data = struct.pack(\"&lt;3HB\",uuid,fc,pid,fcnt)+mac+struct.pack(\"&lt;H2BH\",objid,objlen,0,objval) #mac获取得到的是一个tuple对象 ex: (0, b'4\\\\x86]\\\\xb6\\\\xeb\\\\x0e'), 取第二个 service_data = struct.pack(\"&lt;3HB\",uuid,fc,pid,fcnt)+mac[1]+struct.pack(\"&lt;H2BH\",objid,objlen,0,objval) print(\"Service Data:\",service_data) return advertising_payload(service_data=service_data) def _advertise(self, interval_us=500000): self._ble.gap_advertise(interval_us, adv_data=self._payload) time.sleep_ms(100) print(\"sd_adv\",self._sd_adv) if self._sd_adv is not None: print(\"sdddd_adv\",self._sd_adv) self._ble.gap_advertise(interval_us, adv_data=self._sd_adv) # lightsensor.py from machine import ADC from machine import Pin class LightSensor(): def __init__(self, pin): self.light = ADC(Pin(pin)) def value(self): value = self.light.read() print(\"Light ADC value:\",value) return int(value / 4095 * 6000) esp32的网关实现# blescan.py import time from threading import Thread from interruptingcow import timeout from bluepy.btle import DefaultDelegate, Peripheral, Scanner, UUID, capitaliseName, BTLEInternalError from bluepy.btle import BTLEDisconnectError, BTLEManagementError, BTLEGattError class LightScanner(): SCAN_TIMEOUT = 5 def __init__(self, name): self._name = name def status_update(self): results = self._get_data() # messages = [ # MqttMessage( # topic=self.format_topic(\"property/light\"), # payload=results.lightlevel, # ) # ] return results def _get_data(self): \"\"\" 获取光照强度数据，并对超时异常进行处理 \"\"\" scan_processor = ScanProcessor(self._name) scanner = Scanner().withDelegate(scan_processor) scanner.scan(self.SCAN_TIMEOUT, passive=True) with timeout( self.SCAN_TIMEOUT, exception=Exception( \"Retrieving data from {} device {} timed out after {} seconds\".format( repr(self), self._name, self.SCAN_TIMEOUT ) ), ): while not scan_processor.ready: time.sleep(1) return scan_processor.results return scan_processor.results class ScanProcessor: ADV_TYPE_SERVICE_DATA = 0x16 #设置数据格式为十六进制 def __init__(self, name): self._ready = False self._name = name self._results = MiBeaconData() def handleDiscovery(self, dev, isNewDev, _): is_nodemcu = False if isNewDev: for (adtype, desc, value) in dev.getScanData(): #Service Data UUID == 0xFE95 according to MiBeacon if adtype == self.ADV_TYPE_SERVICE_DATA and value.startswith(\"95fe\"): print(\"FOUND service Data:\",adtype, desc, value) #Object ID == 0x1007 according to MiBeacon if len(value) == 38 and value[26:30] == '0710': light_den = int((value[-2:] + value[-4:-2]), 16) mac = value[14:26] self._results.lightlevel = light_den self._results.mac = mac self.ready = True @property def mac(self): return self._mac @property def ready(self): return self._ready @ready.setter def ready(self, var): self._ready = var @property def results(self): return self._results class MiBeaconData: def __init__(self): self._lightlevel = None self._mac = None @property def lightlevel(self): return self._lightlevel @lightlevel.setter def lightlevel(self, var): self._lightlevel = var @property def mac(self): return self._mac @mac.setter def mac(self, var): self._mac = var # gateway.py from blescan import LightScanner, MiBeaconData import time import asyncio import json import uuid import paho.mqtt.client as MQTTClient \"\"\" QCloud Device Info \"\"\" DEVICE_NAME = \"Lightsensor_1\" PRODUCT_ID = \"X2OQT7NRTP\" DEVICE_KEY = \"h0ftJ153maTi6jJWg9KCQA==\" \"\"\" MQTT topic \"\"\" MQTT_CONTROL_TOPIC = \"$thing/down/property/\"+PRODUCT_ID+\"/\"+DEVICE_NAME MQTT_CONTROL_REPLY_TOPIC = \"$thing/up/property/\"+PRODUCT_ID+\"/\"+DEVICE_NAME def mqtt_callback(client, userdata, msg): # Callback # print(f\"Received `{msg.payload.decode()}` from `{msg.topic}` topic\") return async def mqtt_connect(): #connect callback def on_connect(client, userdata, flags, rc): if rc == 0: print(\"Connected to MQTT Broker!\") else: print(\"Failed to connect, return code %d\\n\", rc) mqtt_client = None MQTT_SERVER = PRODUCT_ID + \".iotcloud.tencentdevices.com\" MQTT_PORT = 1883 MQTT_CLIENT_ID = PRODUCT_ID+DEVICE_NAME MQTT_USER_NAME = \"X2OQT7NRTPLightsensor_1;12010126;DTXFZ;1655263739\" MQTTT_PASSWORD = \"c02c6980d125f3846de11e1ab1d256f864e78f7377d2d4f94d992c5703a056c1;hmacsha256\" mqtt_client = MQTTClient.Client(MQTT_CLIENT_ID) mqtt_client.username_pw_set(MQTT_USER_NAME, MQTTT_PASSWORD) mqtt_client.on_connect = on_connect mqtt_client.connect(MQTT_SERVER, MQTT_PORT, 60) return mqtt_client def mqtt_report(client, light_level): client_token = \"clientToken-\" + str(uuid.uuid4()) msg = { \"method\": \"report\", \"clientToken\": client_token, \"params\": { \"Illuminance\": light_level } } client.publish(MQTT_CONTROL_REPLY_TOPIC, json.dumps(msg)) async def light_loop(mclient): bles = LightScanner('Nodemcu') mclient.subscribe(MQTT_CONTROL_TOPIC) mclient.on_message = mqtt_callback mclient.loop_start() while True: try: #调用bles成员函数读取扫描到的光照强度数值 data = bles._get_data() except Exception as e: print(\"BLE SCAN error:\", e) continue #上传扫描到的光照强度数值 mqtt_report(mclient, data) await time.sleep(0.3) async def main(): mqtt_client = None # MQTT connection try: mqtt_client = await asyncio.wait_for(mqtt_connect(), 20) except asyncio.TimeoutError: print(\"mqtt connected timeout!\") if mqtt_client is not None: await asyncio.gather(light_loop(mqtt_client)) asyncio.get_event_loop().run_until_complete(main())","tags":[]},{"title":"C++中string、char *、char[]、const char*的转换","date":"2022-06-02T14:49:17.000Z","path":"2022/066dcc5737.html","text":"在C++中string、const char、 char 、char[]四者类型经常会需要转化。 转化方法 C和C++中char和string区别 转化方法 char*转string：可以直接赋值。 char[]转string：可以直接赋值。 char*转char[]：不能直接赋值，可以循环char*字符串逐个字符赋值,也可以使用strcpy_s等函数。 string转char[]:不能直接赋值，可以循环char*字符串逐个字符赋值,也可以使用strcpy_s等函数 string转char*:调用string对象的c_str函数或data函数或copy函数。 char[]转char*:直接赋值即可。使用时，要对源格式和目标格式进行初始化。源格式赋值为具体的内容，目标格式赋值为空。 总结如下：A. 变成string,直接赋值。B. char[]变成别的，直接赋值。C. char*变const char*容易，const char*变char*麻烦。&lt;char*&gt;(const char*);D. string变char*要通过const char*中转。E. 变成char[]。string逐个赋值，char* const char* strncpy_s() C和C++中char和string区别在C语言中，string 是定义一个字符串，存储的是一段如“abcd”的数据，而且最后还有一个结束符’\\0’; char 是定义一个字符，存储一个字符，占一个字节。 在C++中，string有两种，一种是字符串char[]，另外一种是封装好的字符串类，要区别理解。例如’a’是char, “a”是char string，这两者都是普通的字符和字符串，和C语言中没什么不同值得注意的是后者包含两个字符，末尾有一个隐身的’\\0’ 而 string str = “a” 是C++ 封装好的string。C++中的char string和string不是一回事。当用到了”string”这个关键词，就不是普通的字符串，而是用到了封装后的类。在C++中，char仍然是一个primitive type（原始类型），而string已经经过封装，成为了一个class（类）用到它时，我们需要 #include ，它是C++ Standard Library （C++标准库）的一部分。 参考：c/c++中string与char的区别C++中string、char *、char[]、const char*的转换","tags":[]},{"title":"VS Code集成终端字体修改 & 字体颜色、大小修改方法","date":"2022-06-02T08:45:00.000Z","path":"2022/068a4c5ed0.html","text":"打开VScode，Ctrl + ,或者设置 -&gt; 设置搜索workbenck，如下图：点击Edit in settings.json在配置文件最后加上以下参数： //终端颜色配置 \"workbench.colorCustomizations\" : { //可以将鼠标放到下面的色号上根据自己的偏好进行选择 \"terminal.foreground\" : \"#37FF13\",//字体颜色 \"terminal.background\" : \"#2b2424\"//背景颜色 }, \"terminal.integrated.cursorBlinking\": true, \"terminal.integrated.lineHeight\": 1.2, \"terminal.integrated.letterSpacing\": 0.1, \"terminal.integrated.fontSize\": 14, //字体大小设置 \"terminal.integrated.fontFamily\": \"Lucida Console\", //字体设置 保存即可 具体颜色可根据个人喜好配置，如果想恢复默认颜色或者背景，删除该行代码即可 配置之后效果如下：","tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://kpl0111.github.io/blog/tags/VSCode/"}]},{"title":"利用RSA加密算法和MD5哈希算法实现加密通信（C++）","date":"2022-05-31T09:40:39.000Z","path":"2022/052824aa7.html","text":"本篇为作者个人作业，仅供参考，转载请注明出处 实验目的 实验要求 设计思路 实验设计流程图 MD5算法实现身份验证 RSA实现信息加密解密 RSA原理 实现过程 主程序 实验演示截图 源代码 文件树 MD5.h generateKey.cpp Server.h Server.cpp Client.h Client.cpp 实验目的在保密通信过程中，对消息完整性的检验和对消息来源的认证，是一个非常重要的问题，本次大作业的内容为： 设计一个协议，利用rsa公钥加密算法和MD5哈希算法，实现对消息的完整性检验和发送者身份验证的功能，并编程实现这个协议。程序的要求是假设通讯双方为A和B，并假设发方拥有自己的RSA公钥PKA和私钥SKA ，同时收方B已经通过某种方式知道了发方的公钥PKA 。协议要求对发方A发来的消息，收方B通过检验，能够确定： B收到的消息是完整的，即消息在传送过程中没有遭到非法修改； B收到的消息来源是真实的，即该消息的确是由A发来的，而不是由其他人伪造的。 实验要求 分别编写两个程序，一个为发方程序，一个为收方程序，写清楚两个程序分别要完成的功能，并能够在两个程序间进行通讯。 大作业的提交方式同实验报告的提交，也就是说既要提交程序实现的说明文档，也要提交源代码和可执行程序。 设计思路RSA公钥加密算法可以实现对消息的加密和解密，而MD5仅可对消息进行加密处理，且在之前的实验中经过测试均满足雪崩效应，因此初步思路是： 利用MD5算法实现对发送方和接收方的身份确认 双方均知道对方身份，因此可以发送方对自己的ID使用MD5算法进行加密，并把加密后的密文ID发送给接收方 接收方接收到发送方的密文ID之后，利用自己已知的发送方ID（ID双方均已知，攻击者未知）同样对发送方原始ID进行MD5加密，并与发送方发送的密文ID进行比较， 如果一致，由于MD5算法具有雪崩效应，因此可认为发送方即为本人 如果不一致，则立即中止对话，保证信息的安全性 身份确认之后即可进行消息发送接收 身份确认之后利用RSA公钥体系对双方发送消息进行加密和解密 双方输入消息，利用RSA对消息进行加密，并把加密后消息使用TCP协议进行发送，这样即便消息被截获没有密钥也无法破译 接收方接收到密文后，利用密钥对其进行解密即可获取消息内容，同样也可发送消息利用TCP协议进行消息的收发，这里仅用来实现发送消息，TCP协议的安全性暂不考虑 实验设计流程图实验流程图如下： RSA算法流程图如下： MD5算法流程图如下： MD5算法实现身份验证 获取输入，该模块用于获取一段明文字符，不定长 对获取的不定长字符串进行填充,使其字节长度满足n*512 + 448, 填充规则是第一位填充1，后续填充0，直至满足上述条件，最后再用一个64为二进制字符串表示明文长度，这样填充之后长度为(n + 1)*512 // 填充字符串 vector&lt;unsigned int&gt; padding(string src) { // 以512位,64个字节为一组 unsigned int num = ((src.length() + 8) / 64) + 1; vector&lt;unsigned int&gt; rec(num*16); strlength = num*16; for(unsigned int i = 0; i &lt; src.length(); i++){ // 一个unsigned int对应4个字节，保存4个字符信息 rec[i&gt;&gt;2] |= (int)(src[i]) &lt;&lt; ((i % 4) * 8); } // 补充1000...000 rec[src.length() &gt;&gt; 2] |= (0x80 &lt;&lt; ((src.length() % 4)*8)); // 填充原文长度 rec[rec.size()-2] = (src.length() &lt;&lt; 3); return rec; } 字符串分块函数，将上述填充之后的字符串分割为L个512字节长度的字符串 循环压缩函数：对每个512-bit分组进行64轮迭代运算 对分组（A, B, C, D）中的A进行迭代运算 公式为：A &lt;= B + ((A + f(B,C,D) + X[k] + T[i])) &lt;&lt; S[i] 其中： A,B,C,D代表MD5缓冲区当前的数值 f为轮函数，1-16轮迭代使用F函数，17-32轮迭代使用G函数，33-48轮迭 代使用H函数，49-64轮迭代使用I函数 // F函数 unsigned int F(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; c) | ((~b) &amp; d); } // G函数 unsigned int G(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; d) | (c &amp; (~d)); } // H函数 unsigned int H(unsigned int b, unsigned int c, unsigned int d) { return b ^ c ^ d; } // I函数 unsigned int I(unsigned int b, unsigned int c, unsigned int d) { return c ^ (b | (~d)); } // 移位操作函数 unsigned int shift(unsigned int a, unsigned int n) { return (a &lt;&lt; n) | (a &gt;&gt; (32 - n)); } X[k]代表当前处理消息分组的第k个32位字，X[k]由第n轮迭代对应的顺序表决定 T[i]代表T表的第i项的值，T[i] = int(2^32 * |sin(i)|) S[i]对应第i轮的左循环移位的s值 对分组（A,B,C,D）作循环轮换 公式为：（B,C,D,A）&lt;=（A,B,C,D） 按照1， 2步骤进行四轮循环压缩 // 循环压缩 void iterateFunc(unsigned int* X, int size = 16) { unsigned int a = tempA, b = tempB, c = tempC, d = tempD, rec = 0, g, k; for(int i = 0; i &lt; 64; i++) { if(i &lt; 16) { // F迭代 g = F(b, c, d); k = i; } else if(i &lt; 32) { // G迭代 g = G(b, c, d); k = (1 + 5*i) % 16; } else if(i &lt; 48) { // H迭代 g = H(b, c, d); k = (5 + 3*i) % 16; } else { // I迭代 g = I(b, c, d); k = (7*i) % 16; } rec = d; d = c; c = b; b = b + shift(a + g + X[k] + T[i], s[i]); a = rec; } tempA += a; tempB += b; tempC += c; tempD += d; } MD5编码主函数：用于调用前面的功能函数对明文字符串进行MD5编码 输入待加密的明文字符串 对明文字符串进行填充 对填充后的明文字符串进行分块（$Y_q$） 使用预设的初始值初始化MD5缓冲区间（IV） 对各个分块字符串利用公式HMD5($CV_(i-1), Y_i$)进行循环压缩，运算结果作为下一块的输入（$CV_i$） 当所有的分块迭代完成后，输出结果$CV_L$，L表示最后一个分块的序号 // MD5加密函数 string encode(string src) { vector&lt;unsigned int&gt; rec = padding(src); for(unsigned int i = 0; i &lt; strlength/16; i++) { unsigned int num[16]; for(int j = 0; j &lt; 16; j++) { num[j] = rec[i*16+j]; } iterateFunc(num, 16); } return format(tempA) + format(tempB) + format(tempC) + format(tempD); } RSA实现信息加密解密RSA原理 公钥 选择两个不同的大素数p和q，n是二者的乘积，即$ n=pq $， 使$$ \\varphi (n)=(p-1)(q-1) $$为欧拉函数。 随机选取正整数e，使其满足$ gcd(e,\\varphi (n))=1 $，即e和$\\phi (n)$互素，则将(e,n)作为公钥。 私钥 求出正数d，使其满足$ e \\times d \\equiv 1mod\\varphi (n) $，则将(d,n)作为私钥。 加密算法 对于明文m，由$ c \\equiv m^emodn $，得到密文c，这里需要注意明文的分组方法。 解密算法 对于密文c，由$ m \\equiv c^dmodn $，得到明文m。 实现过程C++中大数需要用到gmp库,简单说下怎么安装 Linux一行命令的事情 sudo apt-get install libgmp-dev Windows下需要MinGW,打开MinGW Installation Manager,左侧All Packages选中，然后找到MinGW-gmp，版本的话选择dev，右键Mark for Installation，然后菜单栏Installation选择Apply Changes即可，等待安装即可。 首先定义一个密钥对结构体： struct key_pair { string n; string d; int e; }; 利用GMP的素性测试和数据生成完成两个大素数p，q的生成 //生成两个大素数 mpz_t * gen_primes() { gmp_randstate_t grt; gmp_randinit_default(grt); gmp_randseed_ui(grt, time(NULL)); mpz_t key_p, key_q; mpz_init(key_p); mpz_init(key_q); mpz_urandomb(key_p, grt, KEY_LENGTH / 2); mpz_urandomb(key_q, grt, KEY_LENGTH / 2); //随机生成两个大整数 mpz_t * result = new mpz_t[2]; mpz_init(result[0]); mpz_init(result[1]); mpz_nextprime(result[0], key_p); //使用GMP自带的素数生成函数 mpz_nextprime(result[1], key_q); mpz_clear(key_p); mpz_clear(key_q); return result; } 根据RSA原理生成密钥对 //生成密钥对 key_pair * gen_key_pair() { mpz_t * primes = gen_primes(); mpz_t key_n, key_e, key_f; mpz_init(key_n); mpz_init(key_f); mpz_init_set_ui(key_e, 65537); //设置e为65537 mpz_mul(key_n, primes[0], primes[1]); //计算n=p*q mpz_sub_ui(primes[0], primes[0], 1); //p=p-1 mpz_sub_ui(primes[1], primes[1], 1); //q=q-1 mpz_mul(key_f, primes[0], primes[1]); //计算欧拉函数φ(n)=(p-1)*(q-1) mpz_t key_d; mpz_init(key_d); mpz_invert(key_d, key_e, key_f); //计算数论倒数 key_pair * result = new key_pair; char * buf_n = new char[KEY_LENGTH + 10]; char * buf_d = new char[KEY_LENGTH + 10]; mpz_get_str(buf_n, BASE, key_n); result-&gt;n = buf_n; mpz_get_str(buf_d, BASE, key_d); result-&gt;d = buf_d; result-&gt;e = 65537; mpz_clear(primes[0]); //释放内存 mpz_clear(primes[1]); mpz_clear(key_n); mpz_clear(key_d); mpz_clear(key_e); mpz_clear(key_f); delete []primes; return result; } 加密函数 char * encrypt(char * plain_text, const char * key_n, int key_e) { mpz_t M, C1, n; mpz_init_set_str(M, plain_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_ui(C1, 0); mpz_powm_ui(C1, M, key_e, n); //使用GMP中模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, C1); return result; } 解密函数 char * decrypt(char * cipher_text, const char * key_n, const char * key_d) { mpz_t M, C1, n, d; mpz_init_set_str(C1, cipher_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_str(d, key_d, BASE); mpz_init(M); mpz_powm(M, C1, d, n); //使用GMP中的模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, M); return result; } 主程序 对A,B双方分别创建套接字，采用TCP，IPv4协议，输入自己的昵称之后经过TCP的三次握手即可连接成功 接下来进入身份确认环节，对AB双方发送的身份信息进行确认，利用对方昵称生成MD5密文，对比发送密文即可判断 MD5 tmp_name; string tmp_s = tmp_name.encode(client_name_tmp); for (int i = 0; i &lt; tmp_s.length(); i++) { client_name[i] = tmp_s[i]; } send_len = send(client, client_name, sizeof(client_name), 0); receive_len = recv(client, server_name, sizeof(server_name), 0); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED); cout &lt;&lt; endl; if (IdConfirm(server_name, \"lkp1\")) { cout &lt;&lt; \"ID Confirm success, Let's chatting...\" &lt;&lt; endl &lt;&lt; endl; } else { cout &lt;&lt; \"ID Confirm failed, Conversation aborted...\"; return 0; } 身份确认成功之后即可进入发送环节，双方回合制发送信息 如果输入12582则表示当前回合结束，对方可发送信息 如果输入12581则表示想要退出聊天，则发送双方结束本次聊天 如果是其他信息，则相对信息进行加密然后发送，为了演示加密过程，在发送信息下方打印出密文和明文详情 实验演示截图为了演示清晰，程序对文字进行了颜色处理，采用最原始聊天的蓝绿风格，并对身份确认环节进行红色处理。 默认双方昵称为lkp1和lkp2。 双方正常对话发送消息 client结束本轮对话，由server发送消息 server发送完消息之后输入12581结束本次对话 接下来演示身份错误环节 实验实现了目标里面的功能并且能够双向通信。 源代码文件树├───Client│——|——client.cpp│——|——client.exe│——|——client.h│——|——MD5.h├───Server│——|——generateKey.cpp│——|——generateKey.exe│——|——MD5.h│——|——server.cpp│——|——server.exe│——|——server.h MD5.h#pragma once #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; using namespace std; #define A 0x67452301 #define B 0xefcdab89 #define C 0x98badcfe #define D 0x10325476 const char str16[] = \"0123456789abcdef\"; const unsigned int T[] = { 0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee, 0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501, 0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be, 0x6b901122,0xfd987193,0xa679438e,0x49b40821, 0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa, 0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8, 0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed, 0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a, 0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c, 0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70, 0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05, 0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665, 0xf4292244,0x432aff97,0xab9423a7,0xfc93a039, 0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1, 0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1, 0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391 }; const unsigned int s[] = { 7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22, 5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20, 4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23, 6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21}; // 第一部分是要进行 HASH 运算的原始明文，第二部分则是其对应的 HASH 值 static const struct data{ string msg; unsigned char hash[16]; }tests[] = { { \"\", { 0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04, 0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e } }, { \"a\", {0x0c, 0xc1, 0x75, 0xb9, 0xc0, 0xf1, 0xb6, 0xa8, 0x31, 0xc3, 0x99, 0xe2, 0x69, 0x77, 0x26, 0x61 } }, { \"abc\", { 0x90, 0x01, 0x50, 0x98, 0x3c, 0xd2, 0x4f, 0xb0, 0xd6, 0x96, 0x3f, 0x7d, 0x28, 0xe1, 0x7f, 0x72 } }, { \"message digest\", { 0xf9, 0x6b, 0x69, 0x7d, 0x7c, 0xb7, 0x93, 0x8d, 0x52, 0x5a, 0x2f, 0x31, 0xaa, 0xf1, 0x61, 0xd0 } }, { \"abcdefghijklmnopqrstuvwxyz\", { 0xc3, 0xfc, 0xd3, 0xd7, 0x61, 0x92, 0xe4, 0x00, 0x7d, 0xfb, 0x49, 0x6c, 0xca, 0x67, 0xe1, 0x3b } }, { \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", { 0xd1, 0x74, 0xab, 0x98, 0xd2, 0x77, 0xd9, 0xf5, 0xa5, 0x61, 0x1c, 0x2c, 0x9f, 0x41, 0x9d, 0x9f } }, { \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", { 0x57, 0xed, 0xf4, 0xa2, 0x2b, 0xe3, 0xc9, 0x55, 0xac, 0x49, 0xda, 0x2e, 0x21, 0x07, 0xb6, 0x7a } }, }; class MD5 { private: unsigned int tempA, tempB, tempC, tempD, strlength; public: MD5() { tempA = A; tempB = B; tempC = C; tempD = D; strlength = 0; } // 填充字符串 vector&lt;unsigned int&gt; padding(string src) { // 以512位,64个字节为一组 unsigned int num = ((src.length() + 8) / 64) + 1; vector&lt;unsigned int&gt; rec(num*16); strlength = num*16; for(unsigned int i = 0; i &lt; src.length(); i++){ // 一个unsigned int对应4个字节，保存4个字符信息 rec[i&gt;&gt;2] |= (int)(src[i]) &lt;&lt; ((i % 4) * 8); } // 补充1000...000 rec[src.length() &gt;&gt; 2] |= (0x80 &lt;&lt; ((src.length() % 4)*8)); // 填充原文长度 rec[rec.size()-2] = (src.length() &lt;&lt; 3); return rec; } // F函数 unsigned int F(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; c) | ((~b) &amp; d); } // G函数 unsigned int G(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; d) | (c &amp; (~d)); } // H函数 unsigned int H(unsigned int b, unsigned int c, unsigned int d) { return b ^ c ^ d; } // I函数 unsigned int I(unsigned int b, unsigned int c, unsigned int d) { return c ^ (b | (~d)); } // 移位操作函数 unsigned int shift(unsigned int a, unsigned int n) { return (a &lt;&lt; n) | (a &gt;&gt; (32 - n)); } // 循环压缩 void iterateFunc(unsigned int* X, int size = 16) { unsigned int a = tempA, b = tempB, c = tempC, d = tempD, rec = 0, g, k; for(int i = 0; i &lt; 64; i++) { if(i &lt; 16) { // F迭代 g = F(b, c, d); k = i; } else if(i &lt; 32) { // G迭代 g = G(b, c, d); k = (1 + 5*i) % 16; } else if(i &lt; 48) { // H迭代 g = H(b, c, d); k = (5 + 3*i) % 16; } else { // I迭代 g = I(b, c, d); k = (7*i) % 16; } rec = d; d = c; c = b; b = b + shift(a + g + X[k] + T[i], s[i]); a = rec; } tempA += a; tempB += b; tempC += c; tempD += d; } // 整理输出 string format(unsigned int num) { string res = \"\"; unsigned int base = 1 &lt;&lt; 8; for(int i = 0; i &lt; 4; i++) { string tmp = \"\"; unsigned int b = (num &gt;&gt; (i * 8)) % base &amp; 0xff; for(int j = 0; j &lt; 2; j++) { tmp = str16[b%16] + tmp; b /= 16; } res += tmp; } return res; } // 编码函数 string encode(string src) { vector&lt;unsigned int&gt; rec = padding(src); for(unsigned int i = 0; i &lt; strlength/16; i++) { unsigned int num[16]; for(int j = 0; j &lt; 16; j++) { num[j] = rec[i*16+j]; } iterateFunc(num, 16); } return format(tempA) + format(tempB) + format(tempC) + format(tempD); } }; generateKey.cpp#include &lt;cstdio&gt; #include &lt;ctime&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;gmp.h&gt; #define KEY_LENGTH 2048 //公钥的长度 #define BASE 16 //输入输出的数字进制 using namespace std; struct key_pair { string n; string d; int e; }; //生成两个大素数 mpz_t * gen_primes() { gmp_randstate_t grt; gmp_randinit_default(grt); gmp_randseed_ui(grt, time(NULL)); mpz_t key_p, key_q; mpz_init(key_p); mpz_init(key_q); mpz_urandomb(key_p, grt, KEY_LENGTH / 2); mpz_urandomb(key_q, grt, KEY_LENGTH / 2); //随机生成两个大整数 mpz_t * result = new mpz_t[2]; mpz_init(result[0]); mpz_init(result[1]); mpz_nextprime(result[0], key_p); //使用GMP自带的素数生成函数 mpz_nextprime(result[1], key_q); mpz_clear(key_p); mpz_clear(key_q); return result; } //生成密钥对 key_pair * gen_key_pair() { mpz_t * primes = gen_primes(); mpz_t key_n, key_e, key_f; mpz_init(key_n); mpz_init(key_f); mpz_init_set_ui(key_e, 65537); //设置e为65537 mpz_mul(key_n, primes[0], primes[1]); //计算n=p*q mpz_sub_ui(primes[0], primes[0], 1); //p=p-1 mpz_sub_ui(primes[1], primes[1], 1); //q=q-1 mpz_mul(key_f, primes[0], primes[1]); //计算欧拉函数φ(n)=(p-1)*(q-1) mpz_t key_d; mpz_init(key_d); mpz_invert(key_d, key_e, key_f); //计算数论倒数 key_pair * result = new key_pair; char * buf_n = new char[KEY_LENGTH + 10]; char * buf_d = new char[KEY_LENGTH + 10]; mpz_get_str(buf_n, BASE, key_n); result-&gt;n = buf_n; mpz_get_str(buf_d, BASE, key_d); result-&gt;d = buf_d; result-&gt;e = 65537; mpz_clear(primes[0]); //释放内存 mpz_clear(primes[1]); mpz_clear(key_n); mpz_clear(key_d); mpz_clear(key_e); mpz_clear(key_f); delete []primes; return result; } key_pair* getKey (char name) { key_pair * p = gen_key_pair(); cout &lt;&lt; \"n = \" &lt;&lt; p-&gt;n &lt;&lt; endl; cout &lt;&lt; \"d = \" &lt;&lt; p-&gt;d &lt;&lt; endl; cout &lt;&lt; \"e = \" &lt;&lt; p-&gt;e &lt;&lt; endl; cout &lt;&lt; name &lt;&lt; \"s public key is:(\" &lt;&lt; p-&gt;n &lt;&lt; \", \" &lt;&lt; p-&gt;e &lt;&lt; \")\" &lt;&lt; endl &lt;&lt; endl; //输出公钥(n, e) cout &lt;&lt; name &lt;&lt; \"s private key is:(\" &lt;&lt; p-&gt;n &lt;&lt; \", \" &lt;&lt; p-&gt;d &lt;&lt; \")\" &lt;&lt; endl &lt;&lt; endl; //输出私钥(n, d) return p; } void generateABKey() { key_pair * A = getKey('A'); key_pair * B = getKey('B'); } int main() { generateABKey(); return 0; } Server.h#pragma once #include &lt;cstdio&gt; #include &lt;ctime&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;gmp.h&gt; #include \"MD5.h\" #define KEY_LENGTH 2048 //公钥的长度 #define BASE 16 //输入输出的数字进制 using namespace std; struct key_pair { string n; string d; int e; string k; }; key_pair* key = new key_pair; void keyInit() { key-&gt;n = \"42ed95a8c26d10e856d7ac17e9451037457d5f6e66b824471229ac1422d28f868d6699492c7c31b6d10ed32ee6ad3cbb00bbefe2e76de75b924342781f3f67fd09a3d67c639363c97af569fb52863901f1b6b5e7901c00c989dd7847fc7f55989bf4775969254c2dc0d8e9f7e7dbb5e158c97f5d7d18de47766ee1efb2a3d7e899d019240701e2dec5ca8473a34cea6b6dcb62cff25d40858df7b37e3c14bac390d26926cf30c977b7417130bced9fcce5b7ff6923ab21652a2bf73c3dd0c40a3398f02261e9bd75a24134264412b3371c03daa715e2ad74c20d0ab895ab7025b0bec1eea316146127a5a6d97aa4f09c82624d7f897ef93a7d114cc0757d4253\"; key-&gt;d = \"1f3c797be0fa3c48e3b716e7b60478b40327a77184596efd089a1068f973a26edef1c29ae73b338caa77abd298f0c38657aa5f245c74ebe4ce17bc1f0a1e72af235fa70c3901223277c3b06a0eb2fc4a4f00c25747e7f9ea16011a5126a45b53b57ddc720b63cff10eaf6e4b38984f83d4077efd281482318231f01b0a19f3fb58f835baa189bd387e4ba9d7da4b597d84fdcffc22e707be41adb6ca20f05787cf7e6d1ef27fb8e18ecb4d7ba9f544488e0d109cad4e7befa47020b8e568cf509543fc972b79aa1a8fb49149b517384b5b458f7a8052c299e3605fe12c786cd80f3fd8a2dc7f0ae67ecf1c3b2212d2b21fe5b7588a2d977af636cc461ec78c99\"; key-&gt;e = 65537; key-&gt;k = \"77232546f0b2983adb0ab839b04b81278bcbdc2d34f06a248333cd33e3c139fb578ca19b389e0253fa6f3b3b41e2fd0f6f1fa7e94499fa212afa7f0b2a89f8681dd00e3207c09586c7c6f923016455b652e93ae4bf3b905d7e955fb3102286d9947247f1e75921aaa35840ad3359091e701c167f28be312116c43a13946d0c8d5da8fa21938be40c1f60821d45ef8530d6e24adfd5ab2a1a6ad34545d83c5fcca02a7f29541d6d4cf29778593958957c9b4ad9693289db7743a05bf88480473dc028e4f8e32ff6bdd206910b971ae00c649038aa59baebe8b7af542e9a9b65f69e7efcc17d6a88244cc9520d4b009371c268058e62d707561825ad5a98a81d11\"; } //加密函数 char * encrypt(const char * plain_text, const char * key_n, int key_e) { mpz_t M, C1, n; mpz_init_set_str(M, plain_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_ui(C1, 0); mpz_powm_ui(C1, M, key_e, n); //使用GMP中模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, C1); return result; } //解密函数 char * decrypt(const char * cipher_text, const char * key_n, const char * key_d) { mpz_t M, C1, n, d; mpz_init_set_str(C1, cipher_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_str(d, key_d, BASE); mpz_init(M); mpz_powm(M, C1, d, n); //使用GMP中的模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, M); return result; } string getTime() {//时间函数，返回一个时间戳 time_t timep; time(&amp;timep); char tmp[64]; strftime(tmp, sizeof(tmp), \"%Y-%m-%d %H:%M:%S\", localtime(&amp;timep)); return tmp; } bool IdConfirm (string ID, string name) { MD5 tmp; string hash = tmp.encode(name); if (ID.compare(hash)) { return false; } return true; } Server.cpp#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;winsock.h&gt; #include&lt;time.h&gt; #include\"windows.h\" #include \"server.h\" #pragma comment(lib,\"ws2_32.lib\")//加载ws2_32.dll #define BUF_SIZE 4096 //指定聊天信息缓冲区大小 using namespace std; int main() { WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); SOCKET server = socket(AF_INET, SOCK_STREAM, 0);//创建server套接字，采用ipv4地址，默认TCP协议 sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET;//套接字地址也采用IPv4地址 server_addr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\");//本机地址 server_addr.sin_port = htons(1234);//端口号 bind(server, (SOCKADDR*)&amp;server_addr, sizeof(server_addr));//将套接字和地址绑定 char server_name[2048] = { 0 };//申请一个2048字节的缓冲区，用于储存服务器的名称 char server_name_tmp[2048] = { 0 }; cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Please enter your nickname:\"; cin.getline(server_name_tmp, 2048); //gets() cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Waiting for connection...\\n\"; listen(server, 1);//进入监听状态，数字1表示队列中只能存在一个请求 /*服务器已经初始化完毕，等待客户机连接*/ char client_name[2048] = { 0 }; SOCKET client; SOCKADDR_IN client_addr; int client_addr_len = sizeof(client_addr); while (true) { client = accept(server, (SOCKADDR*)&amp;client_addr, &amp;client_addr_len); if (client == INVALID_SOCKET) { cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Connection failed.\\n\" &lt;&lt; WSAGetLastError(); } else { cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Connection succeeded!!!\\n\"; break; } } char buffer[BUF_SIZE] = { 0 }; char buffer_send[BUF_SIZE + 100] = { 0 }; char buffer_receive[BUF_SIZE + 100] = { 0 }; int receive_len = 0; int send_len = 0; /*通过建立的连接进行通信*/ //发送和接受客户端与服务端的名字 MD5 tmp_name; string tmp_s = tmp_name.encode(server_name_tmp); for (int i = 0; i &lt; tmp_s.length(); i++) { server_name[i] = tmp_s[i]; } send_len = send(client, server_name, sizeof(server_name), 0); receive_len = recv(client, client_name, sizeof(client_name), 0); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED); cout &lt;&lt; endl; if (IdConfirm(client_name, \"lkp2\")) { cout &lt;&lt; \"ID Confirm success, Let's chatting...\" &lt;&lt; endl &lt;&lt; endl; } else { cout &lt;&lt; \"ID Confirm failed, Conversation aborted...\"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return 0; } keyInit(); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); cout &lt;&lt; \"Please enter the message(just number) you want to send, or enter \\\"12582\\\" to abort this conversation, or enter \\\"12581\\\" to abort this chat\" &lt;&lt; endl; while (true) { while (true) {//接收消息 memset(buffer_receive, 0, sizeof(buffer_receive));//初始化缓冲区 receive_len = recv(client, buffer_receive, sizeof(buffer_receive), 0); //string tmp(buffer_receive); string tmp = decrypt(buffer_receive, key-&gt;n.data(), key-&gt;d.data()); if (strcmp(buffer_receive, \"12581\") == 0) {//如果聊天内容中含有12581，则退出聊天，关闭socket SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY); cout &lt;&lt; \"The program will exit in 3 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 2 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 1 seconds...\"; Sleep(1000); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//恢复原来的颜色 closesocket(server); closesocket(client); WSACleanup(); return 0; } else if (strcmp(buffer_receive, \"12582\") == 0)//如果聊天内容中含有12582，则本回合聊天结束，不然可以继续发送信息 break; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE);//设置蓝色 if (tmp.find(\"0\") != string::npos) { continue; } cout &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl &lt;&lt; \"Message:\" &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"Ciphertext:\" &lt;&lt; buffer_receive &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl; } while (true) {//发送消息 memset(buffer, 0, sizeof(buffer));//清空缓冲区 memset(buffer_send, 0, sizeof(buffer_send)); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);//设置绿色 string tmp_time = getTime(); cout &lt;&lt; tmp_time &lt;&lt; \" \" &lt;&lt; server_name_tmp &lt;&lt; \":\"; cin.getline(buffer, BUF_SIZE); if (strcmp(buffer, \"12582\") == 0) { send_len = send(client, buffer, sizeof(buffer), 0); break; } else if (strcmp(buffer, \"12581\") == 0) { send_len = send(client, buffer, sizeof(buffer), 0); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY); cout &lt;&lt; \"The program will exit in 3 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 2 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 1 seconds...\"; Sleep(1000); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//恢复原来的颜色 closesocket(server); closesocket(client); WSACleanup(); return 0; } cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl &lt;&lt; \"Message:\" &lt;&lt; buffer &lt;&lt; endl; char* tmp = encrypt(buffer, key-&gt;k.data(), key-&gt;e); cout &lt;&lt; \"Ciphertext:\" &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl; char tmp1[10240]; strncpy(tmp1, tmp, strlen(tmp) + 1); send_len = send(client, tmp1, sizeof(tmp1), 0); } } return 0; } Client.h#pragma once #include &lt;cstdio&gt; #include &lt;ctime&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;gmp.h&gt; #include \"MD5.h\" #define KEY_LENGTH 2048 //公钥的长度 #define BASE 16 //输入输出的数字进制 using namespace std; struct key_pair { string n; string d; int e; string k; }; key_pair* key = new key_pair; void keyInit() { key-&gt;n = \"77232546f0b2983adb0ab839b04b81278bcbdc2d34f06a248333cd33e3c139fb578ca19b389e0253fa6f3b3b41e2fd0f6f1fa7e94499fa212afa7f0b2a89f8681dd00e3207c09586c7c6f923016455b652e93ae4bf3b905d7e955fb3102286d9947247f1e75921aaa35840ad3359091e701c167f28be312116c43a13946d0c8d5da8fa21938be40c1f60821d45ef8530d6e24adfd5ab2a1a6ad34545d83c5fcca02a7f29541d6d4cf29778593958957c9b4ad9693289db7743a05bf88480473dc028e4f8e32ff6bdd206910b971ae00c649038aa59baebe8b7af542e9a9b65f69e7efcc17d6a88244cc9520d4b009371c268058e62d707561825ad5a98a81d11\"; key-&gt;d = \"369979d5082ca14d9fe34ac8cd7ddd0415b26906a2d367a1b22b8468ba816ca43edc6997ec9ba5af7cff8b22be305c0fbdbac1464bb55187efdd7b69cfa6099d15c4ab2ccc96bb3058d05c8f696ce54738ba40ce62c1d688b2a19c8940e4c1ee6774f479edafd099166134caebd46b3472e6bc7cac5c75c1976078c94e65a7b164a983dc15d98ed7d95041fa52adb643f87d7590bc1f476264caad4ea47adc7ec6aaedb5afe341a68afc6b8ee32a8eacf17b0d372afcf14258e87901395349a797443e50ee8bddf2fbf121799ba40a3e3b22e76341f07606dc7a810fb000dcbed3fc05a15223b04ff5f9610e9febae25a27a2871a2b75eacaba745e63bbc295d\"; key-&gt;e = 65537; key-&gt;k = \"42ed95a8c26d10e856d7ac17e9451037457d5f6e66b824471229ac1422d28f868d6699492c7c31b6d10ed32ee6ad3cbb00bbefe2e76de75b924342781f3f67fd09a3d67c639363c97af569fb52863901f1b6b5e7901c00c989dd7847fc7f55989bf4775969254c2dc0d8e9f7e7dbb5e158c97f5d7d18de47766ee1efb2a3d7e899d019240701e2dec5ca8473a34cea6b6dcb62cff25d40858df7b37e3c14bac390d26926cf30c977b7417130bced9fcce5b7ff6923ab21652a2bf73c3dd0c40a3398f02261e9bd75a24134264412b3371c03daa715e2ad74c20d0ab895ab7025b0bec1eea316146127a5a6d97aa4f09c82624d7f897ef93a7d114cc0757d4253\"; } //加密函数 char * encrypt(char * plain_text, const char * key_n, int key_e) { mpz_t M, C1, n; mpz_init_set_str(M, plain_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_ui(C1, 0); mpz_powm_ui(C1, M, key_e, n); //使用GMP中模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, C1); return result; } //解密函数 char * decrypt(char * cipher_text, const char * key_n, const char * key_d) { mpz_t M, C1, n, d; mpz_init_set_str(C1, cipher_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_str(d, key_d, BASE); mpz_init(M); mpz_powm(M, C1, d, n); //使用GMP中的模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, M); return result; } string getTime() { time_t timep; time(&amp;timep); char tmp[64]; strftime(tmp, sizeof(tmp), \"%Y-%m-%d %H:%M:%S\", localtime(&amp;timep)); return tmp; } bool IdConfirm (string ID, string name) { MD5 tmp; string hash = tmp.encode(name); if (ID.compare(hash)) { return false; } return true; } Client.cpp#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;winsock.h&gt; #include&lt;time.h&gt; #include\"windows.h\" #include \"client.h\" #pragma comment(lib,\"ws2_32.lib\")//加载ws2_32.dll #define BUF_SIZE 4096 //指定聊天信息缓冲区大小 using namespace std; int main() { WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); SOCKET client = socket(AF_INET, SOCK_STREAM, 0); sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); server_addr.sin_port = htons(1234); char client_name[2048] = { 0 }; char client_name_tmp[2048] = { 0 }; cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Please enter your nickname:\"; cin.getline(client_name_tmp, 2048); connect(client, (SOCKADDR*)&amp;server_addr, sizeof(server_addr)); cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Connection ready.\\n\"; char server_name[2048] = { 0 }; char buffer[BUF_SIZE] = { 0 }; char buffer_send[BUF_SIZE + 100] = { 0 }; char buffer_receive[BUF_SIZE + 100] = { 0 }; int receive_len = 0; int send_len = 0; MD5 tmp_name; string tmp_s = tmp_name.encode(client_name_tmp); for (int i = 0; i &lt; tmp_s.length(); i++) { client_name[i] = tmp_s[i]; } send_len = send(client, client_name, sizeof(client_name), 0); receive_len = recv(client, server_name, sizeof(server_name), 0); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED); cout &lt;&lt; endl; if (IdConfirm(server_name, \"lkp1\")) { cout &lt;&lt; \"ID Confirm success, Let's chatting...\" &lt;&lt; endl &lt;&lt; endl; } else { cout &lt;&lt; \"ID Confirm failed, Conversation aborted...\"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return 0; } keyInit(); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); cout &lt;&lt; \"Please enter the message(just number) you want to send, or enter \\\"12582\\\" to abort this conversation, or enter \\\"12581\\\" to abort this chat\" &lt;&lt; endl; while (true) { while (true) { memset(buffer, 0, sizeof(buffer)); memset(buffer_send, 0, sizeof(buffer_send)); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);//设置绿色 string tmp_time = getTime(); cout &lt;&lt; tmp_time &lt;&lt; \" \" &lt;&lt; client_name_tmp &lt;&lt; \":\"; cin.getline(buffer, sizeof(buffer)); if (strcmp(buffer, \"12581\") == 0) { send_len = send(client, buffer, sizeof(buffer), 0); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY); cout &lt;&lt; \"The program will exit in 3 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 2 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 1 seconds...\"; Sleep(1000); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//恢复原来的颜色 closesocket(client); WSACleanup(); return 0; } else if (strcmp(buffer, \"12582\") == 0) { send_len = send(client, buffer, sizeof(buffer), 0); break; } cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl &lt;&lt; \"Message:\" &lt;&lt; buffer &lt;&lt; endl; char * tmp = encrypt(buffer, key-&gt;k.data(), key-&gt;e); cout &lt;&lt; \"Ciphertext:\" &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl; char tmp1[10240]; strncpy(tmp1, tmp, strlen(tmp) + 1); send_len = send(client, tmp1, sizeof(tmp1), 0); } while (true) { memset(buffer_receive, 0, sizeof(buffer_receive)); receive_len = recv(client, buffer_receive, sizeof(buffer_receive), 0); string tmp = decrypt(buffer_receive, key-&gt;n.data(), key-&gt;d.data()); if (strcmp(buffer_receive, \"12581\") == 0) { SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY); cout &lt;&lt; \"The program will exit in 3 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 2 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 1 seconds...\"; Sleep(1000); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//恢复原来的颜色 closesocket(client); WSACleanup(); return 0; } else if (strcmp(buffer_receive, \"12582\") == 0) break; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE);//设置蓝色 if (tmp.find(\"0\") != string::npos) { continue; } cout &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl &lt;&lt; \"Message:\" &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"Ciphertext:\" &lt;&lt; buffer_receive &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl; } } return 0; }","tags":[]},{"title":"数字签名算法DSA","date":"2022-05-27T09:10:44.000Z","path":"2022/059d9eab6e.html","text":"本文为作者个人作业，仅供参考 实验要求 实验要求通过对数字签字算法DSA的实际操作，理解DSS的基本工作原理。 实验内容 参照教材，熟悉数字签名算法DSA； 参照教材，熟悉杂凑函数算法SHA； 这里给出一个可运行的DSA数字签字演示程序，运行这个程序，对一段文字进行签字和验证，了解DSA算法的签字和验证过程。 杂凑函数SHA-1安全哈希算法(SHA)是基于MD4算法，其结构与MD4非常类似，用于数字签名的标准算法DSS中。 算法实现步骤 将消息摘要转换成位字符串 因为在SHA-算法中，它的输入必须为位，所以首先要将其转化为位字符串，以“abc”字符串来说明问题，因为’a’=97, ‘b’=98, ‘c’=99，所以将其转换为位串后为： 01100001 01100010 01100011 对转换后的位字符串进行补位操作 SHA-算法标准规定，必须对消息摘要进行补位操作，即将输入的数据进行填充，使得数据长度对512求余的结果为448，填充比特位的最高位补一个1，其余的位补0，如果在补位之前已经满足对512取模余数为448，也要进行补位，在其后补一位1即可。总之，补位是至少补一位，最多补512位，依然以“abc”为例，其补位过程如下： 初始的信息摘要：01100001 01100010 01100011 第一步补位：01100001 01100010 01100011 1….. …… 补位最后一位：01100001 01100010 01100011 10…….0(后面补了423个0) 而后将补位操作后的信息摘要转换为十六进制，如下所示： 61626380 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 附加长度值 在信息摘要后面附加64bit的信息，用来表示原始信息摘要的长度，在这步操作之后，信息报文便是512bit的倍数。通常来说用一个64位的数据表示原始消息的长度，如果消息长度不大于2^64，那么前32bit就为0，在进行附加长度值操作后，其“abc”数据报文即变成如下形式： 61626380 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000018 因为“abc”占3个字节，即24位 ，换算为十六进制即为0x18。 初始化缓存 一个160位MD缓冲区用以保存中间和最终散列函数的结果。它可以表示为5个32位的寄存器($H_0$,$H_1$,$H_2$,$H_3$,$H_4$)。初始化为： $H_0$ = 0x67452301 $H_1$ = 0xEFCDAB89 $H_2$ = 0x98BADCFE $H_3$ = 0x10325476 $H_4$ = 0xC3D2E1F0 前四个与上周的MD-5一样，但不同之处为存储为大端序 计算消息摘要 在计算报文之前还要做一些基本的工作，就是在计算过程中要用到的方法。 循环左移操作符Sn(x),x是一个字，也就是32bit大小的变量，n是一个整数且0&lt;=n&lt;=32。Sn(X) = (X&lt;&lt;n)OR(X&gt;&gt;32-n) 在程序中所要用到的常量，这一系列常量字k(0)、k(1)、…k(79)，将其以十六进制表示如下： $K_t$ = 0x5A827999 (0 &lt;= t &lt;= 19) $K_t$ = 0x6ED9EBA1 (20 &lt;= t &lt;= 39) $K_t$ = 0x8F1BBCDC (40 &lt;= t &lt;= 59) $K_t$ = 0xCA62C1D6 (60 &lt;= t &lt;= 79) 所要用到的一系列函数 Ft(b,c,d) ((b&amp;c)|((~b)&amp;d)) (0 &lt;= t &lt;= 19) Ft(b,c,d) (b^c^d) (20 &lt;= t &lt;= 39) Ft(b,c,d) ((b&amp;c)|(b&amp;d)|(c&amp;d)) (40 &lt;= t &lt;= 59) Ft(b,c,d) (b^c^d) (60 &lt;= t &lt;= 79) 计算 计算需要一个缓冲区，由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。80个字的缓冲区被标识为$W_0, W_1,…, W_{79}$ 另外还需要一个一个字的TEMP缓冲区。 为了产生消息摘要，在第4部分中定义的16个字的数据块$M_1, M_2,…, M_n$会依次进行处理，处理每个数据块$M_i$ 包含80个步骤。 现在开始处理$M_1, M_2, … , M_n$。为了处理 $M_i$,需要进行下面的步骤 将 Mi 分成 16 个字 $W_0, W_1, … , W_{15}, W_0$ 是最左边的字 对于 t = 16 到 79 令 $W_t = S_1(W_{t-3} XOR W_{t-8} XOR W_{t- 14} XOR W_{t-16})$. 令 A = $H_0$, B = $H_1$, C = $H_2$, D = $H_3$, E = $H_4$. 对于 t = 0 到 79，执行下面的循环 TEMP = S5(A) + ft(B,C,D) + E + Wt + $K_t$; E = D; D = C; C = S30(B); B = A; A = TEMP; 令 $H_0$ = $H_0$ + A, $H_1$ = $H_1$ + B, $H_2$ = $H_2$ + C, $H_3$ = $H_3$ + D, $H_4$ = $H_4$ + E. 在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识$H_0$ $H_1$ $H_2$ $H_3$ $H_4$. SHA-1在DSS中的应用在DSS（数字签名标准）中，使用数字签名算法DSA和哈希函数SHA-1结合完成数字签名。 数字签名算法DSADSA是在ElGamal和Schnorr两个签名方案的基础上设计的，其安全性基于求离散对数的困难性。 算法描述 全局变量 p：满足$2^{L-1}&lt;p&lt;2^L$的大素数，其中$512\\leq L\\leq 1024$且$L$是64的倍数。 q：$p-1$的素因子，满足$2^{159}&lt;p&lt;2{160}$，即$q$长为160比特。 g：$g\\equiv h^{(p-1)/q}modp$，其中$h$是满足$1&lt;h&lt;p-1$且使得$h^{(p-1)/q}modp&gt;1$的任一整数。 密钥x $x$是满足$0&lt;x&lt;q$的随机数或伪随机数。 公钥y $y\\equiv g^xmodp$ 用户的随机数选择k $k$是满足$0&lt;k&lt;q$的随机数或伪随机数。 签名过程 用户对消息$M$的签名为$(r,s)$，其中$r\\equiv (g^kmodp)modq$，$s\\equiv [k^{-1}(H(M)+xr)]modq$，$H(M)$是由SHA求出的哈希值。 验证过程 设接收方接收到的消息为$M’$，签名为$(r’,s’)$。计算 $\\omega \\equiv (s’)^{-1}modq$ $u_1\\equiv [H(M’)\\omega ]modq$ $u_2\\equiv r’\\omega modq$ $v\\equiv [(g^{u_1}y^{u_2})modp]modq$。 检查$v$是否等于$r’$，若相等，则证明签名有效，这是因为 若$(M’,r’,s’)=(M,r,s)$， 则$v\\equiv [(g^{H(M)\\omega }g^{xr\\omega })modp]modq\\equiv [g^{(H(M)+xr)^{-1}}modp]modq\\equiv (g^kmodp)modq\\equiv r$ 算法的其中的4个函数分别为： $s\\equiv f_1[H(M),k,x,r,q]\\equiv [k^{-1}(H(M)+xr)]modq$ $r=f_2(k,q,p,g)\\equiv (g^kmodp)modq$ $\\omega =f_3(s’,q)\\equiv (s’)^{-1}modq$ $v\\equiv f_4(y,q,g,H(M’),\\omega ,r’)\\equiv [(g^{(H(M’)\\omega )modq}y^{r’\\omega modq})modp]modq$ DSA实例实验将对消息“i love you，china”进行签名。 在DSATool.exe程序中，选择大素数P的位数为512，数据呈现格式为10进制，生成如下所示的大素数P、素因子Q、G以及用户秘密钥X和用户公开钥Y。 为待签消息选取如下所示的随机秘密数K，并产生签名(r,s)。K=2553DD1A0EEEABFC7781E5444DCD517932AB269E 对该签名进行验证，计算能成功通过。 当修改签名中的某一位时（如将第一位7改为8），则验证将无法通过。 通过上述检测可以验证DSA的有效性和雪崩效应。","tags":[]},{"title":"一些方便好用的常用命令","date":"2022-05-26T15:27:14.000Z","path":"2022/056ac63caa.html","text":"本文记录一些平时遇到的没必要记忆却又需要的指令 VSCode终端编码方式修改VScode的默认编码方式为UTF-8，中国地区下cmd的编码方式GBK，所以会导致在终端运行程序打印中文出乱码的情况，修改编码方式即可 在终端运行以下指令即可修改cmd编码方式： chcp 65001 //UTF-8编码 chcp 936 //GBK编码 国内快速访问Github 打开IPAddress.com网站,查询下列三个地址的ip github.comassets-cnd.github.comgibhut.global.ssl.fastly.net 修改本地hosts文件(window系统) 在C:\\Windows\\System32\\drivers\\etc 找到hosts文件，然后添加下列数据，注意把下面的ip改成你自己查询到ip地址。 140.82.114.3 github.com 185.199.108.153 assets-cdn.github.com 199.232.69.194 github.global.ssl.fastly.net 刷新本地dns缓存 Win+R打开cmd，输入命令 ipconfig/flushdns 此时就配置成功了，然后就可以去访问啦 当然科学上网也是可以的 windows查看文件命令dir //查看当前文件下文件夹详细信息 dir /b //查看当前文件夹下文件夹 dir /b /s //查看当前文件夹下文件夹及文件信息","tags":[{"name":"command","slug":"command","permalink":"https://kpl0111.github.io/blog/tags/command/"}]},{"title":"MarkDown常用语法","date":"2022-05-26T15:26:29.000Z","path":"2022/05d18ae5e4.html","text":"一些常用基本语法不过多介绍，详细可以参看MarkDown官方教程 这里只介绍一些实用但是容易被忽视的一些语法 给出一些例子代码： MarkDown引用 使用标记符 &gt; 对内容进行引用： 引用一段内容 引用一段内容 引用的多层嵌套：只要根据层次加上不同数量的 &gt; 符号 示例： &gt; 请问 Markdwon 怎么用？ - 小白 &gt;&gt; 自己看教程！ - 愤青 &gt;&gt;&gt; 教程在哪？ - 小白 &gt;&gt;&gt;&gt; 我也不知道在哪！ - 愤青 &gt;&gt;&gt;&gt;&gt; 那你回答个屁。 - 小白 显示效果： 请问 Markdwon 怎么用？ - 小白 自己看教程！ - 愤青 教程在哪？ - 小白 我也不知道在哪！ - 愤青 那你回答个屁。 - 小白 引用其它要素： 引用的区块内也可以使用其他的语法，包括标题、列表、代码区块等。 示例： &gt; 1.1 这是第一行列表项。 &gt;&gt; 2.1 这是第二行列表项。 &gt;&gt;&gt; - 这是第三行列表项。 &gt; ### 给出一些例子代码： 显示效果： 1.1 这是第一行列表项。 2.1 这是第二行列表项。 这是第三行列表项。 给出一些例子代码： 引用中内容换行： 有时候引用的内容太长，需要分段落层次，可以使用 &lt; br &gt; 实现换行。 举例： &gt; $\\underline{幽默小故事，笑死人不偿命}$&lt;br&gt; 我：“老板，你这清炒油麦菜是荤菜还是素菜？ 老板：“当然是素菜了”&lt;br&gt; 我：“那这条虫是怎么回事” 老板：“呃……它也是来吃饭的。”&lt;br&gt; 我：“它吃饭凭什么我付钱？我又不认识它！” 老板哭着说：“它为了这顿饭，把命都丢了，你还能要求它AA制吗？” 显示效果： 下划线 示例： $\\underline{给这条语句加一个下划线}$ 给这条语句加一个下划线‾\\underline{给这条语句加一个下划线} 给这条语句加一个下划线​ 效果：","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://kpl0111.github.io/blog/tags/MarkDown/"}]},{"title":"LeetCode笔记-数组","date":"2022-05-25T11:55:34.000Z","path":"2022/05fcf9ff47.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 数组 二分 双指针 螺旋矩阵 数组需要两点注意的是： 数组下标都是从0开始的 数组内存空间的地址是连续的 正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址，而且数组不能增删，只能覆盖。在C++中二维数组在地址空间上是连续的。但是Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。所以看不到每个元素的地址情况。 二分使用二分的前提是： 有序数组 无重复元素 使用二分时一般需要注意边界条件的处理，一般包括以下两种情况： 左闭右闭 左闭右开 二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 双指针使用双指针可以实现滑动窗口等操作，避免了循环嵌套，大大降低了时间复杂度 螺旋矩阵要注意四个方向临界条件以及区间类型都要一致","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://kpl0111.github.io/blog/tags/LeetCode/"}]},{"title":"MD5加密算法C++实现","date":"2022-05-23T12:10:38.000Z","path":"2022/05d90a8c79.html","text":"实验目的本次实验通过C++编程实现MD5加密算法，通过了解MD5算法加深对Hash函数的认识 实验原理Hash 函数是将任意长的数字串转换成一个较短的定长输出数字串的函数，输出的结果称为 Hash 值。Hash 函数具有如下特点： 快速性：对于任意一个输入值 x，由 Hash 函数H(x) ，计算 Hash值 y，即H(x) = y是非常容易的 单向性：对于任意一个输出值 y，希望反向推出输入值 x，使得H(x) = y，是非常困难的。 无碰撞性：包括强无碰撞性和弱无碰撞性，一个好的 Hash 函数应该满足强无碰撞性，即找到两个不同的数字串 x 和 y，满足H(x) = H(y)，在计算上是不可能的。 MD5算法满足Hash特性，然而需要说明的是,2004年8月，在Crypto2004国际密码学会议上，山东大学王小云教授发现了一种找到MD5散列函数的碰撞的方法，即可以找到两个不同的输入x和y，得到相同的Hash结果。这一发现意味着采用MD5算法的数字签名、完整性检验等信息安全应用系统将不在安全了，这就促使信息安全系统的设计者尽快去寻找和探索新的Hash算法。 MD5算法模块拆解 获取输入，该模块用于获取一段明文字符，不定长 对获取的不定长字符串进行填充,使其字节长度满足n*512 + 448, 填充规则是第一位填充1，后续填充0，直至满足上述条件，最后再用一个64为二进制字符串表示明文长度，这样填充之后长度为(n + 1)*512 // 填充字符串 vector&lt;unsigned int&gt; padding(string src) { // 以512位,64个字节为一组 unsigned int num = ((src.length() + 8) / 64) + 1; vector&lt;unsigned int&gt; rec(num*16); strlength = num*16; for(unsigned int i = 0; i &lt; src.length(); i++){ // 一个unsigned int对应4个字节，保存4个字符信息 rec[i&gt;&gt;2] |= (int)(src[i]) &lt;&lt; ((i % 4) * 8); } // 补充1000...000 rec[src.length() &gt;&gt; 2] |= (0x80 &lt;&lt; ((src.length() % 4)*8)); // 填充原文长度 rec[rec.size()-2] = (src.length() &lt;&lt; 3); return rec; } 字符串分块函数，将上述填充之后的字符串分割为L个512字节长度的字符串 循环压缩函数：对每个512-bit分组进行64轮迭代运算 对分组（A, B, C, D）中的A进行迭代运算 公式为：A &lt;= B + ((A + f(B,C,D) + X[k] + T[i])) &lt;&lt; S[i] 其中： A,B,C,D代表MD5缓冲区当前的数值 f为轮函数，1-16轮迭代使用F函数，17-32轮迭代使用G函数，33-48轮迭 代使用H函数，49-64轮迭代使用I函数 // F函数 unsigned int F(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; c) | ((~b) &amp; d); } // G函数 unsigned int G(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; d) | (c &amp; (~d)); } // H函数 unsigned int H(unsigned int b, unsigned int c, unsigned int d) { return b ^ c ^ d; } // I函数 unsigned int I(unsigned int b, unsigned int c, unsigned int d) { return c ^ (b | (~d)); } // 移位操作函数 unsigned int shift(unsigned int a, unsigned int n) { return (a &lt;&lt; n) | (a &gt;&gt; (32 - n)); } X[k]代表当前处理消息分组的第k个32位字，X[k]由第n轮迭代对应的顺序表决定 T[i]代表T表的第i项的值，T[i] = int(2^32 * |sin(i)|) S[i]对应第i轮的左循环移位的s值 对分组（A,B,C,D）作循环轮换 公式为：（B,C,D,A）&lt;=（A,B,C,D） 按照1， 2步骤进行四轮循环压缩 // 循环压缩 void iterateFunc(unsigned int* X, int size = 16) { unsigned int a = tempA, b = tempB, c = tempC, d = tempD, rec = 0, g, k; for(int i = 0; i &lt; 64; i++) { if(i &lt; 16) { // F迭代 g = F(b, c, d); k = i; } else if(i &lt; 32) { // G迭代 g = G(b, c, d); k = (1 + 5*i) % 16; } else if(i &lt; 48) { // H迭代 g = H(b, c, d); k = (5 + 3*i) % 16; } else { // I迭代 g = I(b, c, d); k = (7*i) % 16; } rec = d; d = c; c = b; b = b + shift(a + g + X[k] + T[i], s[i]); a = rec; } tempA += a; tempB += b; tempC += c; tempD += d; } MD5编码主函数：用于调用前面的功能函数对明文字符串进行MD5编码 输入待加密的明文字符串 对明文字符串进行填充 对填充后的明文字符串进行分块（$Y_q$） 使用预设的初始值初始化MD5缓冲区间（IV） 对各个分块字符串利用公式HMD5($CV_(i-1), Y_i$)进行循环压缩，运算结果作为下一块的输入（$CV_i$） 当所有的分块迭代完成后，输出结果$CV_L$，L表示最后一个分块的序号 // MD5加密函数 string encode(string src) { vector&lt;unsigned int&gt; rec = padding(src); for(unsigned int i = 0; i &lt; strlength/16; i++) { unsigned int num[16]; for(int j = 0; j &lt; 16; j++) { num[j] = rec[i*16+j]; } iterateFunc(num, 16); } return format(tempA) + format(tempB) + format(tempC) + format(tempD); } 程序流程图 测试结果对测试数据进行测试，测试结果如下： 雪崩测试对每个测试数据均在字符串末尾加上一个空格得到密文改变位数如下 数据i 1 2 3 4 5 6 7 平均改变位数 改变位数 31 28 29 30 30 29 28 29 源代码//MD5.h #pragma once #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; using namespace std; #define A 0x67452301 #define B 0xefcdab89 #define C 0x98badcfe #define D 0x10325476 const char str16[] = \"0123456789abcdef\"; const unsigned int T[] = { 0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee, 0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501, 0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be, 0x6b901122,0xfd987193,0xa679438e,0x49b40821, 0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa, 0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8, 0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed, 0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a, 0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c, 0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70, 0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05, 0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665, 0xf4292244,0x432aff97,0xab9423a7,0xfc93a039, 0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1, 0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1, 0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391 }; const unsigned int s[] = { 7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22, 5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20, 4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23, 6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21}; // 第一部分是要进行 HASH 运算的原始明文，第二部分则是其对应的 HASH 值 static const struct data{ string msg; unsigned char hash[16]; }tests[] = { { \"\", { 0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04, 0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e } }, { \"a\", {0x0c, 0xc1, 0x75, 0xb9, 0xc0, 0xf1, 0xb6, 0xa8, 0x31, 0xc3, 0x99, 0xe2, 0x69, 0x77, 0x26, 0x61 } }, { \"abc\", { 0x90, 0x01, 0x50, 0x98, 0x3c, 0xd2, 0x4f, 0xb0, 0xd6, 0x96, 0x3f, 0x7d, 0x28, 0xe1, 0x7f, 0x72 } }, { \"message digest\", { 0xf9, 0x6b, 0x69, 0x7d, 0x7c, 0xb7, 0x93, 0x8d, 0x52, 0x5a, 0x2f, 0x31, 0xaa, 0xf1, 0x61, 0xd0 } }, { \"abcdefghijklmnopqrstuvwxyz\", { 0xc3, 0xfc, 0xd3, 0xd7, 0x61, 0x92, 0xe4, 0x00, 0x7d, 0xfb, 0x49, 0x6c, 0xca, 0x67, 0xe1, 0x3b } }, { \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", { 0xd1, 0x74, 0xab, 0x98, 0xd2, 0x77, 0xd9, 0xf5, 0xa5, 0x61, 0x1c, 0x2c, 0x9f, 0x41, 0x9d, 0x9f } }, { \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", { 0x57, 0xed, 0xf4, 0xa2, 0x2b, 0xe3, 0xc9, 0x55, 0xac, 0x49, 0xda, 0x2e, 0x21, 0x07, 0xb6, 0x7a } }, }; class MD5 { private: unsigned int tempA, tempB, tempC, tempD, strlength; public: MD5() { tempA = A; tempB = B; tempC = C; tempD = D; strlength = 0; } // 填充字符串 vector&lt;unsigned int&gt; padding(string src) { // 以512位,64个字节为一组 unsigned int num = ((src.length() + 8) / 64) + 1; vector&lt;unsigned int&gt; rec(num*16); strlength = num*16; for(unsigned int i = 0; i &lt; src.length(); i++){ // 一个unsigned int对应4个字节，保存4个字符信息 rec[i&gt;&gt;2] |= (int)(src[i]) &lt;&lt; ((i % 4) * 8); } // 补充1000...000 rec[src.length() &gt;&gt; 2] |= (0x80 &lt;&lt; ((src.length() % 4)*8)); // 填充原文长度 rec[rec.size()-2] = (src.length() &lt;&lt; 3); return rec; } // F函数 unsigned int F(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; c) | ((~b) &amp; d); } // G函数 unsigned int G(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; d) | (c &amp; (~d)); } // H函数 unsigned int H(unsigned int b, unsigned int c, unsigned int d) { return b ^ c ^ d; } // I函数 unsigned int I(unsigned int b, unsigned int c, unsigned int d) { return c ^ (b | (~d)); } // 移位操作函数 unsigned int shift(unsigned int a, unsigned int n) { return (a &lt;&lt; n) | (a &gt;&gt; (32 - n)); } // 循环压缩 void iterateFunc(unsigned int* X, int size = 16) { unsigned int a = tempA, b = tempB, c = tempC, d = tempD, rec = 0, g, k; for(int i = 0; i &lt; 64; i++) { if(i &lt; 16) { // F迭代 g = F(b, c, d); k = i; } else if(i &lt; 32) { // G迭代 g = G(b, c, d); k = (1 + 5*i) % 16; } else if(i &lt; 48) { // H迭代 g = H(b, c, d); k = (5 + 3*i) % 16; } else { // I迭代 g = I(b, c, d); k = (7*i) % 16; } rec = d; d = c; c = b; b = b + shift(a + g + X[k] + T[i], s[i]); a = rec; } tempA += a; tempB += b; tempC += c; tempD += d; } // 整理输出 string format(unsigned int num) { string res = \"\"; unsigned int base = 1 &lt;&lt; 8; for(int i = 0; i &lt; 4; i++) { string tmp = \"\"; unsigned int b = (num &gt;&gt; (i * 8)) % base &amp; 0xff; for(int j = 0; j &lt; 2; j++) { tmp = str16[b%16] + tmp; b /= 16; } res += tmp; } return res; } // 编码函数 string encode(string src) { vector&lt;unsigned int&gt; rec = padding(src); for(unsigned int i = 0; i &lt; strlength/16; i++) { unsigned int num[16]; for(int j = 0; j &lt; 16; j++) { num[j] = rec[i*16+j]; } iterateFunc(num, 16); } return format(tempA) + format(tempB) + format(tempC) + format(tempD); } }; \\\\MD5.cpp #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; #include &lt;string.h&gt; #include \"MD5.h\" using namespace std; int main() { MD5 test; string a = \"\"; cout &lt;&lt; \"Plain Text: \"; getline(cin,a); cout &lt;&lt; \"result: \" &lt;&lt; test.encode(a) &lt;&lt; endl; return 0; }","tags":[{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"},{"name":"密码学","slug":"密码学","permalink":"https://kpl0111.github.io/blog/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"MD5","slug":"MD5","permalink":"https://kpl0111.github.io/blog/tags/MD5/"}]},{"title":"关于Eclipse安卓开发中的文件调用","date":"2022-05-17T18:35:09.000Z","path":"2022/05442e8a7e.html","text":"问题描述最近在用Eclipse做Android的时候使用jxl库简单处理了xls文件，由于我对xls文件处理不太熟练，于是创建了一个Java项目进行简单测试，没问题之后直接在安卓项目使用，但是却发现即使我把xls文件放在assets文件夹下并在Build Path里面勾选了assets文件夹依旧会抛出找不到文件的错误：FileNotFoundException，采用了 file:///android_asset/xxx.html 和 /assets/xxx.xls 均没有效果，依旧会抛出错误。 问题原因一般情况下我们在本地项目引用文件，直接用绝对路径或者相对路径都可以，这两者都可以在资源文件的属性里面查看，如下图所示： Android项目打包生成APK之后，会将项目打包成Jar包或者war包，此时就不会存在 assets/resources 目录，JVM会在编译项目时，主动将 java文件编译成 class文件 和 resources 下的静态文件放在 target/classes目录下； 也就是说我们在打包之后上述目录结构已经发生变化，此时再用原来的路径去索引文件，必然是索引不到的，那么我们还想去索引这个文件怎么办呢？ 解决方案我们可以用Java提供的方法获取文件流 InputStream input = this.getClass().getResourceAsStream(\"/assets/xxx.xls\"); 从而去使用文件。 需要注意的是，路径的开头的 / 是不能少的，它代表的就是从src目录-根目录，而资源文件路径就是从src开始找，这样工程打包以后同样可以找到路径。 参考：Java项目读取resources资源文件路径那点事","tags":[{"name":"Android","slug":"Android","permalink":"https://kpl0111.github.io/blog/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://kpl0111.github.io/blog/tags/Java/"}]},{"title":"Hello kpl!","date":"2022-05-16T02:38:03.577Z","path":"2022/054a17b156.html","text":"","tags":[]},{"title":"Vim参数推荐","date":"2022-02-18T15:06:31.000Z","path":"2022/0257c5ab7b.html","text":"“ All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by“ the call to :runtime you can find below. If you wish to change any of those“ settings, you should do it in this file (/etc/vim/vimrc), since debian.vim“ will be overwritten everytime an upgrade of the vim packages is performed.“ It is recommended to make changes after sourcing debian.vim since it alters“ the value of the ‘compatible’ option. runtime! debian.vim “ Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.“ This happens after /etc/vim/vimrc(.local) are loaded, so it will override“ any settings in these files.“ If you don’t want that to happen, uncomment the below line to prevent“ defaults.vim from being loaded.“ let g:skip_defaults_vim = 1 “ Uncomment the next line to make Vim more Vi-compatible“ NOTE: debian.vim sets ‘nocompatible’. Setting ‘compatible’ changes numerous“ options, so any other options should be set AFTER setting ‘compatible’.“set compatible “ Vim5 and later versions support syntax highlighting. Uncommenting the next“ line enables syntax highlighting by default.syntax on “ If using a dark background within the editing area and syntax highlighting“ turn on this option as wellset background=dark “ Uncomment the following to have Vim jump to the last position when“ reopening a file“au BufReadPost * if line(“‘\"“) &gt; 1 &amp;&amp; line(“‘\"“) &lt;= line(“$”) | exe “normal! g’\"“ | endif “ Uncomment the following to have Vim load indentation rules and plugins“ according to the detected filetype.if has(“autocmd”) filetype plugin indent onendif “ The following are commented out as they cause vim to behave a lot“ differently from regular Vi. They are highly recommended though.“set showcmd “ Show (partial) command in status line.set showmatch “ Show matching brackets.set ignorecase “ Do case insensitive matchingset smartcase “ Do smart case matchingset incsearch “ Incremental search“set autowrite “ Automatically save before commands like :next and :makeset hidden “ Hide buffers when they are abandoned“set mouse=a “ Enable mouse usage (all modes) “ Source a global configuration file if availableif filereadable(“/etc/vim/vimrc.local”) source /etc/vim/vimrc.localendif setlocal noswapfileset bufhidden = hide“colorscheme eveningset numberset cursorlineset rulerset shiftwidth = 4set softtabstop = 4set tabstop = 4set nobackupset autochdirset backupcopy = yesset hlsearchset noerrorbellsset novisualbellset t_vb=set matchtime=2set magicset smartindentset backspace=ident,eol,startset cmdheight=1set laststatus=2set statusline=\\ %&lt;%F[%1*%M%*%n%R%H]%=\\ %y\\ %0(%{&amp;fileformat}\\ %{&amp;encoding}\\ Ln\\ %l.\\Col\\ %c/%L%)set foldenableset foldmethod=syntaxset foldcolumn=0setlocal foldlevel=1nnoremap @=((foldclosed(line(‘,’)) &lt; 0) ? ‘zc’ : ‘zo’)","tags":[{"name":"Vim","slug":"Vim","permalink":"https://kpl0111.github.io/blog/tags/Vim/"}]},{"title":"物联网安全复习总结","date":"2022-01-04T04:29:58.000Z","path":"2022/018a8f3fb6.html","text":"复习时随手记录，并不完整 物联网安全根据国际电信联盟的定义, 物联网( internet of things, IOT) 主要解决: 物品到物品( thing to thing,T2T) 人到物品( human to thing, H2T) 人到人( human to human, H2H)之间的互联 第1章 物联网安全需求分析与其他传统网络相比, 物联网感知节点大都部署在无人监控的场景中, 具有能力脆弱、资源受限等特点,这些都导致很难直接将传统计算机网络的安全算法和协议应用于物联网 从物联网的功能上来说，应该具备四个特征： 一是全面感知能力，可以利用RFID、传感器、二维条形码等获取被控/被测物体的信息; 二是数据信息的可靠传递，可以通过各种电信网络与互联网的融合，将物体的信息实时准确地传递出去; 三是可以智能处理，利用现代控制技术提供的智能计算方法，对大量数据和信息进行分析和处理，对物体实施智能化的控制。 四是可以根据各个行业、各种业务的具体特点形成各种单独的业务应用，或者整个行业及系统的建成应用解决方案 物联网结构和层次： 感知识别层：重点考虑数据隐私的保护； 传感器，RFID，二维条形码… 网络构建层：重点考虑网络传输安全； 互联网 无线宽带网 无线低速网 移动通信网 管理服务层：重点考虑信息安全； 管理服务层位于感知识别和网络构建层之上，综合应用层之下，人们通常把物联网应用冠以“智能”的名称，如智能电网、智能交通、智能物流等，其中的智慧就来自这一层 数据库：海量性，多态性，关联性，语义性 海量信息存储：网络附加存储（NAS ，Network Attached Storage）和专用存储区域网络（SAN ,Storage Area Network） 数据中心 搜索引擎 数据挖掘技术 综合应用层：重点考虑应用系统安全； 智能物流 智能交通 绿色建筑 智能电网 环境监测 与互联网相比, 物联网主要实现人与物、物与物之间的通信, 通信的对象扩大到了物品。 感知层的安全需求可以总结为如下几点： 机密性：多数网络内部不需要认证和密钥管理，如统一部署的共享一个密钥的传感网。 密钥协商：部分内部节点进行数据传输前需要预先协商会话密钥。 节点认证：个别网络（特别当数据共享时）需要节点认证，确保非法节点不能接入。 信誉评估：一些重要网络需要对可能被敌手控制的节点行为进行评估，以降低敌手入侵后的危害（某种程度上相当于入侵检测）。 安全路由：几乎所有网络内部都需要不同的安全路由技术。 物联网网络构建层将会主要遇到下列安全挑战： 拒绝服务攻击（DOS）攻击、分布式拒绝服务攻击（DDOS）攻击； 假冒攻击、中间人攻击等； 跨异构网络的网络攻击。 网络构建层的安全机制可分为端到端机密性和节点到节点机密性。 对于端到端机密性，需要建立如下安全机制： 端到端认证机制、 端到端密钥协商机制、 密钥管理机制 机密性算法选取机制等。 管理服务层的安全挑战包括如下几个方面： 来自于超大量终端的海量数据的识别和处理； 智能变为低能； 自动变为失控（可控性是信息安全的重要指标之一）； 灾难控制和恢复； 非法人为干预（内部攻击）； 设备（特别是移动设备）的丢失 为了满足物联网智能管理服务层的基本安全需求，需要如下的安全机制。 可靠的认证机制和密钥管理方案； 高强度数据机密性和完整性服务； 可靠的密钥管理机制，包括PKI和对称密钥的有机结合机制； 可靠的高智能处理手段； 入侵检测和病毒检测； 恶意指令分析和预防，访问控制及灾难恢复机制； 保密日志跟踪和行为分析，恶意行为模型的建立； 密文查询、秘密数据挖掘、安全多方计算、安全云计算技术等； 移动设备文件（包括秘密文件）的可备份和恢复； 移动设备识别、定位和追踪机制 应用层的安全挑战和安全需求主要来自于： 如何根据不同访问权限对同一数据库内容进行筛选； 如何提供用户隐私信息保护，同时又能正确认证； 如何解决信息泄露追踪问题； 如何进行计算机取证； 如何销毁计算机数据； 如何保护电子产品和软件的知识产权。 基于物联网综合应用层的安全挑战和安全需求，需要如下的安全机制： 有效的数据库访问控制和内容筛选机制； 不同场景的隐私信息保护技术； 叛逆追踪和其他信息泄露追踪机制； 有效的计算机取证技术； 安全的计算机数据销毁技术； 安全的电子产品和软件的知识产权保护技术 第2章 物联网安全技术框架现代经常涉及的信息安全技术主要有数据加密、身份认证、访问控制和口令、数字证书、电子签证机关（CA）、数字签名等常用信息安全技术 安全技术简介 数据加密 身份验证 访问控制 自由访问控制：用户有权对自身所创建的访问对象进行访问 强制访问控制，按照系统规则对用户所创建对象进行控制，即便是创建者，也可能无权访问对象 口令（密码）：实际上，弱口令。缺省口令和没有口令的账号均应该从数据库中删除 网络数据流窃听口令，如果明文传输，则可能被窃取 认证消息截取/重放，用加密口令实现系统登录 字典攻击 穷举攻击，字典攻击的加强版，使用字符串的全集作为字典 窥探，窥探合法用户输入口令过程 社交工程 垃圾搜索 数字证书：一个数字文件，一般由四部分构成 持有人的姓名，地址等信息 公开密钥 证书序号，有效期限 发证单位的数字签名 数字签名 本身是一种解密过程，而且是非对称密钥，类似于与校验和 使用用途，区别身份，鉴权，保证完整性，不可抵赖（即承认发送来源） 数据加密 分类 私用密钥（对称密钥） 信息的发送方和接收方使用同一个密钥进行加密和解密 适合对大数据量进行加密，密钥管理困难 公共密钥（非对称密钥） 信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，但加密和解密速度却比对称密钥加密慢得多 能够完成发送方的身份认证和接收方无法伪造报文的功能 通过公钥推算出私钥的算法必须不可能实现 物联网中的加密机制传统的IP网络加密：需要在感知层运行加密/解密算法，需要存储开销，CPU开销，而且需要能量 节点认证机制：PKI（Public Key Infrastructure ）即“公钥基础设施”，是一种遵循既定标准的密钥管理平台,它能够为所有网络应用提供加密和数字签名等密码服务及所必需的密钥和证书管理体系。简单来说，PKI就是利用公钥理论和技术建立的提供安全服务的基础设施 访问控制，由给人授权访问转变为给机器授权访问 态势分析及其他：评估现在以及未来一段时间内的网络运行状态 实现统一的密钥管理系统可以采用两种方式: 一是以互联网为中心的集中式管理方式 二是以各自网络为中心的分布式管理方式 其安全需求体现在 密钥生成或更新算法的安全性 前向私密性 后向私密性或可扩展性 抗同谋攻击 源端认证和新鲜性 第3章 密码与身份认证技术密码学基本概念密码学是主要研究通信安全和保密的学科，他包括两个分支：密码编码学和密码分析学 密码编码学主要研究对信息进行变换，以保护信息在传递过程中不被敌方窃取、解读和利用的方法 密码分析学则于密码编码学相反，它主要研究如何分析和破译密码 使用密码学可以达到以下目的： 保密性：防止用户的标识或数据被读取。 数据完整性：防止数据被更改。 身份验证：确保数据发自特定的一方 加密算法应在公开时不影响明文和密钥的安全 从密码学发展历程来看，可分为： 古典密码（以字符为基本加密单元的密码） 代替密码 单表替换密码 凯撒密码：某字母用右边第k个字母表示，Z后面是A 密钥短语密码 同音替换密码 多字母 组替换 密码 多表替换密码 置换密码 现代密码（以信息块为基本加密单元的密码） 分组密码 流密码 密钥加密系统 对称密码系统的安全性依赖于以下两个因素。 第一，加密算法必须是足够强的，仅仅基于密文本身去解密信息在实践上是不可能的； 第二，加密方法的安全性依赖于密钥的秘密性，而不是算法的秘密性，因此我们没有必要确保算法的秘密性，而需要保证密钥的秘密性 对称密码体制的特点是：对称加密算法使用起来简单快捷，密钥较短，且破译困难。 密钥难于安全传送。 密钥量太大，难于进行管理。 无法满足互不相识的人进行私人谈话时保密要求。 难于解决数字签名验证的问题。 相对于对称密钥密码体系，非对称密钥加密系统最大的特点在于加密和解密使用不同的密钥 非对称密钥技术的优点是：易于实现，使用灵活，密钥较少，可以满足互不相识的人之间进行私人谈话时的保密性要求，可以完成数字签名和数字鉴别。 弱点在于：要取得较好的加密效果和强度，必须使用较长的密钥。 现代加密算法对称加密算法在对称加密算法中，只有一个密钥用来加密和解密信息，即加密和解密采用相同的密钥。常用的算法包括： DES（Data Encryption Standard）： 数据加密标准，速度较快，适用于加密大量数据的场合。 3DES（Triple DES）： 是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。 AES（Advanced Encryption Standard）： AES高级加密标准，是下一代的加密算法标准，速度快，安全级别高 非对称加密算法 RSA：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的； RSA是第一个既能用于数据加密也能用于数字签名的算法 DSA（Digital Signature Algorithm）： 数字签名算法，是一种标准的 DSS（数字签名标准）； 除了加密外，公开密钥密码学最显著的成就是实现了数字签名。 加密算法的选择 我们应该根据自己的使用特点来确定： 由于非对称加密算法的运行速度比对称加密算法的速度慢很多，当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。 对称加密算法不能实现签名，因此签名只能非对称算法。 由于对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。 在实际的操作过程中，我们通常采用的方式是： 采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。 认证与身份证明身份证明系统的组成 示证者P(Prover)，出示证件的人，又称作申请者(Claimant)，提出某种要求； 验证者V(Verifier)，检验示证者提出的证件的正确性和合法性，决定是否满足其要求； 攻击者，可以窃听和伪装示证者骗取验证者的信任。 可信赖者，参与调解纠纷。必要时的第四方 物联网认证与访问控制目前常用的身份识别技术可以分为两大类 一类是基于密码技术的各种电子ID身份鉴别技术； 另一类是基于生物特征识别的识别技术 基于零知识证明的识别技术 零知识洞穴 第4章 RFID系统安全与隐私RFID系统一般由3大部分构成： 标签 标签放置在要识别的物体上，携带目标识别数据，是RFID系统真正的数据载体，由耦合元件以及微电子芯片(包含调制器、编码发生器、时钟及存储器)组成 读写器 用于读或读/写标签数据的装置，由射频模块(发送器和接收器)、控制单元、与标签连接的藕合单元组成 后台数据库 后台服务器包含数据库处理系统，存储和管理标签相关信息，如标签标识、阅读器定位、读取时间等 工作原理 RFID系统的基本工作原理是：阅读器与标签之间通过无线信号建立双方通信的通道，阅读器通过天线发出电磁信号，电磁信号携带了阅读器向标签的查询指令。 当标签处于阅读器工作范围时，标签将从电磁信号中获得指令数据和能量，并根据指令将标签标识和数据以电磁信号的形式发送给阅读器，或根据阅读器的指令改写存储在RFID标签中的数据 阅读器可接收RFID标签发送的数据或向标签发送数据，并能通过标准接口与后台服务器通信网络进行对接，实现数据的通信传输。 根据标签能量获取方式，RFID系统工作方式可分为：近距离的电感耦合方式和远距离的电磁耦合方式 RFID的安全和攻击模式 安全 信息及隐私泄露 RFID的隐私威胁 隐私信息泄露 跟踪 效率和隐私保护的矛盾 攻击模式 窃听 中间人攻击 欺骗、重放、克隆 欺骗(spoofing)：基于已掌握的标签数据通过阅读器 重放(replaying)：将标签的回复记录并回放 克隆(cloning)：形成原来标签的一个副本 拒绝服务攻击(Denial-of-service attack, DoS)拒绝服务攻击是通过不完整的交互请求消耗系统资源，使系统不能正常工作 物理破解(corrupt)物理破解采用如下一些步骤对RFID射频系统进行破坏 篡改信息(modification)进行非授权的修改或擦除标签数据，从而达到篡改信息的目的。 RFID病毒(virus, malware)包括EPC标签在内的RFID标签可以被用来携带病毒，并能攻击电脑系统。 其他隐患：RFID的安全和隐私问题涉及到的其他隐患还包括：电子破坏、屏蔽干扰和拆除等。 RFID系统根据分层模型可划分为3层：应用层、通信层和物理层，ISO／IEC 18000标准定义了读写器与标签之间的双向通信协议，其基本的通信模型如下图。 安全RFID系统的基本特征 机密性 完整性 可用性 真实性 隐私性 第5章 WSN无线传感器网络安全无线传感器网络与安全相关的特点 资源受限，通信环境恶劣。 部署区域的安全无法保证，节点易失效。 网络无基础框架。 部署前地理位置具有不确定性。","tags":[{"name":"物联网安全","slug":"物联网安全","permalink":"https://kpl0111.github.io/blog/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"},{"name":"复习","slug":"复习","permalink":"https://kpl0111.github.io/blog/tags/%E5%A4%8D%E4%B9%A0/"}]},{"title":"编译系统原理复习提纲","date":"2022-01-01T07:31:41.000Z","path":"2022/0178868943.html","text":"编译系统原理[toc] 内容过多，未完全整理 题型设计 单项选择（12*2） 编译阶段所做事情考察 编译器和解释器的区分 ϵ是空符号串 正则表达式本质上表述的是符号串集合 NFA，DFA和CFG 设计题（6*4） 正则表达式表示的含义 设计正则表达式 设计上下文无关文法 解答题 Thompson构造法 子集构造法 终结符，非终结符，开始符号 消除左递归 构造预测分析表 流图 三地址码 优化 真题C++编译器检查数组下标越界是在_____阶段?ϵ为空符号串 概述广义的编译器：浏览器 分析-综合模型两个基本部分 分析：将源程序分解为基本组成部分，生成中间表示形式 中间表示形式：树 节点-操作 孩子-参数 综合：从中间表示形式构建目标程序 源程序分析的三个阶段 线性分析/词法分析/扫描 由左至右扫描源程序字符序列➔token，单词（记号）——具有组合意义的字符序列 忽略空格、回车等，将字符组合为单词 层次分析/语法分析 单词序列➔有意义的集合，语法单位 将词法分析产生的单词组合为语法短语 语法分析树：内部节点-运算符，叶节点-运算对象 语义分析 检查程序各部分是否正确符合语义 语法结构的递归定义 表达式 标识符是表达式 数是表达式 若expression1和expression2是表达式，则expression1 + expression2 、expression1 * expression2、( expression1 )也是表达式 1、2——基本规则，3——递归定义 文法（grammar） 语句（statement）定义 若identifier1是一个标识符，expression2是一个表达式，则identifier1 := expression2是一个语句 若expression1是一个表达式，statement2是一个语句，则while ( expression1 ) do statement2和if ( expression1 ) then statement2也是语句 文法：处理token相互关系和结构的一组规则 程序优化技术现状 CPU上的过程内优化基本成熟 过程间优化能力仍然受限 面向GPU等新型体系结构的编译优化还有空间 一个简单的编译器字符流 → 词法分析器 → 单词流 → 语法制导翻译器 → 中间表示形式 语法制导翻译器：语法分析 + 中间代码生成 语法定义上下文无关文法：描述语言的语法结构 组成： 一组终结符号，单词，基本符号 一组非终结符号（语法变量），语法范畴，语法概念 一组产生式，定义语法范畴 产生式：A→α A—一个非终结符，左部 α—终结符或/与非终结符串，右部 一个特定的非终结符——开始符号，start symbol 几个概念 Σ：有穷字母表，元素——符号 符号串：Σ中符号构成的有穷序列 空字：不含任何符号的序列，ε Σ*：符号串全体，包括空字 φ：空集{}，区分ε，{}，{ε} Σ*的子集U、V的积（连接）{ αβ|α ∈ U 且 β ∈ V} UV≠VU，(UV)W=U(VW) V自身的n次积（连接）记为$V^{n}$ $V^{0}={ε}$ V的闭包（closure） $V* = V^{0} ⋃ V^{1} ⋃ V^{2} ⋃ V^{3} ⋃ …$ 每个符号串，都是V中符号串有限次连接 正则闭包，$V^{+}=VV*$ 四元式定义上下文无关文法 $(V_{T}, V_{N}, S, P)$ $V_{T}$：非空有限集，终结符号集合 $V_{N}$：非空有限集，非终结符号集合 S：开始符号 P：产生式集合（有限集） 每个产生式形式A→α，其中 $A ∈ V_{N},α ∈(V_{T} ⋃ V_{N})*$ 关于A的产生式S至少在某个产生式左部出现一次 符号约定 expr → expr + digit expr → expr – digit expr → digit digit → 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 数字、运算符、黑体字符串——终结符 斜体字符串——非终结符 左部相同可合并，‘|’——“或”的意思expr → expr + digit | expr - digit | digit候选式 推导 单词串(string)：0个或多个单词构成的序列 推导(derive) 由开始符号作为推导起点 用产生式右部替换左部非终结符 反复替换，最终得到单词串 语言(language) 语法所定义的语言——可由开始符号推导出的所有单词串的集合 二义性：多个语法分析树生成相同的单词串——多个意义 语法制导翻译 翻译：为生成代码，需保存语言结构的类型、代码位置、代码数量等 属性(attribute)：类型、串、内存位置等 语法制导翻译syntax-directed translation 语法制导定义syntax-directed definition 属性与语法结构相关联➔指明翻译方法 翻译模式，translation scheme 表达式E的后缀形式Postfix(E)如何生成： E为变量或常量：Postfix(E) = E $E = E_{1} op E_{2}$，op—二元运算符，$E_{1}、E_{2}$—子表达式： $Postfix(E) = Postfix(E_{1} op E_{2})= Postfix(E_{1}) Postfix(E_{2}) op$ $E = (E_{1})$： $Postfix(E) = Postfix(E_{1})$ (9 - 5) + 2 ➔9 5 - 2 + 9 - (5 + 2) ➔9 5 2 + - 语法制导定义 基于语言的上下文无关文法 语法符号——一组属性 产生式——一组语义规则(semantic rule)——属性值计算规则 CFG+语义规则➔语法制导定义 语法制导翻译的基本过程（翻译——输入→输出映射过程） 输入单词串x➔语法分析树 节点n标记为X，X.a——X的属性 计算节点n的X.a的值——利用X产生式的语义规则➔ “注释语法分析树”（annotated parse tree） 语法制导定义的实现 树的遍历：计算完所有孩子节点的属性，父节点才能计算自身属性 后序遍历，深度优先 翻译模式 translation scheme 同样基于上下文无关文法 语义动作（semantic action，程序片断）嵌入产生式的右部 语法分析树添加额外节点 指明了语义动作执行顺序 语法分析 确定一个单词串是否可由一个文法生成 构造语法分析树 时间复杂度$O(n^3)➔O(n)$ 自顶向下分析方法，top-down语法树构造——由根向叶适合手工编写语法分析器 自底向上分析方法，bottom-up语法树构造——由叶向根适用更多文法，自动生成工具 自顶向下分析方法 从根节点（标记为开始符号）开始构造语法树，不断重复以下步骤 对标记为NT A的节点n,选择一个关于A的产生式,利用产生式右部构造n的孩子节点 选择下一个没有扩展（构造孩子节点）的节点，对它执行1 平凡算法 初始状态，只有一个根节点，标记为开始符号，输入指针指向第一个单词 对于NT节点 a) 选择产生式（尝试、回溯）构造孩子节点 b) 对孩子节点从左至右继续分析 对于T节点 a) 与当前输入单词进行比较 b) 若匹配，输入指针前移，处理下一个节点 c) 不匹配，可能需要回溯或报告错误","tags":[{"name":"Lex","slug":"Lex","permalink":"https://kpl0111.github.io/blog/tags/Lex/"},{"name":"Yacc","slug":"Yacc","permalink":"https://kpl0111.github.io/blog/tags/Yacc/"},{"name":"编译系统原理","slug":"编译系统原理","permalink":"https://kpl0111.github.io/blog/tags/%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"编译器","slug":"编译器","permalink":"https://kpl0111.github.io/blog/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"计算机网络复习摘要","date":"2021-12-30T20:53:41.000Z","path":"2021/1210d148d4.html","text":"概述IPV4：32位地址IPv6：128位地址 Internet三个重要理念：➢ 互联网的开放理念➢ 互联网的自组织理念➢ 互联网的分享理念 统计多路复用：主机A和B的报文分组没有固定的到达模式，带宽按需共享，这种方式称为统计多路复用(statistical multiplexing) 网络流量具有很强的突发性，即不平稳，每个独立的流的峰值可能出现在不同时间 结论：流越多，网络平均流量越平滑 报文长度P ：单位“位(bit)”链路长度L ：单位“米”传输速率R ：单位“位/秒”传播时延PROP：电磁波在介质上传播的时间，单位“秒” PROP = L/C，其中C为电磁波传播速度 传输时间TRANSP ：发送长度为P的报文所用的时间 TRANSP = P/R，其中R为传输速率 端端时延Latency：发送端开始传送第一位到接收端接收到最后一位所用的时间，在单一链路上计算方法为： Latency = PROP + TRANSP 当报文分组到达时，如果出口链路忙，报文分组需要在路由器缓存中排队等待，会引入排队时延 往返时延RTT (Round-Trip Time)：从发送方发送数据开始，到发送方收到来自接收方的确认，经历的总时间 时延带宽积 时延带宽积= 传播时延×带宽，即按比特计数的链路长度 若发送端连续发送数据，则在发送的第一个bit即将达到终点时，发送端就已经发送了时延带宽积个bit ，而这些bit都在链路上向前移动 如何将端系统连接到边缘路由器？ 有线接入 数字用户线路(xDSL),电话线 混合光纤同轴电缆(HFC)，电视 光纤宽带(FTTH)，光纤 以太网(Ethernet) 无线接入 无线局域网(WiFi) 移动通信网(4G/5G) 注意两个指标：接入网速率、共享或专用 网络协议的组成要素： 语法：数据与控制信息的结构或格式(协议数据单元PDU) 语义：需要发出何种控制信息，完成何种动作以及做出何种响应 时序：事件实现顺序的详细说明 接口层通常包括数据链路层和物理层 应用层协议及网络编程应用协议与进程通信模型应用：可进行通信的、分布式进程➢ 运行于主机的用户空间➢ 通过交换消息(Messages)实现应用之间的交互➢ 例如：Email、Web等 应用层协议：应用层实体之间的通信规范➢ 定义应用交换的消息和收到消息后采取的行动➢ 使用下层协议(TCP、UDP)提供的通信服务 内容： 消息的类型 如请求request、响应response 消息的语法 如消息包含哪些字段、字段之间如何分割等 消息的语义 字段中信息代表的具体含义 消息的处理 进程何时发送消息、收到消息后的动作等 类型： 公共协议 RFC中定义的协议 可相互兼容 例如：HTTP、SMTP等 专有协议 公司或组织专有 例如：Skype、QQ等 服务指标 数据丢失率 音视频等应用可以容忍一定的数据丢失 文件传输、远程登录等应用要求100%的数据可靠 时延 网络电话、交互游戏等应用对时延有一定的要求 带宽 多媒体等应用需要一定的带宽保证 有些应用则是弹性的 主机的地址标识:主机拥有一个唯一的32位的IPv4地址(或128位的IPv6地址)进程标识符：包括IP地址和端口号 端口号举例: Web服务器进程: 80 Email(SMTP)服务器进程: 25 进程间通信进程：主机中运行的程序 在同一台主机中，两个进程之间按照进程间通信方式进行交互通信(操作系统中定义)不同主机上的进程通信，需要通过交换信息来完成 客户/服务器(C/S)模型 客户向服务器发出服务请求，并接收服务器的响应；服务器等待客户的请求并为客户提供服务 例如：Web浏览器/Web服务器；Email客户端/Email服务器 过程 服务器进程 被动等待 长久在线 固定IP地址 利用集群/云提供扩展性 客户进程 启动与服务器的通信 可能为间歇性连接 可能使用动态IP地址 不与其他客户进行直接通信 对等计算(P2P)模型 最小化(或根本不用)专用服务器 例如：Skype, BitTorrent等 过程 无长久在线的服务器 任意的终端系统之间都可能进行直接通信 端系统之间可能间歇性地进行连接 端系统可能使用动态的IP地址 高可扩展性但维护困难 传输层服务对应用层的支持TCP服务: 面向连接：客户与服务器之间需要建立连接 可靠传输：可保证传递数据无差错 流量控制：发送数据不会超过接收端的容纳容量 拥塞控制: 提供拥塞解决方案 不能提供：时延和带宽保证 UDP服务: 不可靠：不可靠的数据投递 不能提供：连接建立、可靠性、流量控制、拥塞控制、时延和带宽保证 一些常见Socket函数： accept():流方式 connect()：流方式 recv()：流方式 sendto()：数据报方式 recvfrom()：数据报方式 常见CPU的字节序 Big-Endian : PowerPC、IBM、Sun Little-Endian : x86、DEC ARM既可工作在Big-Endian，也可工作在Little-endian 网络使用的字节序：网络通信协议都使用Big-Endian编码序 电子邮件系统 用户代理 (接口) 编辑和发送邮件 接收、读取和管理邮件 管理地址簿 无统一标准 邮件服务器 邮箱：保存用户收到的消息 消息输出队列：消息的发送队列 SMTP协议：邮件服务器之间传递邮件使用的协议 smtp客户: 发送邮件端 smtp服务器: 接收邮件端 邮件地址：一对字符串，用于指定邮件接收者 local-part@domain-name domain-name: 域名 local-part: 域名中的邮箱名 SMTP: 向服务器传递邮件 邮件访问协议: 从邮件服务器的邮箱中获取邮件 POP: 邮局协议[RFC 1939] IMAP: Internet邮件访问协议[RFC 2060] HTTP: 超文本传输协议 邮件消息格式 信封 封装消息 内含传输邮件消息所需的一些信息 目的地址、优先级、安全级别等 消息 消息头 包含用户代理所需的一些控制信息 消息体 文件传输服务与协议 基于TCP/IP的文件传输系统 客户/服务器模型 client: 初始化传输(无论上传还是下载) server: 远端 客户使用TCP协议连接远端服务器 FTP进程模型– 双连接 控制连接 带外控制 TCP的21端口 客户和服务器之间维护的一个FTP会话 用于客户和服务器之间交换命令和响应 在整个会话期间保持活跃 数据传输连接 TCP的20端口 用于传输数据 客户可以在一个会话上向服务器传输多个请求 每个文件请求都会建立一个数据连接 数据传输结束后，释放数据连接 域名系统DNS(Domain Name System)互联网中使用IP地址寻址主机 DNS基本思想： 名字和地址映射关系分布式存放，形成具有层次结构的分布式数据库系统(分布式管理) 通过查询分布式数据库，获得名字到地址的映射，或相反 关键： 如何组织分布式数据库 如何在分布式数据库中查找 DNS服务器组织 顶级域名服务器(Top-Level Domain, TLD) 根服务器 负责顶级域名的解析 授权域名服务器 对于名字与地址映射，保留其初始数据来源的服务器 主要区分名字与地址映射是原始的还是被缓存的(非授权) 本地域名服务器(或称默认域名服务器) 一般每个ISP都部署有域名服务器，其用户可将该服务器设置成本地域名服务器(或默认域名服务器) 当进行域名解析时，查询请求首先发送到本地域名服务器(即查询的起点) 域名解析：名字到地址映射(通过名字查地址) 分布式：层级的服务器组织，协同实现解析 有效性：大多数解析可以在本地完成，一部分会产生互联网流量 可靠性：通过冗余设置，避免单点失效 解析方式 反复解析 递归解析 主机缓存 基本方法 在启动时从本地域名服务器下载名字-地址映射数据库 定期获取新的映射 缓存最近用过的名字和地址映射 优点 无需访问域名服务器，名字解析速度快 本地服务器的故障不影响名字解析 减低服务器的负载 缺点？ DNS包括query和reply两种报文 域名格式压缩？ 客户-服务器模式 域名服务器： 保存名字到地址映射关系(数据库) 接收客户端请求，并给出响应 域名解析器(客户端)： 请求域名解析的客户进程 向域名服务器发起解析请求，并等待服务器的响应 Web服务与HTTP协议 服务器 Web页面(HTML文档)：包含到多种对象的链接 对象：可以是 HTML文档、图像文件、视频文件、声音文件、脚本文件等 对象用URL(统一资源定位符)编址：协议类型://主机名//路径和文件名 客户端 发出请求、接收响应、解释HTML文档并显示 有些对象需要浏览器安装插件 HTTP(HyperText Transfer Protocol) 传输层通常使用TCP协议，缺省使用TCP的80端口 HTTP为无状态协议，服务器端不保留之前请求的状态信息 无状态协议：效率低、但简单 有状态协议：维护状态相对复杂，需要维护历史信息，在客户端或服务器出现故障时，需要保持状态的一致性等 HTTP标准 HTTP/1.0: RFC 1945(1996年) 每请求一个文件都要建立连接和断开 eg:请求一个index.html，里面包含3张jpg图片，先发送html文件，后重新建立三次连接发送图片 HTTP/1.1: RFC 2616(1999年) HTTP 1.1的问题 队头阻塞问题 基于文本协议的问答有序模式，先请求的必须先响应 传输效率问题 文本格式、冗长重复的头部等 HTTP 1.1队头阻塞的解决策略 浏览器建立多个TCP连接 一般最多可以建立6个TCP连接 通过不同TCP连接传送的请求没有响应顺序的要求 耗费较多的计算和存储资源 HTTP/2: RFC 7540(2015年)、RFC 8740(2020年) 二进制分帧传输 不改变HTTP原有的语义 将HTTP请求和响应分割成帧，采用二进制编码 帧为最小传输单位 最常用的HTTP 请求/ 响应的帧形式 TCP连接复用：提高连接利用率，解决HTTP的队头阻塞问题 消息(Message)：HTTP一次请求或响应，包含一个或多个帧 流(Stream)：简单看成一次请求和应答，包含多个帧 每个TCP连接中可以承载多个流，不同流的帧可以交替穿插传输 流的创建与标识 Stream ID：标识一个流。客户端创建的流，ID为奇数；服务器创建的流，ID为偶数；0x00和0x01用于特定场景；Stream ID 不能重复使用，如果一条连接上ID分配完，会新建一条连接。接收端通过Stream ID进行消息的组装。 流创建：发送和接收到HEADERS帧(包含新Stream ID)时创建 流优先级：可以依据重要性为流设置不同的优先级(1~256)，在HEADERS帧中承载 服务器推送：提高响应速度 服务器在请求之前先推送响应信息到客户端，推送的响应信息可以在客户端被缓存 HTTP头压缩(HPACK) 请求头由大量的键值组成，多个请求的键值重复程度很高 静态表：定义通用HTTP头域，常用键值无需重复传送，直接引用内部字典的整数索引 动态表：两边交互发现新的头域，添加到动态表 自定义键值：采用Huffman编码 http测试 HTTP 2.0协议解决的问题 通过引入流机制，解决了HTTP队头阻塞问题，提高了传输效率 通过二进制编码、头压缩机制提高了网络带宽利用率 通过服务器推送，加快了页面响应速度 HTTP 2.0协议没有解决的问题 TCP+TLS的多次交互，造成启动延迟问题 对移动主机和多宿主机的连接迁移问题 TCP队头阻塞问题 HTTP报文类型 HTTP两种报文：请求(request)、响应(response) HTTP请求报文：采用ASCII，数据部分采用MIME格式 HTTP响应报文：数据部分采用MIME格式 几个比较典型的状态码 200 OK 请求成功，被请求的对象包含在该响应的数据部分 301 Moved Permanently 请求的对象被移走，新的位置在响应中通过Location: 给出 400 Bad Request 服务器不能解释请求报文 404 Not Found 服务器中找不到请求的文档 505 HTTP Version Not Supported 服务器不支持相应的HTTP版本 用户-服务器交互：认证 认证：控制对服务器内容的访问 认证方法：通常使用“名字-口令” 无状态：客户端需要在每个请求中携带认证信息 每个请求头中包含authorization: 如果请求头中无authorization:，则服务器拒绝访问，并在响应头中包含WWW authenticate： 用户-服务器状态：Cookies 服务器使用cookies保持状态 HTTP响应头中使用set-cookie： 选择的cookie号具有唯一性 后继的HTTP请求中使用cookie： Cookie文件保存在用户的主机中，由用户主机中的浏览器管理 Web服务器建立后端数据库，记录用户信息 例如： Set-Cookie: SID=31d4d96e407aad42; Path=/; Domain=example.com Cookie: SID=31d4d96e407aad42 Web缓存机制：客户端缓存 目标：如果被请求的对象在客户端缓存有最近版本，则不需要发送该对象 客户端：在发送的HTTP请求中指定缓存的时间，请求头包含 If-modified-since: &lt; date &gt; 服务器：如果缓存的对象是最新的，在响应时无需包含该对象，响应头包含 HTTP/1.1 304 Not Modified Web缓存机制：代理服务器缓存 目标：由代理服务器进行缓存，尽量减少原始服务器参与 用户设置浏览器：通过代理服务器进行Web访问 浏览器将所有的HTTP请求发送到代理服务器 如果缓存中有被请求的对象，则直接返回对象 否则，代理服务器向原始服务器请求对象，再将对象返回给客户端 优点：降低时延，减少网络流量 HTTP发展现状 内容分发网络CDN(Content Distribution Network)基本思想源于MIT对Web服务瞬间拥塞问题的解决(1998) 一种Web缓存系统，靠近网络边缘(用户)提供内容服务 目前提供更丰富的服务，包括静态内容、流媒体、用户上传视频等 主要优点 降低响应时延，避免网络拥塞 避免原始服务器过载及防止DDoS攻击 分布式架构，具有良好的可扩展性 对用户透明，无需用户感知 DNS辅助 负载均衡DNS负责决策CDN服务器选择 负载均衡DNS需要收集CDN服务器的位置和负载情况 如果找不到被请求的对象，需要从原始服务器获取 动态自适应流媒体协议DASHDynamic Adaptive Streaming over HTTP)(重点)基本思想： 完整视频被拆分为固定时长(2s-10s)、不同码率的视频片段(segment) 视频片段与媒体表示描述(Media Presentation Description, MPD) 文件一同存放于DASH服务器 客户端根据自身设备性能、当前网络条件、客户端缓冲大小等自适应选择一种视频码率进行下载 例如：HTTP服务器中保存有高中低三种质量的视频片段，DASH客户端评估网络状况，通常在保证视频流畅的前提下，获取最高质量的视频片段 自适应码率(Adaptive bitrate，ABR)规则 传输层协议传输层需要解决的基本问题 网络层：将IP数据包从源主机传送到目的主机，提供无连接不可靠服务 数据包传输存在的问题：延迟、乱序、出错、丢失等 传输层解决的问题之一：可靠性，向应用层提供可靠服务 应用层运行多个应用进程 共享单一的网络层协议(IP)和网络接口 传输层解决的问题之二：复用(Multiplexing)和分用(Demultiplexing) TCP/IP体系结构中传输层协议与服务传输层协议的基本功能 复用和分用 可靠性保证 传输层实体执行的动作 发送端：将应用层的消息封装成传输层的数据单元，传递到网络层 接收端：将从网络层接收的传输层数据单元，处理后交给应用层 传输控制协议TCP(Transport Control Protocol) 为进程间通信提供面向连接的、可靠的传输服务 实现复用分用、差错检测、确认重传、流量控制等传输层功能 用户数据报协议UDP(User Datagram Protocol) 为进程间通信提供非连接的、不可靠的传输服务 实现复用分用、差错检测等传输层功能 用户数据报协议(UDP)UDP协议特点 发送方和接收方不需要握手过程 每个UDP数据单元(数据报)独立传输 提供复用分用功能和可选的差错检测功能 支持组播通信(点到多点通信) 不提供可靠性保证：无确认重传、可能有出错、丢失、乱序等现象 UDP数据报格式 长度：包含头部、以字节计数 校验和：为可选项，用于差错检测 进程标识：目的IP地址+目的端口号 UDP数据报的差错检测 可选项，利用数据报中携带冗余位(校验和域段)来检测数据报传输过程中出现的差错 发送端：利用自己产生的伪首部和发送的UDP数据报计算校验和 接收端：利用自己产生的伪首部和接收的UDP数据报计算校验和 伪首部：包含源IP地址、目的IP地址、协议类型等域段 UDP校验和计算几点说明 IPv4中UDP校验和是可选项，IPv6中变成强制项 0无，非0有(如果计算结果为0，则以全1代替) UDP校验和覆盖的范围超出了UDP数据报本身，使用伪首部的目的是检验UDP数据报是否到达真正的目的地 正确的目的地包括了特定的主机和该主机上特定的端口 伪首部不随用户数据报一起传输，接收方需自己形成伪首部进行校验 伪首部的使用破坏了层次划分的基本前提，即每一层的功能独立 目的主机的IP地址UDP通常知道，源IP的使用需要通过路由选择决定 u_short cksum(u_short *buf, int count){ register u_long sum = 0; while (count--){ sum += *buf++; if (sum &amp; 0XFFFF0000){ sum &amp;= 0XFFFF; sum++; } } Return ~(sum &amp; 0XFFFF); } IP首部、ICMP、UDP、TCP都需要计算校验和，方法类似 使用UDP服务的应用： 流媒体应用(实时音频和视频)通常使用UDP服务 能够容忍一定的丢失 对时延敏感 其他使用UDP服务的应用，如： DNS SNMP 需要在UDP之上实现可靠传输，即在应用层增加可靠机制 为什么提供UDP服务？ 不需要建立连接，建立连接需要增加延时，特别对于简单的交互应用 协议简单：在发送端和接收端不需要维护连接状态 数据报头部短，额外开销小 无拥塞控制 可靠数据传输rdt：reliable data transfer protocol(可靠数据传输协议) 停等机制：发送端发送一个分组，然后等待接收端响应 两种典型的流水线协议： 回退N：Go-Back-N (GBN) 允许发送端发出N个未得到确认的分组 需要增加序列号范围 分组首部中增加k位的序列号，序列号空间为[0, $2^{k-1}$] 采用累积确认，只确认连续正确接收分组的最大序列号 可能接收到重复的ACK 发送端设置定时器，定时器超时时，重传所有未确认的分组 选择重传：Selective Repeat (SR) 接收端独立确认每个正确接收的分组，必要时缓存分组，对高层按序交付 每个分组独立定时，发送端只重传未收到ACK的分组 过程 发送端 接收上层数据：如果发送窗口中有可用的序号，则发送分组 超时(n)：重传分组n，重启定时器 接收ACK(n)：n在[send_base, send_base+N-1]区间，将分组n标记为已接收，如果是窗口中最小的未确认的分组，则窗口向前滑动，基序号为下一个未确认分组的序号 接收端：接收分组n： n在[rcv_base, rcv_base+N-1]区间，发送ACK(n)，缓存失序分组，按序到达的分组交付给上层，窗口向前滑动 n在[rcv_base-N, rcv_base-1]区间，发送ACK(n) 传输控制协议(TCP)TCP协议特点提供可靠服务：按序、可靠交付 提供字节流服务，不识别消息边界可靠传输机制 提供差错检测(校验和)功能，正确接收返回确认 使用序列号检测丢失和乱序 超时重传机制，解决出错、丢失问题 支持流水线机制，自适应窗口 面向连接：发送数据之前发送方和接收方之间需要握手 三次握手建立连接 初始化所需的参数及分配缓冲区 提供复用分用功能 只提供点对点通信 具有流量控制和拥塞控制功能 头长度：四个字节为计数单位，包含选项部分 接收窗口通告：指示接收缓冲区可接收的字节数 标志位：URG, ACK, PUSH, RESET, SYN, FIN 选项格式：Kind(1字节)|Length(1字节)|Info(n字节) TCP连接与复用、分用机制 通信之前通过三次握手建立TCP连接 分配缓冲区、协商参数(初始序号、接收缓冲区大小、最大段尺寸等) 连接标识(四元组)：源IP地址、目的IP地址、源端口号、目的端口号 通过建立的TCP连接为应用进程提供可靠的字节流服务 事件 TCP接收端动作 期望序号的报文段按序到达，之前的报文段均已被确认 延迟发送ACK，等待下一个报文段到达；等500毫秒，仍未收到下一个报文段，则发送ACK 期望序号的报文段按序到达，之前有一个延迟确认的报文段 发送ACK，确认两个按序到达的报文段 报文段未按序到达，到达的报文段序号高于期望的序号，数据流不连续 发送重复ACK，确认序号中包含期望接收的序号 到达的报文段填补了之前数据流不连续部分 发送ACK，确认序号中包含期望接收的序号 TCP采用自适应方法计算重传超时时间(原因？) 基于往返时间(RTT)确定重传超时间(RTO) 问题：如何准确估算 上一次RTT可以测得，下一次RTT需要估算 网络拥塞和路由变化，每次往返时间可能不同，有时会有较大变化 流量控制的目的：避免发送端发送数据过快，接收端不能及时处理，造成接收缓冲区溢出 增加流控功能后，发送窗口还需要受接收能力的约束 可变的滑动窗口：接收端利用“接收窗口通告”域段告知发送端接收端缓冲区剩余的空间，发送端依据该通告调整发送窗口的大小 接收窗口大小对性能的影响 较小的缓冲区会影响网络的吞吐率 过大的缓冲区会浪费主机的存储资源 连接的半打开状态：连接的一端存在、而另一端不存在 当一个进程终止连接未能通知到另一方时，例如：掉电、异常关闭等 TCP定时器: 连接建立定时器(75秒) 重传定时器(RTO) 延迟ACK定时器(500毫秒) 持续定时器(避免0窗口死锁) 保活定时器(避免半打开) 静默定时器(避免端口号重用等) 理解网络拥塞拥塞控制方法：两种广泛使用的拥塞控制方法 端到端拥塞控制 网络中无明确的反馈 端系统通过观察丢失、延迟推断是否发生拥塞 TCP采用的拥塞控制策略 网络辅助的拥塞控制 路由器提供到端系统的反馈 例如：可以使用1位指示拥塞(如X.25, ATM) TCP拥塞控制机制带宽探测：接收到ACK提高传输速率，发生丢失事件降低传输速率 ACK返回：说明网络并未拥塞，可以继续提高发送速率 丢失事件：假设所有丢失是由于拥塞造成的，降低发送速率 TCP拥塞控制控制窗口：采用基于窗口的方法，通过拥塞窗口的增大或减小控制发送速率 实际发送窗口取决于接收通告窗口和拥塞控制窗口中较小值 TCP拥塞控制 慢启动阶段 初始拥塞窗口：cwnd=1(MSS) 每个RTT，cwnd翻倍(指数增长) 每接收到一个ACK，cwnd增1(MSS) 当连接初始建立或报文段超时未得到确认时，TCP拥塞控制进入慢启动阶段 特点：初始值小，增长速度快 拥塞避免阶段 阈值ssthresh：拥塞窗口达到该阈值时，慢启动阶段结束，进入拥塞避免阶段 每个RTT，cwnd增1(线性增长) 注意：TCP使用字节计数，当收到ACK时，拥塞窗口计算如下： $cwnd = cwnd + MSS \\times \\frac{MSS}{cwnd}$ 丢失检测 通过超时检测丢失： 阈值ssthresh = cwnd/2 cwnd=1，进入慢启动阶段 通过三次重复ACK检测丢失(TCP RENO算法)： 阈值ssthresh = cwnd/2 cwnd= ssthresh+3，进入线性增长(拥塞避免阶段) 注：重复ACK指明网络仍可以交付一些报文段(拥塞不严重) TCP Tahoe算法对于两种丢失情况均将cwnd设成1，并进入慢启动阶段 网络层协议网络层功能网络层功能部署 网络层在每台主机和路由器中实现 发送端：将传输层数据单元封装在数据包中 接收端：解析接收的数据包中，取出传输层数据单元，交付给传输层 路由器：检查数据包首部，转发数据包 网络层关键功能 路由(控制面): 决定数据包从源主机到目的主机的路径核心：路由算法与路由协议 转发(数据面): 将数据包从路由器的输入接口送到输出接口的过程 IP协议- IP服务IP层服务 面向无连接的数据报服务 不需要提前建立连接 数据包基于目的主机地址进行转发 数据包独立转发，相同源-目的的数据包可能经过不同的路径 尽力而为(Best-effort)的不可靠服务 数据包可能会产生较长的时延 数据包可能会丢失、失序、重复 IPv4IPv4地址 IP地址：32位二进制逻辑地址(四部分，0~255)，实现互联网络统一编址，标识主机和路由器的接口 接口：将主机和路由器连接到物理网络 路由器一般有多个接口 主机可以有一个或多个接口 IP与物理接口绑定 IP地址表示：点分割的十进制，如：223.1.1.1 IP地址层次： 网络号部分(net-id) 主机号部分(host-id) 什么是一个IP网络： 位于同一个物理网络 设备接口的IP地址的网络号部分相同，主机号部分不同 IPv4地址：如何获取 公有IP地址要求全球唯一，由区域互联网注册机构(RIR，Regional Internet Registry)或ISP分配 静态设定： 申请固定IP地址，手工设定 动态获取： 使用DHCP协议或其他动态配置协议 当主机加入IP网络，允许主机从DHCP服务器动态获取IP地址 可以有效利用IP地址，方便移动主机的地址获取 路由器转发IP数据包过程：总结 路由器确定IP数据包中目的地址的网络号 如果目的主机与路由器属于相同的IP网络，则直接转发到目的主机 如果目的主机与路由器不属于相同的IP网络，则查找路由表，确定下一跳路由器地址 如果存在相应的路由信息，则转发 如果没有相应的路由信息，则丢弃 减小TTL值，修改首部的校验和 将数据包转发到相应的接口 无类地址划分CIDR: Classless Inter-Domain Routing IP地址分为前缀和后缀两部分 一个前缀不一定标识一个物理网络 前缀可以是任意长度，前缀和后缀长度用32位掩码标识 也可以表示成：a.b.c.d /x，x为前缀长度 私有IP地址和NAT 私有IP地址的使用 可以在私有网络(本地网络)中自由使用，但不能出现在公网上 如果数据包要进入公网，需要进行私有地址到公有地址的转换 承担地址转换的设备称为NAT(Network Address Translation) 本地网络使用私有IP地址，NAT 面向公网侧使用公网IP地址 只需要一个或少量的公网IP地址 公网IP地址变化，不影响本地网络地址配置 安全性增强 NAT 的基本实现方法离开本地网络的数据包：用(NAT 的IP地址+新端口号)代替(源IP地址+端口号)，远端的主机返回的数据包将使用(NAT 的IP地址+新端口号)作为目的IP地址和目的端口 NAT 在转换表中记录(NAT 的IP地址+新端口号)到(源IP地址+端口号)的映射 进入本地网络的数据包：用转换表中的(源IP地址+端口号)替换数据包中的目的IP地址和端口号(NAT 的IP地址+新端口号) IPv6IPv6互联网的优势 解决地址耗尽问题：更大的地址空间(32位→128位) 340,282,366,920,938,463,463,374,607,431,768,211,456个IP地址 地球上每平方米范围：6.67×1023个IP地址 自动配置的支持(即插即用) 无状态地址自动配置 有状态地址自动配置：对DHCP协议改进和扩展，网络管理更加方便和快捷 改善网络性能 IP包头的合理改善，提高了路由器对数据包的处理速率 路由聚合，使路由表更小，提高转发效率 方便各项业务开展 无需使用NAT 设备 IPv6数据包由一个IPv6基本头、多个扩展头和上层数据单元组成 IPv6基本头：40字节固定长度，包含了发送和转发该数据包必须处理的一些字段 IPv6数据包可以包含0个或多个扩展头，扩展头位于基本头之后 基本头和扩展头中“下一包头”字段指出下一个扩展头的类型。最后一个扩展头中的“下一包头”字段指出高层协议的类型 128位地址：由冒号分开的8组十六进制字段组成 完全形式：1080:0000:0000:0000:0008:0800:200C:417A 圧缩形式：1080:0:0:0:8:800:200C:417A / 1080::8:800:200C:417A 地址段中有时会出现连续的几组0，这时这些0可以用“::”代替，但一个地址中只能出现一次“::“，例如：FF01:0:0:0:0:0:0:101=FF01::101，0:0:0:0:0:0:0:1=::1 内嵌IPv4地址的IPv6地址：0:0:0:0:0:0:61.1.133.1 或::61.1.133.1 URL的IPv6地址表示：https://[2001:410:0:1:250:fcee:e450:33ab]:8443/abc.html ICMP协议ICMP: 互联网控制消息协议 路由算法目标：确定从源主机到目的主机的最优路径 最优路径：一般为代价最小的路径 代价：有不同的定义方法，例如：距离、时延、费用、拥塞等 路由算法的分布式实现 路由器之间交互路由信息或链路状态信息 每台路由器独立计算最优路径 相对于数据包转发，所有路由协议的开销都属于额外管理开销 网络结构的图抽象 路由器：图中的点 物理链路：图中的边 代价：图中边的权值 用G = (N, E) 表示图 N = { u, v, w, x, y, z }，路由器集合 E = { (u, v), (u, x), (v, x), (v, w), (x, w),(x,y), (w,y), (w,z), (y,z) } ，链路的集合 链路代价：相邻节点之间的代价值，表示为$c(x_i,x_j)$ 如果xi和xj不相邻，链路代价记为无穷 例如, c(w, z) = 5 路径代价：路径上所有链路代价和 例如，路径$(x_1, x_2,x_3,…, x_p)的代价= c(x_1,x_2) + c(x_2,x_3) + … + c(x_{p-1},x_p)$ Dijkstra算法详解 Bellman-Ford公式假设：$D_x$(y) = 从x到y最小代价路径的代价值则：$D_x$(y) = min { c(x,m) + Dm(y) } m为x的邻居 距离向量路由算法 算法符号定义 $D_x$(y) = 从x到y最小代价路径的代价值节点x可以获知到每个邻居的链路代价c(x, m) 节点x维护自己的距离向量$D_x = [D_x$(y): y єN ] 节点x维护其邻居的距离向量，对于每个邻居m，x维护$D_m = [D_m$(y): y єN ] 基本思想 当节点的距离向量值发生变化时，向邻居节点发送自己的距离向量 如果节点x接收到邻居节点发送的距离向量，使用Bellman-Ford公式重新计算到所有其他节点的路径代价 $D_x(y) ← min {c(x,m) + D_m(y)}$ 每个节点y ∊N 经过反复迭代，$D_x(y)$会逐渐收敛到实际的最小路径代价值 互联网路由协议扩展性问题 络路由表庞大，存储、查找困难 路由信息交互量大，额外开销高 管理的自治问题 互联网由大量自治域构成 每个自治域独立管理，每个自治域可能运行不同的路由协议 层次化路由 自治域内路由 相同的自治域中的所有路由器运行相同的自治域内路由协议 不同的自治域的路由器可以运行不同的自治域内路由协议 网关路由器(或边界路由器)：与其他自治域的路由器相连接的路由器 自治域间路由 不同自治域网关路由器(或边界路由器)之间运行的路由协议 网关路由器：既执行自治域内的路由协议，也执行路由器之间的路由协议 路由表由自治域内和自治域间路由算法产生 运行协议 自治域内路由：也称为内部网关协议IGP 路由信息协议RIP: Routing Information Protocol 使用距离向量法 两种基本的报文类型 请求报文 响应报文 定期发送通告：相邻路由器每隔30秒发送一次响应报文 IP目的地址：255.255.255.255(本地广播地址) 跳步数定义：直接相连=1 每个通告可以最多携带25个目的网络 触发更新：如果发现链路失效或变化，立即发送响应报文 如果超过180秒没有接收到邻居通告，则认为链路失效 通过邻居的路径失效 向邻居发送通告 如果邻居的路由表项发生变化，则继续通告 链路失效信息会传播到整个网络 使用毒性逆转可以防止暂时环路的产生 设置16跳为无穷值，提高收敛速度 RIP协议在应用层实现 路由器中运行守候进程(routed) 使用UDP的520端口 发送和接收RIP报文，管理路由表 开放最短路径优先协议OSPF: Open Shortest Path First 几个概念 邻居(Neighbor)：两台路由器属于相同的IP网络，并通过交换Hello报文协商成功，则可以成为邻居 邻接关系(Adjacency)：形成邻居关系后，如果两台路由器成功交换DBD(数据库描述)报文以及LSA，则建立邻接关系 链路状态通告(Link State Advertisement，LSA)：每台路由器会在所有形成邻接关系的邻居之间发送LSA，LSA描述了路由器的链路、接口、邻居等信息 链路状态数据库(LSDB)：路由器将收到的LSA记录在LSDB中，并发送LSA拷贝给该路由器的其他所有邻居。当LSA传播到整个区域后，区域内所有的路由器都会形成同样的LSDB OSPF直接运行在IP协议之上，OSPF报文由IP数据包直接承载，协议类型为89 三张表 邻居列表：列出全部已经建立邻接关系的邻居路由器 链路状态数据库：列出网络中其他路由器的信息，由此显示全网的网络拓扑 路由表：列出通过最短路径优先算法计算出到达每个相连网络的最佳路径 OSPF工作过程 邻居发现 通过Hello报文发现并形成邻居关系，建立邻居表 路由通告 邻接路由器之间通过LSU洪泛LSA，通告链路状态信息，最终区域内所有路由器的LSDB完全相同，即实现同步 通过DBD、LSR、LSACK辅助LSA的同步 路由计算 LSDB同步后，每台路由器独立计算最优路由，将最优路由信息写入路由表 中间系统到中间系统路由协议IS-IS：Intermediate System-to-Intermediate System (ISO) 内部网关路由协议IGRP: Interior Gateway Routing Protocol (Cisco) 自治域间路由 边界网关协议BGP-4: Border Gateway Protocol 目前互联网中唯一实际运行的自治域间的路由协议 BGP功能 eBGP: 从相邻的AS获得网络可达信息 iBGP: 将网络可达信息传播给AS内的路由器 基于网络可达信息和策略决定到其他网络的“最优”路由 BGP报文 BGP通过TCP的179端口交换报文 BGP报文包括: Open报文：用于建立BGP对等体（peer）之间的会话连接，协商BGP参数（该过程需要认证） Update报文：用于在对等体之间交换路由信息 Keepalive报文：用于保持BGP会话连接 Notification报文：用于差错报告和关闭BGP连接 软件定义网络(SDN)软件定义网络核心思想 解耦： 将控制平面和数据平面进行分离，解决传统网络中控制平面和数据平面在物理上紧耦合导致的问题解决的问题 控制平面和数据平面之间不需要相互依赖，只需要遵循一定的开放接口即可进行通信 控制平面：负责决策控制，由软件实现，灵活 数据平面：专注数据转发，可有由通用硬件实现 抽象： 转发抽象：将数据平面抽象为通用的转发模型，如Openflow的交换机模型，各种转发表项，如MAC地址表、路由表、NAT 转换表等，抽象为统一的流表 分布状态抽象：控制层将设备的分布状态，抽象成全局的网络视图，从而实现逻辑的集中控制，具体可以通过网络操作系统来实现 网络操作系统（NOS）：下发控制命令，收集设备和链路状态，为上层应用提供全局网络视图 配置抽象：网络行为的表达通过编程语言实现，将抽象配置映射为物理配置，利用控制器提供的API，通过控制器配置全局设备 接口层原理与协议 接口层提供同一物理网络中各节点之间的连接和通信 同一个物理网络必须执行相同的接口层协议 不同的物理网络接口层协议可以不同 接口层基础物理网络连接方式：节点到节点连接、共享式连接、交换式连接 接口层功能 物理层：提供位流服务 传输介质和拓扑结构定义 编码与解码(数据→信号) 信号的发送与接收 时钟同步 数据链路层：提供可靠或不可靠的传输服务 数据单元及寻址方式定义 链路层差错检测 链路层的复用和分用 可靠数据传输 共享式连接：提供介质访问控制方法 交换式连接：数据单元转发 接口层技术分类 有多种接口层技术，传统上大致可以分成三类 局域网技术(LAN, Local Area Network ) 如：以太网(Ethernet)、无线局域网(WiFi) 城域网技术(MAN, Metropolitan Area Network) 如：FDDI、交换式Ethernet 广域网技术Wide Area Network (WAN) 如：ATM 其他接口技术 个人区域网 如：蓝牙技术(Bluetooth) 无线传感网络 如：Zigbee技术 局域网体系结构与组网方法介质访问控制层(Medium Access Control ) 物理节点寻址 差错控制 介质访问控制（共享式连接） 逻辑链路控制层（Logical Link Control） 链路层的复用和分用 可靠数据传输 共享式局域网 网络中任一节点发送的信息会被网络中所有节点收到（广播传输） 例如，共享式以太网，无线局域网，FDDI等 需要协调节点对共享介质的访问 介质访问控制方法 交换式局域网 链路采用点到点连接 例如，交换式以太网 交换机成为网络连接的核心 完成链路层数据单元的转发 通常采用统计多路复用 MAC地址—物理地址 32位IP地址: 网络层地址（逻辑地址）：标识主机或路由器的一个接口 主要用于IP数据包的路由转发 48位MAC地址（物理地址）: 物理地址：在相同的物理网络中，标识一个节点 对于大多数局域网，采用48位MAC地址 位于网卡的ROM或EPROM中 扁平地址，无层次，需要唯一 局域网编址与ARP协议ARP协议ARP: Address Resolution Protocol 局域网的每个IP节点（主机或路由器）都有ARP表 ARP表缓存IP地址和MAC地址的映射关系 链路层差错控制在数据链路层中，广泛使用循环冗余校验（Cyclic Redundancy Check ）CRC校验码计算方法 设原始数据D为k位二进制位模式 如果要产生n位CRC校验码，事先选定一个n+1位二进制位模式G（称为生成多项式），G的最高位为1 将原始数据D乘以$2^n$ （相当于在D后面添加n 个0），产生k+n位二进制位模式，用G对该位模式做模2除，得到余数R（n位，不足n位前面用0补齐）即为CRC校验码 共享式与交换式以太网共享式以太网：连接方式与功能 连接方式 方式1：通过同轴电缆连接（10Mbps以太网） 方式2：通过双绞线、光纤与集线器连接 服务：面向非连接的不可靠服务 功能 物理层 信号编码、时钟同步等，如差分曼彻斯特编码 介质访问控制层 介质访问控制：CSMA/CD 差错检测 逻辑链路控制层 复用与分用 虚拟局域网基于端口的VLAN: 交换机的端口被分组，单个物理交换机能够作为多个虚拟交换机运行 基于端口VLAN原理： 隔离通信流量: 来自于或到达端口1-8的流量只能到达1-8 也可以基于MAC地址定义VLAN 动态配置: 端口能够在VLAN之间动态配置 VLAN之间转发:类似独立的交换机，通过路由进行转发 无线局域网802.11无线局域网组网模式 基础架构模式： 站点（STA） 访问点（AP） 基本服务器（BSS） 扩展服务器（ESS） 注：每个BSS中的站点和AP共享同一无线信道；站点通过AP转发数据 自组织模式： 站点（STA） 独立基本服务器（IBSS） 站点之间直接通信 共享同一无线信道 注：每个站点在某个时刻只能工作在一种模式","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://kpl0111.github.io/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"LightSensor","date":"2021-04-23T19:31:03.000Z","path":"2021/0420210424.html","text":"光线传感器实验目的本次实验的目的是让大家了解Android中光线传感器的基本知识，掌握Android中光线传感器的使用方法。 实验要求 了解Android中光线传感器基本知识 掌握Android中光线传感器使用方法 基础知识光线传感器基础 光线传感器的好处是可以根据手机所处环境的光线来调节手机屏幕的亮度和键盘灯。例如在光线充足的地方屏幕会很亮，键盘灯就会关闭。相反如果在暗处，键盘灯就会亮，屏幕较暗（与屏幕亮度的设置也有关系），这样既保护了眼睛又节省了电量。光线传感器在进入睡眠模式时候会发出蓝色周期性闪动的光，非常美观。在本节的内容中，将详细讲解Android系统光线传感器的基本知识。光线传感器介绍在Android设备中，光线传感器通常位于前摄像头旁边的一个小点，如果在光线充足的情况下（室外或者是灯光充足的室内），大约在2～3秒之后键盘灯会自动熄灭，即使再操作机器键盘灯也不会亮，除非到了光线比较暗的地方才会自动地亮起来。如果在光线充足的情况下用手将光线感应器遮上，在2～3秒后键盘灯会自动亮起来，在此过程中光线感应器起到了一个节电的功能。要想在Android设备中监听光线传感器，需要掌握如下所示的监听方法。 registerListenr(SensorListenerlistenr,int sensors,int rate)：已过时。 registerListenr(SensorListenerlistenr,int sensors)：已过时。 registerListenr(SensorEventListenerlistenr,Sensor sensors,int rate)。 registerListenr(SensorEventListenerlistenr,Sensor sensors,int rate,Handlerhandler)：因为SensorListener已经过时，所以相应的注册方法也过时了。 在上述方法中，各个参数的具体说明如下所示。 Listener：相应监听器的引用。 Sensor：相应的感应器引用。 Rate：感应器的反应速度，这个必须是系统提供的4个常量之一。 SENSOR_DELAY_NORMAL：匹配屏幕方向的变化。 SENSOR_DELAY_UI：匹配用户接口。 SENSOR_DELAY_GAME：匹配游戏。 SENSOR_DELAY_FASTEST.：匹配所能达到的最快。 实验内容按照实验的内容进行操作，掌握Android中光线传感器的使用方法等内容。完成实验内容后，设计一个光线传感器的app，至少包含如下功能： 显示当前光线传感器的光照强度； 显示当前光线传感器的名称，耗电量，以及最大测量范围。 获取上述参数方法如下： myS = mySm.getDefaultSensor(Sensor.TYPE_LIGHT); 名称：myS.getName() ; 耗电量（mA）：myS.getPower(); 最大测量范围：myS.getMaximumRange() 实验过程 利用Android studio创建一个工程，并利用实体机或者安卓虚拟机进行测试（这里我先利用逍遥模拟器进行测试，成功之后，连接真机进行测试） 修改activity_main.yml文件，新建一个静态文本控件用来输出我们要输出的亮度传感器的有关信息，这里新建工程初始化时会自动生成一个文本控件，文本内容默认为“Hello World！”，所以只需在其基础上进行修改即可 &lt;TextView android:id=\"@+id/textView1\"//为控件添加编号textView1 android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\"//初始化文本内容 app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; 修改Mainactivity.java文件对传感器进行控制并进行文本输出 //这里仅展示所需主要代码。具体代码见工程文件 public class MainActivity extends Activity implements SensorEventListener { private SensorManager sensor;//定义一个传感器管理器 private TextView text;//定义一个文本控件 @Override protected void onCreate(Bundle savedInstanceState) {//项目初始化函数 super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sensor = (SensorManager)getSystemService(SENSOR_SERVICE);//调用getSystemService函数来获取传感器控制权 text = (TextView)findViewById(R.id.textView1);//通过控件ID将实体文本控件与代码连接起来 } @Override public void onSensorChanged(SensorEvent event) { // 在传感器控制函数里面实现我们的功能 float[] values = event.values; //定义变量来获取事件的值 int sensorType = event.sensor.TYPE_LIGHT; //定义值为事件发生时的传感器变量值 if(sensorType==Sensor.TYPE_LIGHT){//如果对应系统中的亮度传感器，则证明是亮度发生变化 String detail=\"\\n传感器名称：\"+(event.sensor.getType()==Sensor.TYPE_LIGHT?(event.sensor.getName()+\"\\n中文名称：光照传感器\"):\"\")+\"\\n耗电量：\"+event.sensor.getPower()+\"\\n最大测量范围：\"+event.sensor.getMaximumRange();//定义字符串来实现输出，调用getName，getPower，getMaximumRange函数来获取传感器参数 text.setText(detail+\"\\n当前光照强度：\"+String.valueOf(values[0])+\"Lux\\n\");//将静态文本控件内容更新为传感器信息 text.setTextSize(30);//设置字体大小 text.setTextColor(Color.parseColor(\"#ff5e9cff\"));//#7E0C6E设置字体颜色 } } } 软件效果展示","tags":[{"name":"Android","slug":"Android","permalink":"https://kpl0111.github.io/blog/tags/Android/"},{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"}]},{"title":"Ucore_lab1","date":"2021-04-13T08:26:17.000Z","path":"2021/0420210413.html","text":"说明在解压后的ucroe源码包中使用make命令即可以生成所需的目标文件,例如在本次实验中 user@system:~../lab1$ make 之后就会在bin文件夹生成一系列的目标文件： user.img : 被qemu访问的虚拟硬盘文件 kernel : ELF格式的toy ucore kernel执行文，嵌入到了ucore.img中 bootblock : 虚拟的硬盘主引导扇区(512字节)，包含了bootloader执行代码，同样嵌入了 sign : 外部执行程序，用来生成虚拟的硬盘主引导扇区还有其他文件，不一一列举。 如果要对修改后的ucore代码和ucore 源码进行比较，可以使用diff命令。 user@system:~../lab1$ diff 目标文件 源文件 练习11. 操作系统镜像文件ucore.img如何生成？ 执行指令 user@system:~../lab1$ make \"V=\" 可以获得Makefile中执行的具体指令，详细信息如下（仅列举有关ucore.img文件生成相关指令）: + cc kern/init/init.c gcc -c kern/init/init.c -o obj/kern/init/init.o + cc kern/libs/readline.c gcc -c kern/libs/readline.c -o obj/kern/libs/readline.o + cc kern/libs/stdio.c gcc -c kern/libs/stdio.c -o obj/kern/libs/stdio.o + cc kern/debug/kdebug.c gcc -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o + cc kern/debug/kmonitor.c gcc -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o + cc kern/debug/panic.c gcc -c kern/debug/panic.c -o obj/kern/debug/panic.o + cc kern/driver/clock.c gcc -c kern/driver/clock.c -o obj/kern/driver/clock.o + cc kern/driver/console.c gcc -c kern/driver/console.c -o obj/kern/driver/console.o + cc kern/driver/intr.c gcc -c kern/driver/intr.c -o obj/kern/driver/intr.o + cc kern/driver/picirq.c gcc -c kern/driver/picirq.c -o obj/kern/driver/picirq.o + cc kern/trap/trap.c gcc -c kern/trap/trap.c -o obj/kern/trap/trap.o + cc kern/trap/trapentry.S gcc -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o + cc kern/trap/vectors.S gcc -c kern/trap/vectors.S -o obj/kern/trap/vectors.o + cc kern/mm/pmm.c gcc -c kern/mm/pmm.c -o obj/kern/mm/pmm.o + cc libs/printfmt.c gcc -c libs/printfmt.c -o obj/libs/printfmt.o + cc libs/string.c gcc -c libs/string.c -o obj/libs/string.o + ld bin/kernel ld -o bin/kernel obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o obj/libs/printfmt.o obj/libs/string.o + cc boot/bootasm.S //编译bootasm.S gcc -c boot/bootasm.S -o obj/boot/bootasm.o + cc boot/bootmain.c //编译bootmain.c gcc -c boot/bootmain.c -o obj/boot/bootmain.o + cc tools/sign.c //编译sign.c gcc -c tools/sign.c -o obj/sign/tools/sign.o gcc -O2 obj/sign/tools/sign.o -o bin/sign + ld bin/bootblock //根据sign规范生成bootblock ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o 在makefile文件中搜索ucore.img可以找到 #create ucore.img UCOREIMG :=$(call totarget,ucore.img) $(UCOREIMG):$(kernel)$(bootblock) $ $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc $(call create_target,ucore.img) 可以看出ucore.img镜像文件是由kernel和bootblock文件生成的。 $(V)dd if=/dev/zero of=$@ count=100000 这句语句可以看到UCOREIMG分配了一定空间。 (V)dd if=$(bootblock) of=$@ conv=notrunc 这句语句将bootblock复制到上面分配的空间当中。 $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc 该语句将kernel复制到分配的空间当中。 1.kernel生成 kernel = $(call totarget,kernel) $(kernel): tools/kernel.ld 通过链接来生成kernel目标文件 $(kernel): $(KOBJS) kernel的生成还依赖KOBJS @echo + ld $@ $(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) @$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel) @$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; $(call symfile,kernel) $(call symfile,kernel) kernel = $(call totarget,kernel) 2.bootblock生成 bootfiles = $(call listf_cc,boot) 用boot替换listf_cc里面的变量，将listf_cc的返回值赋给bootfiles,也就是滤出.c,.s文件 $(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc)) 编译bookfiles bootblock = $(call totarget,bootblock) 生成bootblock $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign) 生成目标文件bootblock需要依赖于sign和bootfiles @echo + ld $@ 将以下文件与bootblock连接起来 $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock) @$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock) @$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock) @$(call totarget,sign) $(call outfile,bootblock) $(bootblock) $(call create_target,bootblock) 3.生成sign工具 $(call add_files_host,tools/sign.c,sign,sign) $(call create_target_host,sign,sign) 由sign工具、bootfile生成bootblock 由KOBJS生成kernel 由kernel和bootblock生成最终的ucore.img 2.一个被系统认为是符合规范的硬盘主引导扇区的特征是什么? 通过查阅资料我们可以知道bootblock区域包含用于引导的最小指令集，而在上一个问题中我们发现bootblock的生成需要依赖于sign.c文件和bootfiles文件，其中bootfiles提供开机启动所需要的文件，而sign.c则代表生成bootblock的规范。 因此，我们去在文件夹中查看sign.c文件。 文件代码如下： char buf[512]; //定义buf数组 memset(buf, 0, sizeof(buf)); // 把buf数组的最后两位置为 0x55, 0xAA buf[510] = 0x55; buf[511] = 0xAA; FILE *ofp = fopen(argv[2], \"wb+\"); size = fwrite(buf, 1, 512, ofp); if (size != 512) { //大小为512字节 fprintf(stderr, \"write '%s' error, size is %d.\\n\", argv[2], size); return -1; } 通过查看这里的代码，我们可以发现sign规范中给buf提供了512个字节的空间，而且bootblock的格式是最后两个字节分别是0x55和0xAA，而这也是操作系统课上提到的两个神奇的数。 练习21.使用qemu调试make文件 在进入lab1文件夹之后，使用命令 make debug 进入调试模式。 （1）在查看了tools文件夹中的gdbinit文件之后，可以看到存在代码 target remote localhost：1234 这代表着在启动之后会连接qemu和gdb。 （2）在make debug之后输入stepi，可以按照机器指令单步执行。 （3）一开始进入的是init.c程序。提示是init the console。 （4）再执行几次step执行源代码之后，就进入stdio.c文件。 （5）像这样反复执行step/next语句，就可以按照程序源代码一步一步执行了。 2.在初始化位置0x7c00设置实地址断点 在tools文件夹中的gdbinit文件中增加”b*0x7c00”语句，可以在实地址0x7c00位置设置一个断点。 3.单步跟踪反汇编得到的代码与bootasm.s和bootblock.asm进行比较 在位置0x7c00位置之后单步执行机器指令并且查看反汇编语句，和gedit打开的bootblock.asm文件进行对比。可以找到这个位置正好在bootblock.asm文件中。在位置0x7c00这里有着相同的语句。 注意在这里要在gdb中执行如下的指令 define hook-stop x/i $pc end 这样才可以进入反汇编的状态 同时我们查看bootasm.s文件之后，可以看到这样的代码 \\#Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00) movl $0x0, %ebp movl $start, %esp call bootmain 意味着从这里开始跳转到0x7c00. 4.自己找一个bootloader或者内核中的代码位置，设置断点并进行测试 像上个问题一样在gdbinit里面写入*b 0x7c1a，设置断点，然后类似的进行单步调试。 练习3分析bootloader进入保护模式的过程。BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。提示：需要阅读小节“保护模式和分段机制”和lab1/boot/bootasm.S源码，了解如何从实模式切换到保护模式，需要了解：1、为何开启A202、以及如何开启A203、 如何初始化GDT表4、如何使能和进入保护模式 分析首先bootloader从实模式进入保护模式要经过一下几个步骤： 1、开启A20门 2、建立GDT表并对其进行初始化操作 3、设置cr0寄存器的值为1 当寄存器值切换后方可表示模式切换成功初始状态A20地址线被屏蔽所以一直保持为0，我们要进一步访问内存需要A20地址线，需要将其打开。一、开启A20打开A20 Gate的具体步骤大致如下： 1、等待8042 Input buffer为空 2、发送Write 8042 Output Port （P2） 命令到8042 Input buffer 3、等待8042 Input buffer为空 4、将8042 Output Port（P2） 对应字节的第2位置1，然后写入8042 Input buffer # 开启A20：通过将键盘控制器上的A20线置于高电位，全部32条地址线可用， # 可以访问4G的内存空间。 seta20.1: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.1 movb $0xd1, %al # 0xd1 -&gt; port 0x64 outb %al, $0x64 # 0xd1 means: write data to 8042's P2 port seta20.2: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 0xdf -&gt; port 0x60 outb %al, $0x60 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1 二、建立并初始化GDT,寄存器置为1# Switch from real to protected mode, using a bootstrap GDT # and segment translation that makes virtual addresses # identical to physical addresses, so that the # effective memory map does not change during the switch. # 初始化GDT表：一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可 lgdt gdtdesc movl %cr0, %eax #进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式 orl $CR0_PE_ON, %eax movl %eax, %cr0 完成以后步骤后bootloader已经从实模式进入到了保护模式练习4分析BootLoader加载ELF格式的OS的过程 通过阅读bootmain.c,了解bootloader如何加载ELF文件。通过分析代码和通过qemu来运行调试 分析首先看bootmain函数 void bootmain(void){ //read the 1st page off disk readseg((uintptr_t)ELFHDR,SECTSIZE*8,0); //is this a valid ELF? if (ELFHDR-&gt;e_magic !=ELF_MAGIC){ goto bad; } struct proghdr *ph,*eph; // load each program segment(ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR+ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; for(;ph&lt;eph;ph++){ readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); } // call the entry point from the ELF header // note:does not return ((void(*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))(); bad: outw(0x8A00,0x8A00); outw(0x8A00,0x8E00); /* do nothing */ while(1); } 先是读磁盘，转入readseg函数 static void readseg(uintptr_t va,uint32_t count,uint32_t offset){ uintptr_t end_va = va + count; //round down to sector boundary va -= offset % SECTSIZE ; //translate from bytes to sectors; kernel starts at sector 1 uint32_t secno = (offset / SECTSIZE) + 1; //If this is too slow , we could read lots of sectors at a time. //We'd write more to memory than asked,but it doesn't matter -- //We load in increasing order. for(; va &lt; end_va; va += SECTSIZE, secno ++){ readsect((void*)va,secno); } } 从readseg函数发现又调用了readsect函数 static void readsect(void *dst,unit32_t secno){ //wait for disk to be ready waitdisk(); outb(0x1F2, 1);//要读写的扇区数，需要表明要读写几个扇区 outb(0x1F3, secno &amp; 0xFF);//LBA参数的0~7位 outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);//LBA参数的8~15位 outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);//LBA参数的16~23位 outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);//第0~3位：LBA参数的24-27位 第4位：为0主盘；为1从盘 outb(0x1F7,0x20);//状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口 读数据 //wait for disk to be ready waitdisk(); //read a sector insl(0x1F0,dst,SECTSIZE/4);//读取扇区 读一个扇区的流程大致如下： 等待磁盘准备好 发出读取扇区的命令 等待磁盘准备好 把磁盘扇区数据读到指定内存 其中的outb是一个机器指令，是在x86.h中的 static inline void outb(uint16_t port, unit8_t data){ asm volatile(\"outb %0, %1\" :: \"a\"(data), \"d\"(port)); } 用内联汇编实现，用了I0空间寻址方式，能将外部的数据读到内存中来，这也是x86里面的寻址方式 可以发现首先是等磁盘准备好，然后是写入地址和读取磁盘的命令，最后是按照地址读取磁盘扇区（可参考代码中的中文注释） 再接着看main函数，用了一个if语句判断是否为ELF文件，具体判断方式为将ELF header中的一个e_magic和一个特定值进行比较，若不是则转入bad,是则继续执行 struct proghdr *ph,*eph; // load each program segment(ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR+ELFHDR-&gt;e_phoff);//将ELF文件的头部文表取出存到ph eph = ph + ELFHDR-&gt;e_phnum; for(;ph&lt;eph;ph++){ #加载ELF文件到内存 readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); } // call the entry point from the ELF header // note:does not return ((void(*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();//ELF文件加载完毕后，将控制权交给ucore去执行 由此完成ELF文件的加载练习5完成kdebug.c中函数print_stackframe的实现，可以通过函数&gt;print_stackframe来跟踪函数调用堆栈中记录的返回地址。 1、函数堆栈的原理 理解函数堆栈最重要的两点是：栈的结构，以及EBP寄存器的作用。 一个函数调用动作可分解为零到多个 PUSH指令（用于参数入栈）和一个 CALL 指令。CALL 指令内部其实还暗含了一个将返回地址压栈的动作，这是由硬件完成的。几乎所有本地编译器都会在每个函数体之前插入类似如下的汇编指令： pushl %ebp movl %esp,%ebp 这两条汇编指令的含义是：首先将ebp 寄存器入栈，然后将栈顶指针 esp 赋值给 ebp。 movl %esp %ebp这条指令表面上看是用esp覆盖 ebp原来的值，其实不然。因为给 ebp赋值之前，原ebp 值已经被压栈（位于栈顶），而新的ebp又恰恰指向栈顶。此时ebp寄存器就已经处于一个非常重要的地位，该寄存器中存储着栈中的一个地址（原 ebp入栈后的栈顶），从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的ebp值。 我们可以直接根据ebp就能读取到各个栈帧的地址和值，一般而言，ss:[ebp+4]处为返回地址，ss:[ebp+8]处为第一个参数值（最后一个入栈的参数值，此处假设其占用 4 字节内存，对应32位系统），ss:[ebp-4]处为第一个局部变量，ss:[ebp]处为上一层 ebp 值。 如图 2、print_stackframe函数的实现 首先我们直接看到print_stackframe函数的注释： void print_stackframe(void) { /* LAB1 YOUR CODE : STEP 1 */ /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t); * (2) call read_eip() to get the value of eip. the type is (uint32_t); * (3) from 0 .. STACKFRAME_DEPTH * (3.1) printf value of ebp, eip * (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4] * (3.3) cprintf(\"\\n\"); * (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc. * (3.5) popup a calling stackframe * NOTICE: the calling funciton's return addr eip = ss:[ebp+4] * the calling funciton's ebp = ss:[ebp] */ } 这样我们直接根据注释以及之前的相关知识就能比较简单的编写成程序，如下所示： void print_stackframe(void) { uint32_t ebp=read_ebp();//(1) call read_ebp() to get the value of ebp. the type is (uint32_t) uint32_t eip=read_eip();//(2) call read_eip() to get the value of eip. the type is (uint32_t) int i; for(i=0;i&lt;STACKFRAME_DEPTH&amp;&amp;ebp!=0;i++){//(3) from 0 .. STACKFRAME_DEPTH cprintf(\"ebp:0x%08x eip:0x%08x \",ebp,eip);//(3.1)printf value of ebp, eip uint32_t *tmp=(uint32_t *)ebp+2; cprintf(\"arg :0x%08x 0x%08x 0x%08x 0x%08x\",*(tmp+0),*(tmp+1),*(tmp+2),*(tmp+3));//(3.2)(uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4] cprintf(\"\\n\");//(3.3) cprintf(\"\\n\"); print_debuginfo(eip-1);//(3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc. eip=((uint32_t *)ebp)[1]; ebp=((uint32_t *)ebp)[0];//(3.5) popup a calling stackframe } } 实验结果截图如下： 练习6：完善中断初始化和处理1、中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？2、请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。3、请编程完善trap.c中的中断处理函数trap,在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统毎遇到100次时钟中断后，调用print_tricks子程序，在屏幕上打印一行文字“100 ticks”。 1、中断描述符表中一个表项占8字节 如上图所示，其中的0-15位是offset的低16位，48-63位是offset的高16位，16-31位是段选择子，用于索引全局描述符表GDT来获取中断处理代码对应的段地址，再加上段内偏移量即可得到中断处理代码的入口。 2、完善初始化函数 （1）根据函数中的注释提示，第一步是声明__vertors[]; (2) 第二步是使用SETGATE填充中段描述符表IDT (3) 第三步是使用lidt指令让CPU加载中断描述符表IDT 具体的代码如下： void idt_init(void){ extern uintptr_t __vecors[]; int i; for(i=0; i &lt; 256; i++){ SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL); } SETGATE(idt[T_SWITCH_TOK],0,GD_KTEXT,__vectors[T_SWITCH_TOK],DPL_USER); lidt(&amp;idit_pd); } 其中宏SETGATE的定义为 #define SETGATE(gate, istrap, sel, off, dpl) GD_KTEXT和DPL_KERNEL的定义在memlayout.h中 gate表示处理函数的入口地址，此处即idt[]数组中的内容istrap表示1为异常门，0为中断门sel表示段选择子off表示偏移量，此处即__vectors[]数组中的内容dpl表示设置等级，此处设置为DPL_KERNEL，恒为0 3、编写函数根据提示，需要用一个全局变量记录每次时钟中断，然后用print_ticks()打印“100 ticks”后重新从0开始计数，参照clock.c,写出如下函数： case IRQ_OFFSET+IRQ_TIMER: ticks=ticks+1; if(ticks==TICK_NUM){ print_ticks(); ticks=0; } break; 其中TICK_NUM已被定义为100 最后的运行结果为下图： Challenge 1&amp;2 新建用户态并进行内核态互换通过编写c++内联汇编函数，来实现用户态和内核态的切换。 已知初始化内核的函数如下： static void switch_test(void) { print_cur_status(); // print 当前 cs/ss/ds 等寄存器状态 cprintf(\"+++ switch to user mode +++\\n\"); switch_to_user(); // switch to user mode print_cur_status(); cprintf(\"+++ switch to kernel mode +++\\n\"); switch_to_kernel(); // switch to kernel mode print_cur_status(); } 而在init.c里面没有switch_to_user函数的内容以及switch_to_kernel函数的内容，因此这些部分需要编程。 1.调到用户态 通过编写switch_to_user的内容来使在内核初始化的时候可以切换到用户态。 asm volatile ( \"sub $0x8, %%esp \\n\" \"int %0 \\n\" \"movl %%ebp, %%esp\" : : \"i\"(T_SWITCH_TOU) ); 通过编写内联汇编语句来实现切换，用中断处理int 0来实现，需要输入的“i”也就是T_SWITCH_TOU。调整栈顶指针和栈底指针开辟程序空间之后，进行中断来实现切换。 在trap.c中要修改t_switch_tou的内容 case T_SWITCH_TOU: if (tf-&gt;tf_cs != USER_CS) { switchk2u = *tf; switchk2u.tf_cs = USER_CS; switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS; switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8; switchk2u.tf_eflags |= FL_IOPL_MASK; *((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u; } break; 这段代码可以使原来的状态不是用户态时候，将原来的状态修改成用户态。 switchk2u.tf_eflags |= FL_IOPL_MASK; *((uint32_t*)tf - 1) = (uint32_t)&amp;switchk2u; 将这里的标记确认成为用户态，并且中断返回到正确的栈。 2.用户态到内核态 用类似的内联汇编处理。 asm volatile ( \"int %0 \\n\" \"movl %%ebp, %%esp \\n\" : : \"i\"(T_SWITCH_TOK) ); 因为切换到的是内核态，不需要更多空间，所以相比内核到用户的内联汇编不再需要在栈指针减去一个值来开辟空间。 然后我们同样需要在trap.c中修改T_SWITCH_TOK的内容 case T_SWITCH_TOK: if (tf-&gt;tf_cs != KERNEL_CS) { tf-&gt;tf_cs = KERNEL_CS; tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS; tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK; switchu2k = (struct trapframe *)(tf-&gt;tf_esp (sizeof(struct trapframe) - 8)); memmove(switchu2k, tf, sizeof(struct trapframe) - 8); *((uint32_t *)tf - 1) = (uint32_t)switchu2k; } 跟之前切换的修改类似 3.实现切换case IRQ_OFFSET + IRQ_KBD: c = cons_getc(); cprintf(\"kbd [%03d] %c\\n\", c, c); if(c == '0' &amp;&amp; (tf-&gt;tf_cs &amp; 3) != 0) { cprintf(\"Input 0......switch to kernel\\n\"); tf-&gt;tf_cs = KERNEL_CS; tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS; tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK; } else if (c == '3' &amp;&amp; (tf-&gt;tf_cs &amp; 3) != 3) { cprintf(\"Input 3......switch to user\\n\"); tf-&gt;tf_cs = USER_CS; tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS; tf-&gt;tf_eflags |= FL_IOPL_MASK; } break; 修改完代码之后执行 make qemu 键盘输入0或3即可实现切换 最终评分","tags":[{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"},{"name":"OS","slug":"OS","permalink":"https://kpl0111.github.io/blog/tags/OS/"}]},{"title":"可视化第一次作业","date":"2021-04-09T17:52:16.000Z","path":"2021/042021410.html","text":"作业内容1．编程实现消息测试程序，满足以下要求： 按下键盘任意字符键（至少识别两个功能键），客户区中显示按键信息（字符或功能键内容）； 单击鼠标左键，消息对话框中显示鼠标信息（鼠标左键+坐标）； 假设鼠标右键失灵，用Ctrl+鼠标左键代替，消息对话框中显示鼠标信息（鼠标右键+坐标）； 自定义WM_MY_MESSAGE消息，带10和100两个参数，由“#”（不是“3”）键激活，客户区中显示相应信息（自定义消息+参数）。 2．编程实现SmallBall程序，满足以下要求： 黑色小球，从左上角开始，沿着45度方向移动，遇到边界反弹； 通过两个菜单项（加速与减速），调节小球的移动幅度（递增或递减）； 通过两个工具栏按钮，控制小球停止与再次启动。 展示Key 常规按键 功能键 单击鼠标左键 Ctrl+鼠标左键替代鼠标右键 自定义Message Ball 加速 减速 暂停 启动 有轨迹 状态栏 实现过程Key添加命令在MESSAGE_MAP处添加本项目所需所有打印命令，包括自定义命令。 BEGIN_MESSAGE_MAP(CKeyView, CView) //标准打印命令 ON_COMMAND(ID_FILE_PRINT, &amp;CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_DIRECT, &amp;CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_PREVIEW, &amp;CView::OnFilePrintPreview) ON_WM_LBUTTONUP() ON_WM_CHAR() ON_WM_KEYDOWN() ON_MESSAGE(WM_MYMESSAGE, OnMyMessage) END_MESSAGE_MAP() 头文件函数声明在KeyView.h头文件里面声明OnLButtonUp，OnChar，PreTranslateMessages，以及OnMyMessage函数 protected: afx_msg void OnLButtonUp(UINT nFlags, CPoint point); //添加鼠标左键点击函数，以及按键事件函数 afx_msg void OnChar(UINT nChar, UINT nRedCnt, UINT nFlags); virtual BOOL PreTranslateMessage(MSG* pMsg); afx_msg LRESULT OnMyMessage(WPARAM wParam, LPARAM lParam); void CKeyView::OnLButtonUp(UINT nFlags, CPoint point)本函数主要实现鼠标左键点击以及替代右键功能，利用if语句如果是Ctrl+鼠标左键的话，则输出右键点击，并利用point来获取当前坐标，使用TextOutW来输出，如果if条件不成立，则输出左键点击 void CKeyView::OnLButtonUp(UINT nFlags, CPoint point) { CDC* pDC = GetDC(); CString m_str; if (nFlags &amp; MK_CONTROL)//ctrl+左键代表右键 m_str.Format(L\"X:%d,Y:%d:Right Mouse Button Clicked!\", point.x, point.y); else m_str.Format(L\"X:%d,Y:%d:Left Mouse Button Clicked!\", point.x, point.y); pDC-&gt;TextOutW(point.x, point.y, m_str); } void CKeyView::OnChar(UINT nChar, UINT nRedCnt, UINT nFlags)本函数主要实现常规按键和自定义消息#键（在自定义消息里面讲）的输出，首先获取当前按键的字符，如果不是#，则弹出弹框声明 void CKeyView::OnChar(UINT nChar, UINT nRedCnt, UINT nFlags) { if (nChar == '#') //按键如果是#则调用自定义消息，其他则调用系统消息 SendMessage(WM_MYMESSAGE, 10, 100); else { CString str; str.Format(L\"%c Key Entered!\", nChar); MessageBox(str); } CView::OnChar(nChar, nRedCnt, nFlags); } BOOL CKeyView::PreTranslateMessage(MSG* pMsg)本函数实现功能按键，主要思路就是通过pMsg的wParam来对应不同功能键，从而进行输出，考虑到shift和ctrl的常用性，并没有对其进行添加，其他功能键也类似```BOOL CKeyView::PreTranslateMessage(MSG* pMsg){ if (pMsg-&gt;message == WM_KEYDOWN)//添加功能键，方法类似可添加更多，常用ctrl和shift注释掉了以免影响其他键的操作 { if (pMsg-&gt;wParam == VK_F1) MessageBox(L”F1 Key Entered!”); if (pMsg-&gt;wParam == VK_F2) MessageBox(L”F2 Key Entered!”); if (pMsg-&gt;wParam == VK_F3) MessageBox(L”F3 Key Entered!”); if (pMsg-&gt;wParam == VK_F4) MessageBox(L”F4 Key Entered!”); if (pMsg-&gt;wParam == VK_F5) MessageBox(L”F5 Key Entered!”); if (pMsg-&gt;wParam == VK_F6) MessageBox(L”F6 Key Entered!”); if (pMsg-&gt;wParam == VK_F7) MessageBox(L”F7 Key Entered!”); if (pMsg-&gt;wParam == VK_F8) MessageBox(L”F8 Key Entered!”); if (pMsg-&gt;wParam == VK_F9) MessageBox(L”F9 Key Entered!”); if (pMsg-&gt;wParam == VK_F10) MessageBox(L”F10 Key Entered!”); if (pMsg-&gt;wParam == VK_F11) MessageBox(L”F11 Key Entered!”); if (pMsg-&gt;wParam == VK_F12) MessageBox(L”F12 Key Entered!”); if (pMsg-&gt;wParam == VK_UP) MessageBox(L”↑ Key Entered!”); if (pMsg-&gt;wParam == VK_DOWN) MessageBox(L”↓ Key Entered!”); if (pMsg-&gt;wParam == VK_LEFT) MessageBox(L”← Key Entered!”); if (pMsg-&gt;wParam == VK_RIGHT) MessageBox(L”→ Key Entered!”); //if (pMsg-&gt;wParam == VK_CONTROL) MessageBox(L”Ctrl Key Entered!”); if (pMsg-&gt;wParam == VK_CAPITAL) MessageBox(L”CapsLk Key Entered!”); //if (pMsg-&gt;wParam == VK_SHIFT) MessageBox(L”Shift Key Entered!”); } return CView::PreTranslateMessage(pMsg); } ##### 自定义消息 - 首先声明自己的消息名字和编号 #define WM_MYMESSAGE WM_USER+10 - 声明一个关于自定义消息的响应函数OnMyMessage - 在Onchar里面实现，如果按下#键，则SendMessage，含有两个参数10和100 if (nChar == ‘#’) //按键如果是#则调用自定义消息，其他则调用系统消息 SendMessage(WM_MYMESSAGE, 10, 100); ##### 定义主面板名称 cs.style &amp;= ~FWS_ADDTOTITLE; //修改主窗口标题m_strTitle = _T(“Key”); ### Ball 小球采用异或方法来实现小球的消除，也可以实现小球的轨迹消除，通过Timer来实现小球的不断移动和刷新，从而造成一种小球运动的现象， ##### 声明Ball类变量 public: afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);//声明timer afx_msg void OnDestroy(); afx_msg void OnTimer(UINT_PTR nIDEvent);private: int x; //x，y表示当前坐标，step_num表示步幅倍数，step_x,step_y表示每次移动距离的单位 int y; int step_num; int step_x; int step_y; int size; //小球大小 bool begin_pause; //小球状态 bool trail; //小球轨迹状态public: afx_msg void OnSpeedUp(); //声明加速函数 afx_msg void OnSpeedDown(); //声明减速函数 afx_msg void OnTrail(); //声明轨迹函数 afx_msg void OnBegin_Pause(); //声明状态函数 ##### 实现小球运动 不断函数调用来实现小球的运动，采用step_num来控制小球的速度，当按下加速键是step_num加1，加速，减速同理，当速度为1是，如果继续减速，将强制停止此操作，并弹出消息提示，暂停功能的实现是通过阶数当前计时器，开始则重新开启一个同样编号的计时器，轨迹的消除通过控制变量trail来实现，如果不需要轨迹，则执行异或操作将轨迹消除，并进行清屏，反之则不执行 int CBallView::OnCreate(LPCREATESTRUCT lpCreateStruct){ if (CView::OnCreate(lpCreateStruct) == -1) return -1; // TODO: 在此添加您专用的创建代码 SetTimer(1, 100, NULL);//计时器编号，刷新时间（ms)可以通过刷新时间来实现加速和减速 return 0; } void CBallView::OnDestroy(){ CView::OnDestroy(); KillTimer(1); } void CBallView::OnTimer(UINT_PTR nIDEvent){ if (nIDEvent == 1) { CRect rect; GetClientRect(&amp;rect); CDC* pDC = GetDC(); pDC-&gt;SetROP2(R2_XORPEN); pDC-&gt;Ellipse(x, y, x + size, y + size); x += step_xstep_num; //通过改变步幅倍率来改变速度 y += step_ystep_num; theApp.x_ = x; theApp.y_ = y; if (x&lt;0 || x&gt;rect.right - size) //转向操作 { step_x = 0 - step_x; } if (y&lt;0 || y&gt;rect.bottom - size) { step_y = 0 - step_y; } if (!trail) //是否保留轨迹，不保留则通过异或消除 pDC-&gt;Ellipse(x,y,x+size,y+size); } CView::OnTimer(nIDEvent);} ##### 菜单栏的实现 在资源视图中找到主视图进行添加相应部分，并添加事件来响应![image-20210410031318645](https://i.loli.net/2021/04/10/CGXbiHruFw5kjBp.png) void CBallView::OnSpeedUp() //加速函数，并弹出弹框提示速度信息{ // TODO: 在此添加命令处理程序代码 step_num++; theApp.speed_ = step_num; CString str; str.Format(L”Current speed:%d”, step_num); MessageBox(str);} void CBallView::OnSpeedDown() //减速函数，并弹出弹框提示速度信息，如果速度为1，仍要减速，则不允许减速，弹出提示消息{ // TODO: 在此添加命令处理程序代码 if (step_num &gt; 1) { step_num–; theApp.speed_ = step_num; CString str; str.Format(L”Current speed:%d”, step_num); MessageBox(str); } else//速度为1 { CString str; str.Format(L” Current speed:%d\\n\\dThe current speed is already the minimum.\\n No more deceleration is allowed.”, step_num); MessageBox(str); }} void CBallView::OnTrail()//是否保留轨迹，不保留则通过用白色刷新全屏来实现清屏{ // TODO: 在此添加命令处理程序代码 if (trail) { trail = false; CDC* pDC = GetDC(); CRect rc; GetClientRect(&amp;rc); pDC-&gt;FillSolidRect(&amp;rc, RGB(255, 255, 255)); pDC-&gt;SetROP2(R2_XORPEN); pDC-&gt;Ellipse(x, y, x + size, y + size); ReleaseDC(pDC); } else trail = true; } //void CBallView::OnBegin_Pause()//暂停实现方法一，步幅倍率为0，则一直在原地刷新，小球会一直闪动//{// // TODO: 在此添加命令处理程序代码// if (begin_pause == 0)// {// begin_pause = step_num;// step_num = 0;// }// else// {// step_num = begin_pause;// begin_pause = 0;// }//}void CBallView::OnBegin_Pause()//暂停实现方法二，通过kill掉Timer来实现暂停，开始则重新申请一个Timer{ // TODO: 在此添加命令处理程序代码 if (!begin_pause) { begin_pause = true; KillTimer(1); } else { SetTimer(1, 100, NULL); begin_pause = false; }} ##### 状态栏的实现 新建三个状态 速度，位置和时间，并将其添加到indicators数组里面，使用SetPaneInfo函数来设置三个状态的信息以及宽度，然后继续利用Timer来不断刷新，速度和位置采用全局变量来获得，时间则通过CTime::GetCurrentTime()函数实现。![image-20210410031352719](https://i.loli.net/2021/04/10/5Q8AhTBCuRIslO7.png) m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT)); m_wndStatusBar.SetPaneInfo(4, IDS_INDICATOR_SPEED, SBPS_POPOUT, 50);//设置三个信息的位置和宽度m_wndStatusBar.SetPaneInfo(5, IDS_INDICATOR_MESSAGE, SBPS_POPOUT, 110);m_wndStatusBar.SetPaneInfo(6, IDS_INDICATOR_TIME, SBPS_POPOUT, 50);RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, IDS_INDICATOR_TIME); //添加时间显示函数SetTimer(2, 100, NULL);CTime t1; CString str_1; //对三栏信息进行初始化str_1.Format(L”Speed:%d”, theApp.speed_);m_wndStatusBar.SetPaneText(4, str_1); CString str_2;str_2.Format(L”Location(%d,%d)”, theApp.x_, theApp.y_);m_wndStatusBar.SetPaneText(5, str_2); t1 = CTime::GetCurrentTime();m_wndStatusBar.SetPaneText(6, t1.Format(“%H:%M:%S”)); void CMainFrame::OnTimer(UINT_PTR nIDEvent)//通过timer来实现刷新{ CTime t1; CString str_1; str_1.Format(L\"Speed:%d\", theApp.speed_); m_wndStatusBar.SetPaneText(4, str_1); CString str_2; str_2.Format(L\"Location(%d,%d)\", theApp.x_, theApp.y_); m_wndStatusBar.SetPaneText(5, str_2); t1 = CTime::GetCurrentTime();//获取当前时间来刷新状态栏 m_wndStatusBar.SetPaneText(6, t1.Format(\"%H:%M:%S\")); CFrameWnd::OnTimer(nIDEvent); } ##### 定义主面板名称 cs.style &amp;= ~FWS_ADDTOTITLE; //修改主窗口标题m_strTitle = _T(“Ball”); ## 实验收获 通过本次实验掌握了MFC的基本操作，理解了其实现功能的机制（消息的发送和执行），了解了一些基本函数的使用的，在对其界面优化过程中，通过实践对其理解加深，主要存在困难就是对函数的使用，以及初步接触MFc对其实现机制不太了解，实验过后相信会有所提升。","tags":[{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"},{"name":"MFC","slug":"MFC","permalink":"https://kpl0111.github.io/blog/tags/MFC/"}]},{"title":"Hexo+Github搭建自己的博客","date":"2021-03-27T14:04:17.000Z","path":"2021/03711.html","text":"​ 今天算是把自己的简易博客给搭建了起来，虽然说很丑，很多地方优化还没做好，功能也不太全，但是，做事情嘛，总是要一步步来的，哪有一蹴而就的事情，自己慢慢摸索，踩了许多坑之后，也把这其中的原理摸索了个七七八八，虽然说要我写个主题是天大的难题，但是理解博客的架构，以及github的用法也是很容易的，甚至就连命令也因为出错太多，四处填坑而记得些常用的，所以说做事情别人教给自己的和自己摸索的是完全不一样的，当然这个摸索也是在其他大佬教程和错误修正基础之上摸索的，并不是“白手起家”，废话不多说，进入正题，记录一些我自己的搭建过程，也是那些像我一样的小白提供一个同样水平的教程，绝对包教包会，首先我们先来了解一下他们的工作原理，通俗理解，如有不对，欢迎指正。 关于Github​ 首先关于Github，本质上讲就是一个比较通用的代码托管平台。你可以将自己做的项目之类balabala的都放在里面，取用方便，最重要的是他完全免费，是一个很好的托管平台，做一些比较大的项目也可以多人协作（扯远了），回来说我们的博客，你可以在Github上面建立一个或者多个仓库，名字可以任意取，这些仓库本质没有区别，Github还为每个仓库提供一个页面还有主题（当然主体比较单一，还比较漂亮chou），当然你也可以选择自己搭配喜欢的主题。唯一不同之处就是Github给每个用户提供一个域名（username.github.io），当你的仓库以这个格式命名的时候，他就会默认这个仓库的界面就是你的网站主界面，其他的仓库就是他的子目录，就这么点区别，举个栗子，我的用户名是Test，那么我的网站主界面就是https://Test.github.io， 他所代表的仓库名字就是Test.github.io，如果我还有一个仓库名字是Blog，那么这个仓库的主界面就要用https://Test.github.io/Blog 打开，这样说就很简单易懂了吧，其他区别完全没有，名字你可随便改，当你给哪个仓库命名为username.github.io时，默认打开就是这个仓库主界面（当然站点配置也要改，不然会出错的）。 关于Git​ Git本身就是一个工具，这里我们用它来实现我们的各种命令，大致可以等同于命令行，可以用Git来安装各种插件，实现命令，这里不多介绍，后面过程中你就会明白。 关于Hexo​ 我们所使用的主题以及大部分插件都由Hexo提供，你可以把它理解为一家衣服店铺，我们来挑选我们喜欢的衣服（theme），同时它也提供裁裤腿，钉扣子（插件）服务，这样就可以理解了吧。 流程​ 简单介绍一下流程，非常简单。首先我们建立一个仓库以便我们能够放一些我们主题的配置文件在里面，当然仓库名字就要命名为username.github.io格式了，这样我们的主页面才会使我们配置的那样，然后我们需要在本地也创建一个仓库，在里面把我们平时用的代码等等都放在里面，然后把本地仓库和远程仓库连接，再把本地文件代码上传就可以得到我们想要的简洁漂亮的网站了，是不是很简单呢。 具体步骤仓库搭建仓库搭建可以参考一下这位大佬的博客：超详细Hexo+Github博客搭建小白教程 讲得非常详细，我就不再介绍了，做点其他有用的东西。 网站配置在你的本地文件夹里面会有一个_config.yml文件，这个就是你的网站的配置文件了，可以在里面配置你的网站名字，图标等等，基本上你想到的都可以在里面设置，具体每一项对应那个部分，hexo官网很详细，也不再多补充，可以参考Hexo文档，里面没有的话百度一下，你就知道，总的来说，不难要善用搜索引擎。 主题更换主题选择的话可以从Themes|Hexo上选你喜欢的，具体步骤里面每个主题作者都会介绍，大致过程是一样的，不管你是clone也好，下载zip主题文件也好，要保证你的主题文件夹在themes文件夹下面，然后回到你的网站的文件夹里面找到_config.yml配置文件，在里面找到theme，将其更改为你的主题，比如说我的是Ayer，就是这样 然后基本上就可以了，之后需要做的就是一些优化工作，讲几点大家会遇到的关键的： 会有两个_config.yml文件，一个位于你网站的页面，是你网站的配置文件，另一个是在你的主题文件夹里面，两个名字一样，但是千万不要弄混，不要修改错文件，这两个都是配置文件，所以名字相同，但是配置的对象不一样，这点明白，应该就很简单了。 更换主题的步骤基本上就是theme后面换上你的主题名字，然后在安装你的主题所需要的插件，比如说你的网站想要有一个播放器小图标，但是你不给安装插件，就算主题配置里面作者配置的再全，也不可能有用，所以说要按照主题安装说明安装插件（在网站主页面右键Git Bush Here),然后修改主题配置文件就可以 格式极其重要，修改配置问件事要注意中间要有一个空格才能有效注意注释前也要有空格 最后放两张我的文件夹，以便大家区分两个配置文件，看不懂的话可以看文件夹上方的路径，路径也看不懂那就没办法了 主文件夹 主题页 最后一点：不要怕出错，实践出真知，搞这个东西没错一段时间是没有游戏体验的，你懂的，这也是一个学习的过程，所以不要急，慢慢来，涨涨姿势，等到把雏形弄出来再慢慢搞UI也不迟。 最后欢迎大家补充，有地方不懂得可以留言，也可以发邮件，看到会回复的，祝大家能尽快拥有自己的网站。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kpl0111.github.io/blog/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://kpl0111.github.io/blog/tags/Blog/"},{"name":"Github","slug":"Github","permalink":"https://kpl0111.github.io/blog/tags/Github/"}]}]