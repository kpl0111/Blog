[{"title":"Hello Nefelibata!","date":"2099-12-31T12:50:55.000Z","path":"2099/12c5804086.html","text":"Hello Nefelibata! image-20210407205253791 9f793abca820791d52dae9e921ce535","tags":[]},{"title":"补个票","date":"2023-11-28T12:40:04.000Z","path":"2023/113cf76af5.html","text":"😆 20231128204017 大镖客2一直名声不错，是一款可以称得上艺术的作品，虽然已经体验过某区的离线版本了，但是体验过后还是震撼的，票终归是要补的，只是没想到是这样补的😄 20231128204853 1174180_screenshots_20231123214800_1","tags":[]},{"title":"原码、反码、补码、移码、浮点数","date":"2023-09-14T05:02:23.000Z","path":"2023/09995a41cb.html","text":"原码、反码、补码、移码、浮点数 基本概念及表示范围定义 真值：对于无符号数，真值即对应其十进制数值，对于有符号数，首位为符号位首位为1表示负，首位为0表示正，剩余位为对应十进制绝对值 原码：符号位加上真值的绝对值。即用第一位表示符号 其余位表示值。比如如果是8位二进制: +1 = 1000_0001 反码：正数的反码是其本身，负数的反码是在其原码的基础上符号位不变，其余各个位取反。 补码：正数的补码就是其本身，负数的补码是在其反码的基础上+1 移码：真值+偏置值，n位二进制数偏置值为$2^n - 1$,其简单计算方法为补码符号位取反，数值位不变 浮点数$V = (-1)^S * M * R^E$,如8.345 * 10^0： S：符号位，取值 0 或 1，决定一个数字的符号，0 表示正，1 表示负 M：尾数，用小数表示，例如前面所看到的 8.345 * 10^0，8.345 就是尾数 R：基数，表示十进制数 R 就是 10，表示二进制数 R 就是 2 E：指数，用整数表示，例如前面看到的 10^-1，-1 即是指数 例如32位二进制浮点数及可表示为下列格式： 20230914131854 IEEE754标准 单精度浮点数 float：32 位，符号位 S 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit 双精度浮点数 float：64 位，符号位 S 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit 为了使其表示的数字范围、精度最大化，浮点数标准还对指数和尾数进行了规定： 尾数 M 的第一位总是 1（因为 1 &lt;= M &lt; 2），因此这个 1 可以省略不写，它是个隐藏位，这样单精度 23 位尾数可以表示了 24 位有效数字，双精度 52 位尾数可以表示 53 位有效数字 指数 E 是个无符号整数，表示 float 时，一共占 8 bit，所以它的取值范围为 0 ~ 255。但因为指数可以是负的，所以规定在存入 E 时在它原本的值加上一个中间数 127，这样 E 的取值范围为 -127 ~ 128。表示 double 时，一共占 11 bit，存入 E 时加上中间数 1023，这样取值范围为 -1023 ~ 1024。 除了规定尾数和指数位，还做了以下规定： 指数 E 非全 0 且非全 1：规格化数字，按上面的规则正常计算 指数 E 全 0，尾数非 0：非规格化数，尾数隐藏位不再是 1，而是 0(M = 0.xxxxx)，这样可以表示 0 和很小的数 指数 E 全 1，尾数全 0：正无穷大/负无穷大（正负取决于 S 符号位） 指数 E 全 1，尾数非 0：NaN(Not a Number) 20230914132505 有了这个统一的浮点数标准，我们再把 25.125 转换为标准的 float 浮点数： 整数部分：25(D) = 11001(B) 小数部分：0.125(D) = 0.001(B) 用二进制科学计数法表示：25.125(D) = 11001.001(B) = 1.1001001 * 2^4(B) 所以 S = 0，尾数 M = 1.001001 = 001001(去掉1，隐藏位)，指数 E = 4 + 127(中间数) = 135(D) = 10000111(B)。填充到 32 bit 中，如下： 20230914132537 相互转换以及运算二进制十进制转换 整数转二进制 采用”除2取余，逆序排列”法： 首先用2整除一个十进制整数，得到一个商和余数 然后再用2去除得到的商，又会得到一个商和余数 重复操作，一直到商为小于1时为止 然后将得到的所有余数全部排列起来，再将它反过来（逆序排列），切记一定要反过来！ 假设我们现在需要将42转为二进制，那我们怎么做呢，如下图所示： 小数转二进制 采用”乘2取整，顺序排列”法： 用2乘十进制小数，可以得到积，将积的整数部分取出 再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出 重复操作，直到积中的小数部分为零，此时0或1为二进制的最后一位，或者达到所要求的精度为止 例如将0.125转换为二进制： 0.125 * 2 = 0.25 ——0 0.25 * 2 = 0.5 ——0 0.5 * 2 = 1.0 ——1 当小数部分为0就可以停止乘2了，然后正序排序就构成了二进制的小数部分：0.001 如果小数的整数部分有大于0的整数时，将整数部分和小数部分先单独转为二进制，再合在一起就可以了， 例如：假设要将8.125 转换为二进制 现将8转为二进制：得到1000 再将0.125转为二进制：得到0.001 合并后为1000.001 二进制转十进制 以小数点左边一位为0，往左位阶依次是$2^1,2^2…$，往右是$2^{-1}, 2^{-2}…$,依次相乘并加和即可 原码、反码、补码、移码相互转换 原码 反码 补码 移码 正整数 本身，符号位为0 与原码相同 与原码相同 符号位取反 负整数 本身，符号位为1 符号位不变，数值位按位取反 反码末位加1 符号位取反 正小数 本身，符号位为0 与原码相同 与原码相同 小数无移码 负小数 本身，符号位为1 符号位不变，数值位按位取反 反码末位加1 小数无移码 表示范围设有一个n位二进制数 表示范围（机器字长为n + 1） 特征 整数原码 $-（2^n -1）\\le x \\le 2^n - 1$ 0的表示方法有两种,原点对称 小数原码 $-(1 - 2^{-n}) \\le x \\le 1 - 2^{-n}$ 0的表示方法有两种,原点对称 整数反码 $-（2^n -1）\\le x \\le 2^n - 1$ 0的表示方法有两种,原点对称 小数反码 $-(1 - 2^{-n}) \\le x \\le 1 - 2^{-n}$ 0的表示方法有两种,原点对称 整数补码 $- 2^n \\le x \\le 2^n - 1$ 真值0只有一种形式，并规定1000，0000表示$x = -2^7$ 小数补码 $-1 \\le x \\le 1 - 2^{-n}$ 真值0只有一种格式，规定1.000，0000表示x = -1 整数移码 $- 2^n \\le x \\le 2^n - 1$ 移码只能用于表示整数，0同样只有一种表示形式，很容易对比大小，移码表示数依次真值递增 在现代计算机中，通常用定点补码表示整数 ，用定点原码表示小数 ，用移码表示浮点数的阶码 加减运算原码加减： 原码加减比较麻烦，一般采用补码进行运算 补码加减： 直接相加并进位 减法等同于加上负数， 由$[x]{补}$ 求$[-x]{补}$，将所有位取反，末尾加一 乘法运算 原码：符号位和数值位单独运算 补码：待补充 除法运算待补充 符号扩展 正数（原、反、补码都一样）最高位进行扩展 负数 原码：在符号位和数值位之间补0 反码：在符号位和数值位之间补1 补码：在符号位和数值位之间补1 正小数（原、反、补码都一样）末尾进行0扩展 负小数 原码：末尾补0 反码：末位补1 补码：末位补0 定点数移位运算算术移位 原码：符号位不参与移位，左移右移都补0 反码：符号位不参与移位，左移右移都补1 补码：符号位不参与移位，左移补0，右移补1 逻辑移位可看作对无符号数的移位 循环移位循环补位，注意进位位","tags":[]},{"title":"Git常用指令","date":"2023-04-07T09:43:00.000Z","path":"2023/044b8db958.html","text":"Git常用指令 创建仓库 git clone &lt;url&gt; [directory] git init git config –global user.name ‘你的用户名’ git config –global user.email ‘你的邮箱’ git remote add origin &lt;远程仓库&gt; git add git add .:添加所有 git add &lt;文件名&gt;：添加指定文件 git commit -m “message” git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 基本指令 git config：配置信息 git remote -v：查看当前关联的远程主机地址 git remote rm origin：删除远程地址 git add：添加文件到缓存命令 git status：查看文件的状态命令 git diff：尚未缓存的改动 git diff –cached：查看已缓存的改动 git diff HEAD：查看已缓存的与未缓存的所有改动 git diff –stat：显示摘要而非整个 git diff：查看更新的详细信息命令 git commit：提交命令 git commit -m “第一次版本提交” git commit -am “第一次版本提交” git reset HEAD：取消缓存命令 git reset HEAD test.txt git rm：删除命令 git mv：移动或重命名命令 分支 git branch：查看分支命令 git branch (branchname)：创建分支命令 git checkout (branchname)：切换分支命令 git merge：合并分支命令 git branch -d (branchname)：删除分支命令 标签 可以使用 git tag -a vx.x来创建一个标签。a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解 git tag：查看标签 log git log：查看记录 –oneline ：查看历史记录的简洁版本 –graph ：查看历史中什么时候出现了分支、合并 –reverse ：逆向显示所有日志 –author ：查找指定用户的提交日志 –since、–before、 –until、–after： 指定帅选日期 –no-merges ：选项以隐藏合并提交 查看提交版本，如果想要回退到指定版本只需使用git checkout 版本ID即可，版本ID在git log之后会显示每个版本的ID 20230419192806","tags":[{"name":"Git","slug":"Git","permalink":"https://nefelibata.icu/tags/Git/"}]},{"title":"C++数组的机理","date":"2023-04-07T06:52:16.000Z","path":"2023/0445fbc665.html","text":"C++中数组真的存在吗 🤔？ 深入理解C++二维数组 提问：定义一个3 * 3的数组arr，值分别为1~9，问arr[0][5]的值为多少？ 首先定义一个二维数组，然后获取其地址： int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { std::cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"] = \" &lt;&lt; arr[i][j] &lt;&lt; \", address = \" &lt;&lt; &amp;arr[i][j] &lt;&lt; std::endl; } } 20230407150212 通过打印地址发现每个元素地址之间差4，也就是一个int的长度(一般情况下int型变量为4个字节)，而且地址也是连续的，说明申请了一个二维数组，然后申请了一段连续的地址空间来存放这些数据。 然后我们打印一下arr、arr[0]、arr[0][0]的地址： std::cout &lt;&lt; \"Address of arr: \" &lt;&lt; &amp;arr &lt;&lt; std::endl; std::cout &lt;&lt; \"Address of arr[0]: \" &lt;&lt; &amp;arr[0] &lt;&lt; std::endl; std::cout &lt;&lt; \"Address of arr[0][0]: \" &lt;&lt; &amp;arr[0][0] &lt;&lt; std::endl; 20230407150901 可以看出，三者地址是一样的，这说明三者都指向数组起始地址，变量名arr也就是数组的起始地址，那么arr是什么数据类型呢？ 打印一下arr、arr + 1、 arr + 2、arr[0]、arr[1]、arr[2]的地址: // 打印arr的地址 std::cout &lt;&lt; \"Address of arr: \" &lt;&lt; arr &lt;&lt; std::endl; // 打印arr + 1的地址 std::cout &lt;&lt; \"Address of arr + 1: \" &lt;&lt; arr + 1 &lt;&lt; std::endl; // 打印arr + 2的地址 std::cout &lt;&lt; \"Address of arr + 2: \" &lt;&lt; arr + 2 &lt;&lt; std::endl; // 打印arr[0]的地址 std::cout &lt;&lt; \"Address of arr[0]: \" &lt;&lt; arr[0] &lt;&lt; std::endl; // 打印arr[1]的地址 std::cout &lt;&lt; \"Address of arr[1]: \" &lt;&lt; arr[1] &lt;&lt; std::endl; // 打印arr[2]的地址 std::cout &lt;&lt; \"Address of arr[2]: \" &lt;&lt; arr[2] &lt;&lt; std::endl; 20230407151423 显而易见，arr + n 等价于 arr[n],arr[n]是指针类型，那么arr就是比arr[n]多一维的维指针 再来看一下arr[0][0]、arr[1][0]、arr[2][0]的地址和值（前面已经打印出来）： // 打印arr[0][0]、arr[1][0]、arr[2][0]的地址和值 std::cout &lt;&lt; \"Address of arr[0][0]: \" &lt;&lt; &amp;arr[0][0] &lt;&lt; \", value = \" &lt;&lt; arr[0][0] &lt;&lt; std::endl; std::cout &lt;&lt; \"Address of arr[1][0]: \" &lt;&lt; &amp;arr[1][0] &lt;&lt; \", value = \" &lt;&lt; arr[1][0] &lt;&lt; std::endl; std::cout &lt;&lt; \"Address of arr[2][0]: \" &lt;&lt; &amp;arr[2][0] &lt;&lt; \", value = \" &lt;&lt; arr[2][0] &lt;&lt; std::endl; 20230407152029 可以看到和上述arr[n]地址一样，表示的每一行第一列的值，显而易见arr[n]指向的就是每行首元素的地址，也就是一维指针，那么arr就是二维指针，来验证一下： int *p = a; // 不通过 实验发现报错，继续看 int* p = *arr; std::cout &lt;&lt; \"Address of p: \" &lt;&lt; p &lt;&lt; \", Address of arr: \" &lt;&lt; arr &lt;&lt; std::endl; 20230407152833 std::cout &lt;&lt; \"the value of p is: \" &lt;&lt; p &lt;&lt; std::endl; std::cout &lt;&lt; \"the value of *p is: \" &lt;&lt; *p &lt;&lt; std::endl; std::cout &lt;&lt; \"the value of p+1 is: \" &lt;&lt; p+1 &lt;&lt; std::endl; std::cout &lt;&lt; \"the value of *(p+1) is: \" &lt;&lt; *(p+1) &lt;&lt; std::endl; std::cout &lt;&lt; \"a[1][1] inferred from p : \" &lt;&lt; *(p+1*3+1) &lt;&lt; std::endl; 20230407153004 对a解引用后确实是一个地址，所以可以定义指针，并且可以用加偏移量的方式得到a[1][1] 对于二维数组arr[i][j],a[m][n]表示其中的一个值: arr[m][n] == *(*(arr + m) + n) == *(*arr + m * i + j) 总的来说数组的本质还是由指针封装起来的数据类型，所以从根本上来说可以从地址上解决，遇到一些奇奇怪怪的问题也可以由地址来解决，比如本文的问题： 20230407154547 另外，数组可以越界，这是C++所决定的，想要不越界只能人为的去限制","tags":[{"name":"C++","slug":"C","permalink":"https://nefelibata.icu/tags/C/"}]},{"title":"SVM","date":"2023-03-06T07:59:48.000Z","path":"2023/03753780000.html","text":"支持向量机是什么呢🤔？ 【数之道】支持向量机SVM是什么 概念 间隔Margin 支持向量（Support Vector）：只是指临界向量吗 正超平面、决策超平面、负超平面 损失因子：异常值 软间隔（Soft Margin）：考虑异常值的间隔 硬间隔（Hard Margin）：不考虑异常值的间隔 20230306164100 KKT条件： 20230306163819 对偶性： 升维转换对于在低纬度下无法轻松区分的数据可以增加维度进行区分，如下图（图源B站FunInCode，侵删）： 20230306164014 因此可以考虑合适的方法进行升维转换： 采用合适的升维函数在高纬度下求解SVM模型，找到对应的高维决策超平面，预测数据时先对数据进行升维，再根据高维决策边界超平面进行判断，但是这种方法需要确定的升维函数，以及更多的数据存储和计算需求 但是一般这种方法耗费很大，因此就要用到核技巧了 核技巧(Kernel Trick)核技巧可以使SVM在低维就可以进行高维的区别对比 20230306170123 高斯核函数（RBF，Radial Basis Kernel） 20230306170437 取$\\lambda$ 为$\\frac{1}{2}$ ,高斯核函数可以转化为自然对数的形式，对其进行泰勒展开，即可通过控制参数获得从0维到无穷维的表达式 20230306170928","tags":[{"name":"SVM","slug":"SVM","permalink":"https://nefelibata.icu/tags/SVM/"}]},{"title":"排序","date":"2022-10-15T03:08:40.000Z","path":"2022/10a444b428.html","text":"排序 20221015114004 冒泡排序（Bubble Sort）（稳定排序）（超出时间限制）比较相邻元素，如果第一个比第二个大，则交换。 时间复杂度$n^2$，空间复杂度1 代码： class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // bubbleSort int n = nums.size(); for (int i = 0; i &lt; n - 1; ++i) { bool flag = false; for (int j = 0; j &lt; n - 1 - i; ++j) { if (nums[j] &gt; nums[j + 1]) { swap(nums[j], nums[j + 1]); flag = true; } } if (flag == false) break; //无交换，代表当前序列已经最优 } return nums; } }; 选择排序（Select Sort）（非稳定排序）（超出时间限制）依次给每个位置选择当前位置及以后最小的元素（交换当前元素与之后最小元素的位置）。 不稳定举例：排序前：5, 5*, 1, 7排序后：1, 5*, 5, 7 时间复杂度$n^2$，空间复杂度1 代码： class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // selectSort 选择排序 int minIndex; int n = nums.size(); for (int i = 0; i &lt; n - 1; ++i) { minIndex = i; for (int j = i + 1; j &lt; n; ++j) { if (nums[j] &lt; nums[minIndex]) { minIndex = j; } } swap(nums[i], nums[minIndex]); } return nums; } }; 插入排序（Insect Sort）（稳定排序）（超出时间限制）在前 1~i - 1元素有序的情况下，（依次）将第 i 个元素插入前面已经有序的小序列，使其有序。使用哨兵减少比较 时间复杂度$n^2$，空间复杂度1 代码： class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int i, j; for (i = 2; i &lt;= nums.size(); i++) { if (nums[i] &lt; nums[i - 1]) { nums[0] = nums[i]; //nums[0]为哨兵 for (j = i - 1; nums[0] &lt; nums[j]; j--) { nums[j + 1] =nums[j]; } nums[j + 1] = nums[0]; } } return nums; } }; 插入排序在此基础上也可以将搜索和移动分开，使用二分查找先找到要插入位置，然后再移动 class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int i, j, low, high, mid; for (i = 2; i &lt;= nums.size(); i++) { nums[0] = nums[i]; low = 1; high = i - 1; while (low &lt;= high) { mid = (low + high) / 2; if (nums[mid] &gt; nums[0]) high = mid - 1; else low = mid + 1; } for (j = i - 1; j &gt; high + 1; j--) nums[j + 1] = nums[j]; nums[high + 1] = nums[0]; } return nums; } }; 希尔排序（Shell Sort）（非稳定排序）改进的插入排序（优化：原数组的一个元素距离正确位置很远的情况）先让间隔 h 的元素有序，在使得间隔为 h / 2，一直缩小，一直到 h = 1（此时数组有序）。 时间复杂度介于nlogn和$n^2$之间，空间复杂度1 代码： class Solution { void shellSort(vector&lt;int&gt;&amp;nums, int gap, int i) { int j, tmp = nums[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; tmp &lt; nums[j]; j -= gap) { // 依次后移 nums[j + gap] = nums[j]; } nums[j + gap] = tmp; } public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); // 分组，最开始时，间隔 gap 为数组的一半 for (int gap = n / 2; gap &gt;= 1 ; gap /= 2) { // 对各个分组进行插入分组 for (int i = gap; i &lt; n; ++i) { shellSort(nums, gap, i); } } return nums; } }; 归并排序（Merge Sort）（稳定排序）将无序数组拆分，排序后再合并成大的有序数组。 时间复杂度nlogn，空间复杂度n 代码： class Solution { vector&lt;int&gt; tmp; void merge (vector&lt;int&gt;&amp; nums, int low, int mid, int high) { for (int k = low; k &lt;= high; k++) { tmp[k] = nums[k]; } int i, j; for (i = low, j = mid + 1, k = i; i &lt;= mid &amp;&amp; j &lt;=high; k++) { if (tmp[i] &lt;= tmp[j]) { nums[k] = tmp[i++]; } else { nums[k] = tmp[j++]; } } while (i &lt;= mid) nums[k++] = tmp[i++]; while (j &lt;= high) nums[k++] = tmp[j++]; } public: vector&lt;int&gt; mergeSort(vector&lt;int&gt;&amp; nums, int low, int high) { if (low &lt; high) { int mid = (low + high) / 2; mergeSort(nums, low, mid + 1); mergeSort(nums, mid + 1, high); merge(nums, low, mid, high); } } }; 快速排序（Quick Sort）（非稳定排序）随机选取一个数（x = rand() % len + startIndex）作为基准；把比基准小的数交换到前面，比基准大的数交换到后面；对左右区间递归重复。 时间复杂度nlogn，空间复杂度logn 代码： class Solution { void quickSort(vector&lt;int&gt;&amp;nums, int startIndex, int endIndex) { if (startIndex &gt;= endIndex) return; int x = rand() % (endIndex - startIndex + 1) + startIndex; // 基于随机的原则 swap(nums[startIndex], nums[x]); int firstNum = nums[startIndex]; int l = startIndex, r = endIndex; while (l &lt; r) { // 从后往前走，将比第一个小的移到前面 while (l &lt; r &amp;&amp; nums[r] &gt;= firstNum) --r; if (l &lt; r) { nums[l] = nums[r]; } // 从前往后走，将比第一个大的移到后面 while (l &lt; r &amp;&amp; nums[l] &lt;= firstNum) ++l; if (l &lt; r) { nums[r] = nums[l]; } } nums[l] = firstNum; // 自顶向下 quickSort(nums, startIndex, l - 1); quickSort(nums, l + 1, endIndex); } public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); quickSort(nums, 0, n - 1); return nums; } }; 堆排序（Heap Sort）（非稳定排序）先在原先数组的基础上构造大根堆（时间复杂度nlogn）；再依次弹出最大元素（每次弹出的时间复杂度为logk，k为当前大根堆中元素数目）。 时间复杂度nlogn，空间复杂度1 代码： class Solution { void buildMaxHeap(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = (n - 1) / 2; i &gt;= 0; --i) { maxHeapify(nums, i, n); } } void maxHeapify(vector&lt;int&gt;&amp; nums, int i, int n) { while (i * 2 + 1 &lt; n) { // 代表当前 i 节点的左右儿子； // 超出数组大小则代表当前 i 节点为叶子节点，不需要移位 int lSon = 2 * i + 1; int rSon = 2 * i + 2; int large = i; if (lSon &lt; n &amp;&amp; nums[lSon] &gt; nums[i]) large = lSon; if (rSon &lt; n &amp;&amp; nums[rSon] &gt; nums[large]) large = rSon; if (large != i) { swap(nums[i], nums[large]); // 迭代判断对应子节点及其儿子节点的大小关系 i = large; } else { break; } } } public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // heapSort 堆排序 int n = nums.size(); // 将数组整理成大根堆 buildMaxHeap(nums); for (int i = n - 1; i &gt;= 1; --i) { // 依次弹出最大元素，放到数组最后，当前排序对应数组大小 - 1 swap(nums[0], nums[i]); --n; maxHeapify(nums, 0, n); } return nums; } }; 计数排序（Count Sort）（稳定排序）创建数组 counts，用于统计原数组 nums 中各元素值的出现次数；再依次将元素值赋值到 nums 中对应位置。 计数排序，时间复杂度n + k，空间复杂度k（k = maxNum - minNum + 1） 代码： class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // CountSort 计数排序 int n = nums.size(); int minNum = INT_MAX, maxNum = INT_MIN; // 找到数组中的最小和最大元素 for (int i = 0; i &lt; n; ++i) { if (nums[i] &lt; minNum) minNum = nums[i]; if (nums[i] &gt; maxNum) maxNum = nums[i]; } // 构造计数数组 vector&lt;int&gt; counts(maxNum - minNum + 1, 0); for (int i = 0; i &lt; n; ++i) { ++counts[nums[i] - minNum]; } // 计数排序 int index = 0; for (int i = 0; i &lt; counts.size(); ++i) { while (counts[i] != 0) { nums[index++] = i + minNum; counts[i]--; } } return nums; } }; 桶排序（Bucket Sort）（稳定排序）将原数组的元素分到有限数量的桶里（大编号桶里的所有元素均大于小编号桶里的任意元素）；分别对每个桶进行排序；依次合并。 时间复杂度n + k，空间复杂度n + k（k为桶的数量） 代码： class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // BucketSort 桶排序 int n = nums.size(); // 获取数组的最小值和最大值 int maxNum = nums[0], minNum = nums[0]; for (int i = 1; i &lt; n; ++i) { if (nums[i] &gt; maxNum) maxNum = nums[i]; if (nums[i] &lt; minNum) minNum = nums[i]; } // 初始化桶 int bucketNum = 5, bucketSize = (maxNum - minNum) / bucketNum + 1; vector&lt;vector&lt;int&gt;&gt; buckets(bucketNum, vector&lt;int&gt;(0)); // 小至大分桶 for (int num : nums) { int bucketIndex = (num - minNum) / bucketSize; buckets[bucketIndex].emplace_back(num); } // 桶内排序 for (int i = 0; i &lt; buckets.size(); ++i) { sort(buckets[i].begin(), buckets[i].end()); } // 从桶中依次取数 int index = 0; for (auto&amp; bucket : buckets) { for (int num : bucket) { nums[index++] = num; } } return nums; } }; 基数排序（Radix Sort）（稳定排序）对数组中所有数依次按由低到高的位数进行多次排序；每次排序都基于上次排序的结果。（相对位置顺序保持不变） 例：原始数组 1，23，21，11，32第一次排序后 1，21，11，32，23第二次排序后 1，11，21，23，32时间复杂度n x k，空间复杂度k（k为最大元素的位数） 代码： class Solution { vector&lt;int&gt; counts; void radixSort(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; tmp, int divisor) { int n = nums.size(); counts = vector&lt;int&gt;(10, 0); // 统计个、十、百、千、万上对应 0 ~ 9 的出现次数 for (int i = 0; i &lt; n; ++i) { int x = (nums[i] / divisor) % 10; ++counts[x]; } // 前缀和 for (int i = 1; i &lt;= 9; ++i) { counts[i] += counts[i - 1]; } // 从后向前赋值 for (int i = n - 1; i &gt;= 0; --i) { int x = (nums[i] / divisor) % 10; int index = counts[x] - 1; tmp[index] = nums[i]; --counts[x]; } } public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // RadixSort 基数排序 int n = nums.size(); // 预处理，让所有的数都大于等于0 for (int i = 0; i &lt; n; ++i) { nums[i] += 50000; // 50000为最小可能的数组大小 } // 找出最大的数字，并获得其最大位数 int maxNum = nums[0]; for (int i = 0; i &lt; n; ++i) { if (nums[i] &gt; maxNum) { maxNum = nums[i]; } } int num = maxNum, maxLen = 0; while (num) { ++maxLen; num /= 10; } // 基数排序，低位优先 int divisor = 1; vector&lt;int&gt; tmp(n, 0); for (int i = 0; i &lt; maxLen; ++i) { radixSort(nums, tmp, divisor); swap(tmp, nums); divisor *= 10; } // 减去预处理量 for (int i = 0; i &lt; n; ++i) { nums[i] -= 50000; } return nums; } };","tags":[]},{"title":"中缀表达式转后缀表达式","date":"2022-10-08T06:36:51.000Z","path":"2022/1072a96e3d.html","text":"中缀表达式转后缀表达式 后缀表达式后缀表达式也叫逆波兰表达式 ，其表达式表述严谨，没有括号，并严格遵循“从左到右”的后缀表达式表示方法 后缀表达式求值后缀表达式求值过程用到栈做辅助存储，假设给定后缀表达式字符串s为6523+8*+3+*,借用栈来存储数字，顺序读取，遇到数字则入栈，遇到表达符c则依次从栈中取出a和b，计算bca，并将其值入栈，最后栈中的值即为最终结果，下面演示求值过程： 读取6，入栈，栈中为6 读取5，入栈，栈中为6、5 读取2，入栈，栈中为6、5、2 读取3，入栈，栈中为6、5、2、3 读取+，从栈中依次取出3、2，计算2+3，将结果5入栈，栈中为6、5、5 读取8，入栈，栈中为6、5、5、8 读取*，从栈中依次取出8、5,计算5*8，将结果40入栈，栈中为6、5、40 读取+，从栈中依次取出40、5，计算40+5，将结果45入栈，栈中为6、45 读取3，入栈，栈中为6、45、3 读取+，从栈中依次取出3、45，计算45+3，将结果48入栈，栈中为6、48 读取*，从栈中依次取出48、6，计算6*48，将结果288入栈，栈中为288 读取到行末提示符，运算结束，结果即为栈中元素288 中缀表达式转后缀表达式简便方法以中缀表达式a+b*c+(d*e+f)*g为例，转换为后缀表达式： 对每一次运算（只要出现加减乘除符号）及其运算数加括号，为((a+(b*c))+(((d*e)+f)*g)) 将运算符移到括号后面，为((a(bc)*)+(((de)*f)+g)*)+ 去掉括号，为abc*+de*f+g*+ 一般方法待补充","tags":[]},{"title":"背包理论基础多重背包","date":"2022-08-10T05:42:04.000Z","path":"2022/0871e46bfb.html","text":"背包理论基础完全背包 转载自代码随想录，侵删 建议按照如下顺序观看：背包理论基础01背包1背包理论基础01背包2背包基础理论完全背包背包基础理论多重背包（本文） 这次我们再来说一说多重背包 多重背包对于多重背包，我在力扣上还没发现对应的题目，所以这里就做一下简单介绍，大家大概了解一下。 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。 多重背包和01背包是非常像的， 为什么和01背包像呢？ 每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。 例如： 背包最大重量为10。 物品为： 重量 价值 数量 物品0 1 15 2 物品1 3 20 3 物品2 4 30 2 问背包能背的物品最大价值是多少？ 和如下情况有区别么？ 重量 价值 数量 物品0 1 15 1 物品0 1 15 1 物品1 3 20 1 物品1 3 20 1 物品1 3 20 1 物品2 4 30 1 物品2 4 30 1 毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。 这种方式来实现多重背包的代码如下： void test_multi_pack() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; vector&lt;int&gt; nums = {2, 3, 2}; int bagWeight = 10; for (int i = 0; i &lt; nums.size(); i++) { while (nums[i] &gt; 1) { // nums[i]保留到1，把其他物品都展开 weight.push_back(weight[i]); value.push_back(value[i]); nums[i]--; } } vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } for (int j = 0; j &lt;= bagWeight; j++) { cout &lt;&lt; dp[j] &lt;&lt; \" \"; } cout &lt;&lt; endl; } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl; } int main() { test_multi_pack(); } 时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量 也有另一种实现方式，就是把每种商品遍历的个数放在01背包里面在遍历一遍。 代码如下：（详看注释） void test_multi_pack() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; vector&lt;int&gt; nums = {2, 3, 2}; int bagWeight = 10; vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 // 以上为01背包，然后加一个遍历个数 for (int k = 1; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= 0; k++) { // 遍历个数 dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]); } } // 打印一下dp数组 for (int j = 0; j &lt;= bagWeight; j++) { cout &lt;&lt; dp[j] &lt;&lt; \" \"; } cout &lt;&lt; endl; } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl; } int main() { test_multi_pack(); } 时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量 从代码里可以看出是01背包里面在加一个for循环遍历一个每种商品的数量。 和01背包还是如出一辙的。 当然还有那种二进制优化的方法，其实就是把每种物品的数量，打包成一个个独立的包。 和以上在循环遍历上有所不同，因为是分拆为各个包最后可以组成一个完整背包，具体原理我就不做过多解释了，大家了解一下就行，面试的话基本不会考完这个深度了，感兴趣可以自己深入研究一波。 总结多重背包在面试中基本不会出现，力扣上也没有对应的题目，大家对多重背包的掌握程度知道它是一种01背包，并能在01背包的基础上写出对应代码就可以了。 至于背包九讲里面还有混合背包，二维费用背包，分组背包等等这些，大家感兴趣可以自己去学习学习，这里也不做介绍了，面试也不会考。 背包理论基础01背包1背包理论基础01背包2背包基础理论完全背包背包基础理论多重背包（本文）","tags":[{"name":"背包","slug":"背包","permalink":"https://nefelibata.icu/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"背包理论基础完全背包","date":"2022-08-10T05:22:02.000Z","path":"2022/08806f2082.html","text":"背包理论基础多重背包 转载自代码随想录，侵删 建议按照如下顺序观看：背包理论基础01背包1背包理论基础01背包2背包基础理论完全背包（本文）背包基础理论多重背包 完全背包有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。 同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。 在下面的讲解中，我依然举这个例子： 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 每件商品都有无限个！ 问背包能背的物品最大价值是多少？ 01背包和完全背包唯一不同就是体现在遍历顺序上，所以本文就不去做动规五部曲了，我们直接针对遍历顺序经行分析！ 关于01背包我如下两篇已经进行深入分析了： 动态规划：关于01背包问题，你该了解这些！ 动态规划：关于01背包问题，你该了解这些！（滚动数组） 首先在回顾一下01背包的核心代码 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } 我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。 而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即： // 先遍历物品，再遍历背包 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight ; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } 至于为什么，我在动态规划：关于01背包问题，你该了解这些！（滚动数组）中也做了讲解。 dp状态图如下： 动态规划-完全背包 相信很多同学看网上的文章，关于完全背包介绍基本就到为止了。 其实还有一个很重要的问题，为什么遍历物品在外层循环，遍历背包容量在内层循环？ 这个问题很多题解关于这里都是轻描淡写就略过了，大家都默认 遍历物品在外层，遍历背包容量在内层，好像本应该如此一样，那么为什么呢？ 难道就不能遍历背包容量在外层，遍历物品在内层？ 看过这两篇的话： 动态规划：关于01背包问题，你该了解这些！ 动态规划：关于01背包问题，你该了解这些！（滚动数组） 就知道了，01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。 在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！ 因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。 遍历物品在外层循环，遍历背包容量在内层循环，状态如图： 动态规划-完全背包1 遍历背包容量在外层循环，遍历物品在内层循环，状态如图： 动态规划-完全背包2 看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。 先遍历背包在遍历物品，代码如下： // 先遍历背包，再遍历物品 for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } cout &lt;&lt; endl; } C++测试代码完整的C++测试代码如下： // 先遍历物品，在遍历背包 void test_CompletePack() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; int bagWeight = 4; vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl; } int main() { test_CompletePack(); } // 先遍历背包，再遍历物品 void test_CompletePack() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; int bagWeight = 4; vector&lt;int&gt; dp(bagWeight + 1, 0); for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl; } int main() { test_CompletePack(); } 总结细心的同学可能发现，全文我说的都是对于纯完全背包问题，其for循环的先后循环是可以颠倒的！ 但如果题目稍稍有点变化，就会体现在遍历顺序上。 如果问装满背包有几种方式的话？ 那么两个for循环的先后顺序就有很大区别了，而leetcode上的题目都是这种稍有变化的类型。 这个区别，我将在后面讲解具体leetcode题目中给大家介绍，因为这块如果不结合具题目，单纯的介绍原理估计很多同学会越看越懵！ 别急，下一篇就是了！哈哈 最后，又可以出一道面试题了，就是纯完全背包，要求先用二维dp数组实现，然后再用一维dp数组实现，最后在问，两个for循环的先后是否可以颠倒？为什么？这个简单的完全背包问题，估计就可以难住不少候选人了。 背包理论基础01背包1背包理论基础01背包2背包基础理论完全背包（本文）背包基础理论多重背包","tags":[{"name":"背包","slug":"背包","permalink":"https://nefelibata.icu/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"背包理论基础01背包2","date":"2022-08-10T05:21:14.000Z","path":"2022/08517e3a8f.html","text":"背包理论基础02 转载自代码随想录，侵删 建议按照如下顺序观看：背包理论基础01背包1背包理论基础01背包2（本文）背包基础理论完全背包背包基础理论多重背包 昨天背包理论基础01背包1中是用二维dp数组来讲解01背包。 今天我们就来说一说滚动数组，其实在前面的题目中我们已经用到过滚动数组了，就是把二维dp降为一维dp，一些录友当时还表示比较困惑。 那么我们通过01背包，来彻底讲一讲滚动数组！ 接下来还是用如下这个例子来进行讲解 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 问背包能背的物品最大价值是多少？ 一维dp数组（滚动数组）对于背包问题其实状态都是可以压缩的。 在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]); 与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。 这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。 读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。 dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 一定要时刻记住这里i和j的含义，要不然很容易看懵了。 动规五部曲分析如下： 确定dp数组的定义 在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 一维dp数组的递推公式 dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？ dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。 dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]） 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值， 所以递归公式为： dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。 一维dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。 那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？ 看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。 这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。 那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。 一维dp数组遍历顺序 代码如下： for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } 这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！ 二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。 为什么呢？ 倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！ 举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15 如果正序遍历 dp[1] = dp[1 - weight[0]] + value[0] = 15 dp[2] = dp[2 - weight[0]] + value[0] = 30 此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。 为什么倒序遍历，就可以保证物品只放入一次呢？ 倒序就是先算dp[2] dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0） dp[1] = dp[1 - weight[0]] + value[0] = 15 所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。 那么问题又来了，为什么二维dp数组历的时候不用倒序呢？ 因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！ （如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！） 再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？ 不可以！ 因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。 倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。 （这里如果读不懂，就在回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！） 所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！，这一点大家一定要注意。 举例推导dp数组 一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下： 动态规划-背包问题9 一维dp01背包完整C++测试代码void test_1_wei_bag_problem() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; int bagWeight = 4; // 初始化 vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl; } int main() { test_1_wei_bag_problem(); } 可以看出，一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了。 所以我倾向于使用一维dp数组的写法，比较直观简洁，而且空间复杂度还降了一个数量级！ 在后面背包问题的讲解中，我都直接使用一维dp数组来进行推导。 总结以上的讲解可以开发一道面试题目（毕竟力扣上没原题）。 就是本文中的题目，要求先实现一个纯二维的01背包，如果写出来了，然后再问为什么两个for循环的嵌套顺序这么写？反过来写行不行？再讲一讲初始化的逻辑。 然后要求实现一个一维数组的01背包，最后再问，一维数组的01背包，两个for循环的顺序反过来写行不行？为什么？ 注意以上问题都是在候选人把代码写出来的情况下才问的。 就是纯01背包的题目，都不用考01背包应用类的题目就可以看出候选人对算法的理解程度了。 相信大家读完这篇文章，应该对以上问题都有了答案！ 此时01背包理论基础就讲完了，我用了两篇文章把01背包的dp数组定义、递推公式、初始化、遍历顺序从二维数组到一维数组统统深度剖析了一遍，没有放过任何难点。 大家可以发现其实信息量还是挺大的。 如果把背包理论基础01背包1和本篇的内容都理解了，后面我们在做01背包的题目，就会发现非常简单了。 不用再凭感觉或者记忆去写背包，而是有自己的思考，了解其本质，代码的方方面面都在自己的掌控之中。 即使代码没有通过，也会有自己的逻辑去debug，这样就思维清晰了。 背包理论基础01背包1背包理论基础01背包2（本文）背包基础理论完全背包背包基础理论多重背包","tags":[{"name":"背包","slug":"背包","permalink":"https://nefelibata.icu/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"背包理论基础01背包1","date":"2022-08-10T05:21:02.000Z","path":"2022/08c8776b35.html","text":"背包理论基础01 转载自代码随想录，侵删 建议按照如下顺序观看：背包理论基础01背包1（本文）背包理论基础01背包2背包基础理论完全背包背包基础理论多重背包 这周我们正式开始讲解背包问题！ 如果这几种背包，分不清，我这里画了一个图，如下： 416.分割等和子集1 至于背包九讲其其他背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。 而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。 所以背包问题的理论基础重中之重是01背包，一定要理解透！ leetcode上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要转化为01背包问题。 所以我先通过纯01背包问题，把01背包原理讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为01背包问题了。 之前可能有些录友已经可以熟练写出背包了，但只要把这个文章仔细看完，相信你会意外收获！ 01 背包有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 动态规划-背包问题 这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。 这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？ 每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。 所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！ 在下面的讲解中，我举一个例子： 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 问背包能背的物品最大价值是多少？ 以下讲解和图示中出现的数字都是以这个例子为例。 二维dp数组01背包依然动规五部曲分析一波。 确定dp数组以及下标的含义 对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 只看这个二维数组的定义，大家一定会有点懵，看下面这个图： 动态规划-背包问题1 要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。 确定递推公式 再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 那么可以有两个方向推出来dp[i][j]， 不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。) 放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。 首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图： 动态规划-背包问题2 在看其他情况。 状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。 dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。 那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。 当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。 代码初始化如下： for (int j = 0 ; j &lt; weight[0]; j++) { // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。 dp[0][j] = 0; } // 正序遍历 for (int j = weight[0]; j &lt;= bagweight; j++) { dp[0][j] = value[0]; } 此时dp数组初始化情况如图所示： 动态规划-背包问题7 dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？ 其实从递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。 初始-1，初始-2，初始100，都可以！ 但只不过一开始就统一把dp数组统一初始为0，更方便一些。 如图： 动态规划-背包问题10 最后初始化代码如下： // 初始化 dp vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0)); for (int j = weight[0]; j &lt;= bagweight; j++) { dp[0][j] = value[0]; } 费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的。 确定遍历顺序 在如下图中，可以看出，有两个遍历的维度：物品与背包重量 动态规划-背包问题3 那么问题来了，先遍历 物品还是先遍历背包重量呢？ 其实都可以！！ 但是先遍历物品更好理解。 那么我先给出先遍历物品，然后遍历背包重量的代码。 // weight数组的大小 就是物品个数 for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } 先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组） 例如这样： // weight数组的大小 就是物品个数 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } 为什么也是可以的呢？ 要理解递归的本质和递推的方向。 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的。 dp[i-1][j]和dp[i - 1][j - weight[i]] 都在dp[i][j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示： 动态规划-背包问题5 再来看看先遍历背包，再遍历物品呢，如图： 动态规划-背包问题6 大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！ 但先遍历物品再遍历背包这个顺序更好理解。 其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了。 举例推导dp数组 来看一下对应的dp数组的数值，如图： 动态规划-背包问题4 最终结果就是dp[2][4]。 建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。 做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！ 很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。 主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了。 完整c++测试代码void test_2_wei_bag_problem1() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; int bagweight = 4; // 二维数组 vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0)); // 初始化 for (int j = weight[0]; j &lt;= bagweight; j++) { dp[0][j] = value[0]; } // weight数组的大小 就是物品个数 for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } cout &lt;&lt; dp[weight.size() - 1][bagweight] &lt;&lt; endl; } int main() { test_2_wei_bag_problem1(); } 总结讲了这么多才刚刚把二维dp的01背包讲完，这里大家其实可以发现最简单的是推导公式了，推导公式估计看一遍就记下来了，但难就难在如何初始化和遍历顺序上。 可能有的同学并没有注意到初始化 和 遍历顺序的重要性，我们后面做力扣上背包面试题目的时候，大家就会感受出来了。 下一篇 还是理论基础，我们再来讲一维dp数组实现的01背包（滚动数组），分析一下和二维有什么区别，在初始化和遍历顺序上又有什么差异，敬请期待！ 背包理论基础01背包1（本文）背包理论基础01背包2背包基础理论完全背包背包基础理论多重背包","tags":[{"name":"背包","slug":"背包","permalink":"https://nefelibata.icu/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"LeetCode笔记-动态规划","date":"2022-08-06T09:41:48.000Z","path":"2022/0826e7783f.html","text":"动规 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的 动规的五部曲 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 如果代码写出来了，一直AC不了，灵魂三问： 这道题目我举例推导状态转移公式了么？ 我打印dp数组的日志了么？ 打印出来了dp数组和我想的一样么？ 首先要明白dp数组的含义是什么，下表代表什么，确定了这个之后按照套路走就行，手动推导dp数组本质上也是一种检验的过程，当打印出结果符合预期手动推导结果时，基本就没太大问题 2022.8.9动态规划的习题我认为最重要的就是要确定dp数组的定义，下标代表什么，该如何初始化，举个例子： LeetCode304：整数拆分 给定一个正整数&nbsp;n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例&nbsp;2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 ×&nbsp;3 ×&nbsp;4 = 36。 说明: 你可以假设&nbsp;n&nbsp;不小于 2 且不大于 58。 这道题在我的做法中dp数组表示的是i这个数字的最大拆分乘积，初始化dp[2] = 1,这是易知的，而在一些题解中就把dp[0]和dp[1]也进行了初始化，这么做当然也可以AC，但是dp数组的意义已经模糊了，暂不谈题目限制`$$2 \\le n \\ge 58$$,就按照题目说明，0和1就不能拆分为两个正整数的和，更不用谈乘积，虽然这么初始化问题也不大，但是我感觉要透过题去理解，要明白dp数组的含义，下标表示了什么更为重要，下面是本题C++代码： class Solution { public: int integerBreak(int n) { vector&lt;int&gt; dp(n + 1); dp[2] = 1; for (int i = 3; i &lt;= n ; i++) { for (int j = 1; j &lt; i - 1; j++) { dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)); } } return dp[n]; } }; 时间复杂度：O(n^2) 空间复杂度：O(n) 背包问题2022.08.10 转载自代码随想录，侵删 建议按照如下顺序观看：背包理论基础01背包1背包理论基础01背包2背包基础理论完全背包背包基础理论多重背包 01背包和完全背包2022.08.13 背包问题大概描述是：有一个承重m的背包，旁边有一堆物品共n个，每个物品重量不一，价值不易，weight[i]和value[i]分别代表第i个物品的重量和价值，求背包最多能装下物品的价值 01背包是说每个物品只有一个，怎么装价值最大完全背包是说每种物品有无限多个，怎么装价值最大，比如一辆卡车去进货，每种货占的空间不同，价值也不同，但是每种货数量是不限制的，怎么装，一卡车货价值最大 01背包-二维-先物品后背包采用二维数组遍历必然要考虑遍历顺序，是先遍历背包，还是先遍历物品，不妨设先遍历物品，那么循环内层遍历的就是背包了 当对于num[i]，无非两种情况: 背包可以装的下，继续装那么价值就是dp[i - 1][j - weight[i]] + value[i],表示未装num[i]物品前，背包最大容量必然是j - weight[i]（因为还要装第i件物品，所以预留出weight[i]的空间，剩下的空间可以装的最大值就是dp[i - 1][j - weight[i]]） 装不下，背包里面物品价值还是不变，就是dp[i - 1][j] 那么二者取最大值，就是i件物品容量为j的背包可以装的物品最大价值，依次递推即可 for (int i = 0; i &lt; num[i]; i++) { for (int j = weight[i]; j &lt;= target; j++) { //j从weight[i]开始，是因为小于weight[i]的背包根本装不下第i件物品，所以一定都是dp[i - 1][j] dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } 01背包-二维-先背包后物品转变一下遍历顺序二维时是完全可以的，观察上述递归公式可以发现，dp[i][j]完全是由上一行的值和weight数组和value数组决定的，而后面两个是已知的，所以不管按照什么顺序遍历，dp[i][j]仅由其左上位置数值决定，所以遍历顺序怎么样都可以，下面给出先遍历背包，后遍历物品的代码： for (int j = 0; j &lt;= target; j++) { for (int i = 1; i &lt; nums.size(); i++) { if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; //装不下 else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); //装得下 } } 01背包-一维前面也已经说明过了，dp[i][j]只依赖上一行的数值，所以我们可以将dp数组降为一维，节约空间，但是要注意，二维的时候我们依赖的是上一行（i - 1行）的值，降为一维后，当不做任何变化时，当前数值就是上一行数值，但是如果j还是从前往后遍历，那么当为j时，从0 ~ （j - 1）的数值已经变为新值了，不再是上一行的值，所以不能从前往后遍历，而当我们从后往前遍历则是可以的，原因也很简单，前面说过，dp[i][j]只依赖左上方的值，当降为一维数组之后，就是只依赖左方的值，而我们从后往前遍历，左方的值一直都未变化，当然是可以的，代码如下： for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } 顺序在这里也很重要，一定要是先物品后背包容量，反之则不行 观察二维时候的递推公式 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); dp[i][j]依赖的是上一行，不是上一列，是j - weight[i]列，所以滚动数组完全不可行 完全背包完全背包相比01背包就是物品可以用无数次，仅仅在01背包的基础上略微修改即可，从前往后遍历即可 上文知道，01背包从后往前遍历是为了保证每个物品仅仅使用一次，而完全背包可以用无数次，从前往后即可，代码如下： // 先遍历物品，再遍历背包 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight ; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } // 先遍历背包，再遍历物品 for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } cout &lt;&lt; endl; } 至于遍历顺序，则同01背包 关于排列和组合完全背包往往会涉及到排列和组合的问题 就比如这个组合总数Ⅳ,求数字总和为target 这道题目要求数字顺序不一样也是一种组合，其本质上就是排列问题，那么使用循环遍历时就需要注意遍历顺序了 先物品后背包肯定是行不通的，因为物品只能按顺序出现，比如说{1， 3}，不可能出现{3，1}，因为物品是在外侧循环，只能按照数组顺序出现，所以说不能使用先物品后背包的方式，而要用先背包后物品才可以 一句话总结就是先物品后背包是组合 ， 先背包后物品是排列 多重背包多重背包其实跟01背包如出一辙，只是原本数量为1的物品现在数量不再一定为1了，而是由一个数量数组nums记录每件物品的数量有多少，针对多重背包，有以下两种解决方法： 把多重背包拆分为01背包，把同一种物品拆分为一个一个的，问题就简化为了01背包，按照01背包的解决方法即可 在双重遍历的时候内嵌一个for循环，遍历这个物品对应的数量即可，本质上还是把同一个物品拆分为了一个一个的 背包总结 图源代码随想录知识星球 (opens new window)成员：海螺人","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nefelibata.icu/tags/Leetcode/"}]},{"title":"LeetCode笔记-贪心算法","date":"2022-07-25T12:03:50.000Z","path":"2022/072a2449dc.html","text":"贪心的 本质是选择每一阶段的局部最优，从而达到全局最优 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 思路贪心的题目没有固定套路，但都遵循着一个思想：局部最优从而达到全局最优 简单的问题直接遵循这个思想解决即可，稍微麻烦一点的可能会涉及到两个维度最优，且两个维度相互有联系，相互牵制，就比如下面这道题，首先要根据题目确定一个合适的维度保持最优，然后调整另一个维度。 eg 406.根据身高重建队列 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [$h_i$, $k_i$] 表示第 i 个人的身高为 $h_i$ ，前面 正好 有 $k_i$ 个身高大于或等于 $h_i$ 的人。 请你重新构造并返回输入数组&nbsp;people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例 1： 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 解释： 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 示例 2： 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示： 1 &lt;= people.length &lt;= 2000 0 &lt;= $h_i$ &lt;= 10^6 0 &lt;= $k_i$ &lt; people.length 题目数据确保队列可以被重建 本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。 如果两个维度一起考虑一定会顾此失彼。 对于本题究竟先按h排序呢，还先按照k排序呢？ 如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。 那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。 此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！ 那么只需要按照k为下标重新插入队列即可。 局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性 全局最优：最后都做完插入操作，整个队列满足题目队列属性 本题整个插入过程如下： 排序完的people：[[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]] 插入的过程： 插入[7,0]：[[7,0]] 插入[7,1]：[[7,0],[7,1]] 插入[6,1]：[[7,0],[6,1],[7,1]] 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]] 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]] 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 此时就按照题目的要求完成了重新排列。 class Solution { public: static bool cmp (vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) { if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &gt; b[0]; } vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) { sort(people.begin(), people.end(), cmp); vector&lt;vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; people.size(); i++) { res.insert(res.begin() + people[i][1], people[i]); } return res; } }; 时间复杂度：$O(nlog n + n^2)$ 空间复杂度：O(n) 2022/8/6有一类区间最优问题非常适合贪心，比如下面几题： 用最少数量的箭引爆气球 无重叠区间 划分字母区间 合并区间 这类区间问题有一个套路就是可以先对区间排序，至于是根据左边界排序还是右边界没有太大影响，个人习惯左边界排序，之后通过控制右边界即可轻松解决问题，上文也提到不要一起考虑，不然容易顾此失彼。 根据左边界排序之后，所有的区间左边界必定是递增的（当然不是严格递增，存在相等的情况），而右边界无非三种情况，相对于我们选定的右边界来说，大于，小于，等于，此时只需要根据题目要求针对三种情况处理即可，这样就可以保证处理位置之前的区间都是最优的，也就是局部最优，待遍历到末尾之后，前面都是局部最优解，最终也就是全局最优，总之还是贪心没有固定套路，最多只能是几类问题有相似之处而已，从问题中找到局部最优解，然后扩展到全局即可。 最后附上贪心的知识图（图源知识星球：海螺人）： 20220806181804","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nefelibata.icu/tags/Leetcode/"}]},{"title":"VSCode+PicGo+Aliyun配置MarkDown图床","date":"2022-07-25T09:04:42.000Z","path":"2022/07b93436c8.html","text":"VSCode+PicGo+Aliyun配置MarkDown图床 VSCode作为一款非常轻便的编辑器，以轻量，插件丰富收到大家欢迎，我个人是非常喜欢使用VSCode的，用VSCode去编辑Markdown文件也十分方便，当然Typora在这方便也很受欢迎，但是Typora正式版上线之后要收费，不可避免地会损失一部分用户，接下来我就介绍一下使用VSCode来进行编辑Markdown文件时图传的配置方法 前置要求:安装VSCode即可 插件只需安装一个Markdown All in One即可使用VSCode编辑Markdown文件，非常方便 20220725171244 但是这个插件不提供图床功能，仍需要将图片转换成网络链接复制到md文件中，非常不方便 接下来继续安装一个PicGo插件即可 Aliyun对象存储OSS PicGo默认存储为SMMS，我也一直在用这个，但是今天突然就打不开了，Github也可以，但是其服务器在国外，国内使用经常会显示不了图片，所以综合一下选择了Aliyun，而且新用户免费体验三个月，作为图床仓库，40G存储量一年的价格为5元，也可以说是非常划算了，接下来讲一下详细配置。 打开阿里云官网，登陆或注册，在产品里面找到对象存储OSS 根据需要直接购买，作为图床使用40G空间已经足够了，选项默认的即可，直接购买即可 购买之后直接进入OSS管理控制台 在Bucket列表中新建一个Bucket，地域选择离自己最近的，复制下这个地域名称英文，待会要用读写权限选择公共读其他选择默认配置即可。 创建成功之后进入创建的Bucket，进入概述界面，下方的访问域名中有一个外网访问，记录后面的Bucket域名，待会要使用 然后点击头像的AccessKey管理创建一个AccessKey记录AccessKey ID和AccessKey Secret即可 配置VSCode PicGo配置打开VSCode设置，搜索PicGo,首先找到Pic Bed：current，将其更换为aliyun 20220725173825 然后找到aliyun的配置，进行如下配置： 20220725174406 到此为止图床就已经全部配置完成了 快捷键PicGo默认上传快捷键如下： 20220725174617 我们可以直接按下Ctrl+Alt+U直接从剪贴板复制图片，非常好用，当然也可以更改为自己更加方便的快捷键。","tags":[{"name":"工具","slug":"工具","permalink":"https://nefelibata.icu/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"如何利用网易云盘同步歌曲歌词","date":"2022-07-25T07:47:47.000Z","path":"2022/07Infinity.html","text":"利用网易云的云盘功能实现Listen 1的效果 起源：版权限制一个音乐软件很难拥有所有我们想要的歌曲来源，周杰伦的就只有咪咕有版权，如此一来，就要在各个软件之间切换，很不方便而利用网盘可以很好解决这一问题，以网易云举例 音频文件下载这个不难，直接面向百度,搜索下载即可 歌词文件解决了音频文件问题之后，很容易遇到的就是网盘收藏歌曲只有音频文件，没有歌词，而由于是本地文件，我们也无法从网络获取歌词，就像下面这样 20220725164205 在网易云云盘中上传歌曲时会自动识别是否有歌词文件，比如这样，我们将歌词文件（lrc文件）和歌曲文件放在同一个文件夹下，注意：这两个文件除了后缀，文件名要完全相同，然后转网易云网盘上传文件即可，如下图所示： 20220725164620 然后，我们就可以拥有带歌词的网盘文件了，像这样： 20220725164738 制作lrc歌词文件面向百度一般的歌词文件都是lrc格式的，我们用记事本打开文件 20220725164849 可以看到基本的歌曲信息，至于歌词就是下面的格式 [时间]歌词 这些歌词信息直接面向百度很轻易就可以获取 获取之后直接新建一个lrc文件，将歌词内容复制进去保存之后，上传到网易云即可 LRC Maker当然网络歌词文件并不一定和我们的音频文件匹配，同源的当然更好，不是同源的也没关系，推荐一个在线歌词编辑器LRC Maker 20220725165518 介绍很详细，我们首先添加音频文件 20220725165646 在上方的编辑界面可以直接编辑歌词，编辑完成之后，点击右上方第二个打轴选项，可以试听，并且对歌词进行微调 20220725165841 点击下方播放之后歌词会随着我们编辑的时间和音频文件进行滚动，并且上方也有时间定位，如果歌词时间有点误差（过快或过慢）都可以暂停进行微调 微调之后再次进入编辑界面导出lrc文件即可，注意音频文件一定要和歌词文件同名 这样我们就可以不用频繁的去切换软件了，甚是方便。","tags":[{"name":"工具","slug":"工具","permalink":"https://nefelibata.icu/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"LeetCode笔记-回溯","date":"2022-07-02T07:43:02.000Z","path":"2022/079716a2d4.html","text":"回溯 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 回溯法回溯法也可以叫做回溯搜索法，它是一种搜索的方式。 回溯是递归的副产品，只要有递归就会有回溯。 本质上回溯就是穷举，穷举所有可能，然后找到答案，效率上并不高，如果想让回溯法高效一些，可以加一些剪枝(回溯可以归结为对于树的节点的操作，要遍历所有节点，当遍历到一个节点时，已经不符合设定条件，那么他的子树也必定不符合我们的预设条件，他的子节点就没有必要遍历了，这也在一定程度上减少了运算量)的操作，但即便这样也改不了回溯法就是穷举的本质。 回溯法解决的问题回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 另外，关于组合和排列： 组合是不强调元素顺序的，排列是强调元素顺序 例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。 如何理解回溯法回溯法解决的问题都可以抽象为树形结构 因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。 回溯法三部曲 回溯函数模板返回值以及参数 回溯算法中函数返回值一般为void 参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。 回溯函数伪代码如下： void backtracking(参数) 回溯函数终止条件 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。 所以回溯函数终止条件伪代码如下： if (终止条件) { 存放结果; return; } 回溯搜索的遍历过程 上面提到，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。 如图： 回溯算法理论基础 注意图中，特意举例集合大小和孩子的数量是相等的！ 回溯函数遍历过程伪代码如下： for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。 backtracking这里自己调用自己，实现递归。 从图中看出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。 分析完过程，回溯算法模板框架如下： void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 剪枝前面已经说过，剪枝就是减少一些遍历的节点，因此我们只需要控制递归的终止条件即可 LeetCode题目 77. 组合 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。示例:输入:&nbsp;n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 这是未经剪枝优化的代码 class Solution { private: vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件结果的集合 vector&lt;int&gt; path; // 用来存放符合条件结果 void backtracking(int n, int k, int startIndex) { if (path.size() == k) { result.push_back(path); return; } for (int i = startIndex; i &lt;= n; i++) { path.push_back(i); // 处理节点 backtracking(n, k, i + 1); // 递归 path.pop_back(); // 回溯，撤销处理的节点 } } public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { result.clear(); // 可以不写 path.clear(); // 可以不写 backtracking(n, k, 1); return result; } }; 容易知道当按顺序遍历到3为第一个数字时，已经没必要遍历下去了，因为4是最后一个数字，不能凑出两个数字的组合，但是由于判定条件，4依旧会被进行计算，这样就增加了计算量 for (int i = startIndex; i &lt;= n; i++) { path.push_back(i); backtracking(n, k, i + 1); path.pop_back(); } 这样减少的计算量或许没多少，换个例子，当n = 4，k = 4时，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。 本来四层for循环要经历3 + 2 + 1 + 1 = 7次计算，但是对for循环条件加以优化之后就变为了1次计算，效率大大提升，当然这个例子有点夸张，但是举这个例子目的就是说明确实可以提高效率。 这么说有点抽象，如图所示： 77.组合4 图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。 所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。 如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。 注意代码中i，就是for循环里选择的起始位置。 for (int i = startIndex; i &lt;= n; i++) { 接下来看一下优化过程如下： 已经选择的元素个数：path.size(); 还需要的元素个数为: k - path.size(); 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历,为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。 举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。 从2开始搜索都是合理的，可以是组合[2, 3, 4]。 所以优化之后的for循环是： for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置 优化后整体代码如下： class Solution { private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(int n, int k, int startIndex) { if (path.size() == k) { result.push_back(path); return; } for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) { // 优化的地方 path.push_back(i); // 处理节点 backtracking(n, k, i + 1); path.pop_back(); // 回溯，撤销处理的节点 } } public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { backtracking(n, k, 1); return result; } };","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nefelibata.icu/tags/Leetcode/"}]},{"title":"LeetCode笔记-二叉树","date":"2022-06-17T11:07:45.000Z","path":"2022/0621aed2ac.html","text":"二叉树 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 树的基本知识 节点：包含一个数据元素及若干指向子树分支的信息 节点的度：一个节点拥有子树的数目称为节点的度 叶子节点：也称为终端节点，没有子树的节点或者度为零的节点 分支节点：也称为非终端节点，度不为零的节点称为非终端节点 树的度：树中所有节点的度的最大值 节点的层次：从根节点开始，假设根节点为第1层，根节点的子节点为第2层，依此类推，如果某一个节点位于第L层，则其子节点位于第L+1层 树的深度：也称为树的高度，树中所有节点的层次最大值称为树的深度 有序树：如果树中各棵子树的次序是有先后次序，则称该树为有序树 无序树：如果树中各棵子树的次序没有先后次序，则称该树为无序树 森林：由m（m≥0）棵互不相交的树构成一片森林。如果把一棵非空的树的根节点删除，则该树就变成了一片森林，森林中的树由原来根节点的各棵子树构成 树的基本性质 二叉树的第i层上至多有$2^(i-1)（i≥1）$个节点 深度为h的二叉树中至多含有$2^h - 1$个节点 若在任意一棵二叉树中，有$n_0$个叶子节点，有$n_2$个度为2的节点，则必有$n_0 = n_2 + 1$ 具有n个节点的满二叉树深为$log_2 (n + 1)$ 若对一棵有n个节点的完全二叉树进行顺序编号（1≤i≤n），那么，对于编号为i（i≥1）的节点： 当i=1时，该节点为根，它无双亲节点 当i&gt;1时，该节点的双亲节点的编号为$\\frac{i}{2}$ 若2i≤n，则有编号为2i的左节点，否则没有左节点 若2i+1≤n，则有编号为2i+1的右节点，否则没有右节点 二叉树二叉树的种类二叉树有两种主要的形式：满二叉树和完全二叉树。 满二叉树满二叉树： 如果一棵二叉树只有度 (简单理解为孩子节点个数)为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 如图所示： 这棵二叉树为满二叉树，也可以说深度 (就是有几层)为k，有$2^k - 1$个节点的二叉树，比如本图，4层，那么4层的满二叉树就有$2^4 - 1 = 15$个节点 完全二叉树 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 $1~&nbsp;2^(h-1)$ &nbsp;个节点。 优先级队列其实是一个堆，而堆就是一棵完全二叉树，同时保证父子节点的顺序关系。 二叉搜索树二叉搜索树是有数值的树，二叉搜索树是一个有序树，它有一下几条性质： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值 它的左、右子树也分别为二叉排序树 eg： 平衡二叉搜索树 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and&nbsp;Landis）树，且具有以下性质： 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。(递归定义) 如图： 最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是$log n$，而unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。 二叉树的存储方式 二叉树可以链式存储，也可以顺序存储 链式存储用指针， 顺序存储用数组。 顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。 链式存储如图： 顺序存储呢其实就是用数组来存储二叉树，顺序存储的方式如图： 用数组来存储二叉树如何遍历的呢？ 如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 但是用链式表示的二叉树，更有利于理解，所以一般都是用链式存储二叉树。 所以大家要了解，用数组依然可以表示二叉树。 二叉树的遍历方式二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历(层级遍历)：一层一层的去遍历。 这两种遍历是图论中最基本的两种遍历方式那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式： 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 这里前中后，其实指的就是中间节点的遍历顺序，只要记住 前中后序指的就是中间节点的位置就可以了。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。 而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 二叉树的代码实现C++代码如下： struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。 递归和迭代 在讲二叉树的遍历方式前，首先要搞明白递归和遍历的区别 递归（recursion）： 递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在函数定义中使用函数自身的方法。（A调用A） 迭代（iteration）： 重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B） 递归是一个树结构，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。 迭代是一个环结构，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。 理论上递归和迭代时间复杂度方面是一样的，但实际应用中（函数调用和函数调用堆栈的开销）递归比迭代效率要低。 20220620201425 二叉树的递归遍历(递归非常重要！！！) 一看就会，一写就废！ 首先要知道递归算法的三个要素： 确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件：写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 以下以前序遍历为例： 确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数里需要传入vector在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下： void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) 确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下： if (cur == NULL) return; 确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下： vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 单层递归的逻辑就是按照中左右的顺序来处理的，代码如下： class Solution { public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; } }; 中序和后序代码如下： 中序遍历： void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // 左 vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;right, vec); // 右 } 后序遍历： void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 vec.push_back(cur-&gt;val); // 中 } 二叉树的迭代遍历 听说还可以用非递归的方式 递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。 前序遍历（迭代法）前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。 为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。 动画如下： 二叉树前序遍历（迭代法） 不难写出如下代码: （注意代码中空节点不入栈） class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); // 右（空节点不入栈） if (node-&gt;left) st.push(node-&gt;left); // 左（空节点不入栈） } return result; } }; 中序遍历（迭代法） 注意：中序遍历不能像递归那样微调前序遍历的代码 在迭代的过程中，有两个操作： 处理：将元素放进result数组中 访问：遍历节点 分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。 那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。 那么在使用迭代法写中序遍历，我们就可以添加一个栈用来存放左孩子节点，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。 动画如下： 二叉树中序遍历（迭代法） 中序遍历，可以写出如下代码： class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-&gt;left; // 左 } else { cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-&gt;val); // 中 cur = cur-&gt;right; // 右 } } return result; } }; 后序遍历（迭代法） 数组部分更改前后顺序，要考虑向更改局部，然后整体反转这种思路能不能行的通 再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图： 前序到后序 所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下： class Solution { public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); result.push_back(node-&gt;val); if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈 } reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; } }; 二叉树的统一迭代法中序遍历代码如下：（详细注释）class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node != NULL) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node-&gt;right) st.push(node-&gt;right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node-&gt;left) st.push(node-&gt;left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.top(); // 重新取出栈中元素 st.pop(); result.push_back(node-&gt;val); // 加入到结果集 } } return result; } }; 同理，前序和后续只需要微调一下加入栈的顺序就可以了，我们利用根节点先把所有节点按照我们需要的遍历方法存储到栈里面，然后把需要特定顺序遍历的节点用NULL节点标记，即可实现迭代的统一写法。 迭代法前序遍历class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node != NULL) { st.pop(); if (node-&gt;right) st.push(node-&gt;right); // 右 if (node-&gt;left) st.push(node-&gt;left); // 左 st.push(node); // 中 st.push(NULL); } else { st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); } } return result; } }; 迭代法后序遍历class Solution { public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node != NULL) { st.pop(); st.push(node); // 中 st.push(NULL); if (node-&gt;right) st.push(node-&gt;right); // 右 if (node-&gt;left) st.push(node-&gt;left); // 左 } else { st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); } } return result; } }; 二叉树的层序遍历层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。 需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; tmp; for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); tmp.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(tmp); } return result; } };","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nefelibata.icu/tags/Leetcode/"}]},{"title":"C++中STL常用库函数","date":"2022-06-17T09:40:03.000Z","path":"2022/06b47eaf04.html","text":"C++中STL常用函数简单总结 sort()快排函数原型：sort(起始地址, 末尾地址, cmp),其中cmp是可以自己定义的函数名,默认递增排列 cmp函数示例: bool cmp(int &amp;a, int &amp;b){ return a &gt; b; } reverse()逆置函数原型：reverse(起始地址, 末尾地址) stoi()函数原型:stoi(string类型)将string类型转换为int类型 unique()去重函数原型：unique(起始地址, 末尾地址, fun);其中fun为自定义的函数名。 注意：unique函数去重并不是真正的去重，它是不断的将后面不重复的元素覆盖前面重复的元素，最后返回最后一个不重复的元素的地址。 二分查找函数lower_bound(起始地址, 末尾地址, target)：查找第一个大于等于target目标值的位置 upper_bound(起始地址, 末尾地址, target)：查找第一个大于target目标值的位置 binary_search(起始地址, 末尾地址, target)：查找target是否存在于数组或vector中，找到返回true，否则返回false 字符串查找函数s1.find(s2)：在s1字符串中查找s2，查找到返回第一个字符的位置，查找失败返回s1.npos set.count(a)：本来是计算a出现的次数，但是由于集合中是没有重复元素的，于是count函数也就被作为查找函数了，因为a只能出现1次或者0次，查找成功，返回1；查找失败返回0. map.find()：主要用于查找key是否存在map中，不存在返回map.end()，用法和set一样 vector vector, 变长数组，倍增的思想 函数 功能 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() 访问第一个元素/最后一个元素 push_back()/pop_back() 插入/弹出最后一个元素 begin()/end() 开始元素迭代器/结尾元素迭代器 pair&lt;int, int&gt; 函数 功能 first 第一个元素 second 第二个元素 string，字符串 函数 功能 size()/length() 返回字符串长度 empty() 返回是否为空 clear() 清空 substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 函数 功能 size() 返回队列长度 empty() 返回是否为空 push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue 优先队列，默认是大根堆 函数 功能 size() 返回队列长度 empty() 返回是否为空 push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式： priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; stack, 栈 函数 功能 size() 返回栈长度 empty() 返回是否为空 push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 函数 功能 size() 返回队列长度 empty() 返回是否为空 clear() 清空队列 front()/back() 返回队头元素 push_back()/pop_back() 插入/弹出最后一个元素 push_front()/pop_front() 插入/弹出第一个元素 begin()/end() 开始元素迭代器/结尾元素迭代器","tags":[{"name":"C++","slug":"C","permalink":"https://nefelibata.icu/tags/C/"}]},{"title":"LeetCode笔记-栈和队列","date":"2022-06-16T06:37:39.000Z","path":"2022/0638ccdfc.html","text":"栈和队列 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 栈和队列不为人知的一面 栈是先进后出，队列是先进先出： 20220616145417 基础知识栈先进后出，提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。 所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。 那么问题来了，STL 中栈是用什么容器实现的？ 从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。 常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。 deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。 SGI STL中 队列底层实现缺省情况下一样使用deque实现的。 也可以指定vector为栈的底层实现，初始化语句如下： std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 使用vector为底层容器的栈 对应的队列的情况是一样的。 队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。 也可以指定list 为起底层实现，初始化queue的语句如下： std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列 所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。 用栈模拟实现队列class MyQueue { public: stack&lt;int&gt; stIn; stack&lt;int&gt; stOut; /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { stIn.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据） if (stOut.empty()) { // 从stIn导入数据直到stIn为空 while(!stIn.empty()) { stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } /** Get the front element. */ int peek() { int res = this-&gt;pop(); // 直接使用已有的pop函数 stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去 return res; } /** Returns whether the queue is empty. */ bool empty() { return stIn.empty() &amp;&amp; stOut.empty(); } }; 用队列模拟实现栈class MyStack { public: queue&lt;int&gt; que1; queue&lt;int&gt; que2; MyStack() { } void push(int x) { que1.push(x); } int pop() { if (!this-&gt;empty()) { while (que1.size() &gt; 1) { que2.push(que1.front()); que1.pop(); } int result = que1.front(); que1.pop(); while (!que2.empty()) { que1.push(que2.front()); que2.pop(); } return result; } return 0; } int top() { return que1.back(); } bool empty() { return que1.empty() &amp;&amp; que2.empty(); } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 有效括号问题class Solution { public: bool isValid(string s) { stack&lt;char&gt; sta; for (int i = 0; i &lt; s.size(); i++) { if (s[i] == '(') sta.push(')'); else if (s[i] == '[') sta.push(']'); else if (s[i] == '{') sta.push('}'); else if (sta.empty() || sta.top() != s[i]) return false; else sta.pop(); } return sta.empty(); } };","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nefelibata.icu/tags/Leetcode/"}]},{"title":"LeetCode笔记-双指针大法","date":"2022-06-15T10:15:41.000Z","path":"2022/06c54e8d28.html","text":"双指针 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 双指针法非常实用，但是他并不隶属于任何一种数据结构。 双指针法在数组原地反转，双重循环降低时间复杂度一般都有很好的效果。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nefelibata.icu/tags/Leetcode/"}]},{"title":"LeetCode笔记-字符串","date":"2022-06-15T10:15:24.000Z","path":"2022/063572401b.html","text":"字符串 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 什么是字符串字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定。 在C语言中，把一个字符串存入一个数组时，也把结束符 ‘\\0’存入数组，并以此作为该字符串是否结束的标志。 例如这段代码： char a[5] = \"asd\"; for (int i = 0; a[i] != '\\0'; i++) { } 在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用’\\0’来判断是否结束。 例如这段代码: string a = \"asd\"; for (int i = 0; i &lt; a.size(); i++) { } 那么vector&lt; char &gt; 和 string 又有什么区别呢？ 其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。 所以想处理字符串，我们还是会定义一个string类型。 双指针法双指针法在数组，链表和字符串中很常用。其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。 KMPKMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 KMP的精髓所在就是前缀表 前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。 那么使用KMP可以解决两类经典问题： 匹配问题：28. 实现 strStr() 重复子串问题：459.重复的子字符串 再一次强调了什么是前缀，什么是后缀，什么又是最长相等前后缀。 前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。 后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。 然后针对前缀表到底要不要减一，这其实是不同KMP实现的方式，在KMP精讲 中针对之前两个问题，分别给出了两个不同版本的的KMP实现。 其中主要理解j=next[x]这一步最为关键！","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nefelibata.icu/tags/Leetcode/"}]},{"title":"LeetCode笔记-KMP","date":"2022-06-13T13:30:27.000Z","path":"2022/06e8411ac8.html","text":"KMP算法 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 字符串操作主要考虑格式的转换。 实现strStr()LeetCode题目链接 KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 KMP精讲文字版 KMP精讲视频 摘要构造next数组 next数组的本质就是前缀后缀相同的字符位数表实现方式常见的有减一、右移和保持不变三种，但是本质都是一样的，只在细微地方有区别，本文采用减一方式，其他方式代码详见前缀表（不减一）C++实现 我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下： void getNext(int* next, const string&amp; s) 构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步： 初始化 处理前后缀不相同的情况 处理前后缀相同的情况 接下来我们详解详解一下。 初始化：定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。 然后还要对next数组进行初始化赋值，如下： int j = -1; next[0] = j; j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。 next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j） 所以初始化next[0] = j 。 处理前后缀不相同的情况因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。 所以遍历模式串s的循环下标i 要从 1开始，代码如下： for (int i = 1; i &lt; s.size(); i++) { 如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。 怎么回退呢？ next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。 那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。 所以，处理前后缀不相同的情况代码如下： while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } 处理前后缀相同的情况如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。 代码如下： if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; 最后整体构建next数组的函数代码如下： void getNext(int* next, const string&amp; s){ int j = -1; next[0] = j; for(int i = 1; i &lt; s.size(); i++) { // 注意i从1开始 while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] } } 代码构造next数组的逻辑流程动画如下： 得到了next数组之后，就要用这个来做匹配了。 使用next数组来做匹配在文本串s里 找是否出现过模式串t。 定义两个下标j 指向模式串起始位置，i指向文本串起始位置。 那么j初始值依然为-1，为什么呢？ 依然因为next数组里记录的起始位置为-1。 i就从0开始，遍历文本串，代码如下： for (int i = 0; i &lt; s.size(); i++) 接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。 如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。 代码如下： while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) { j = next[j]; } 如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下： if (s[i] == t[j + 1]) { j++; // i的增加在for循环里 } 如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。 本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。 代码如下： if (j == (t.size() - 1) ) { return (i - t.size() + 1); } 那么使用next数组，用模式串匹配文本串的整体代码如下： int j = -1; // 因为next数组里记录的起始位置为-1 for (int i = 0; i &lt; s.size(); i++) { // 注意i就从0开始 while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t return (i - t.size() + 1); } } 此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下： 前缀表统一减一 C++代码实现class Solution { public: void getNext(int* next, const string&amp; s) { int j = -1; next[0] = j; for(int i = 1; i &lt; s.size(); i++) { // 注意i从1开始 while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] } } int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } int next[needle.size()]; getNext(next, needle); int j = -1; // // 因为next数组里记录的起始位置为-1 for (int i = 0; i &lt; haystack.size(); i++) { // 注意i就从0开始 while(j &gt;= 0 &amp;&amp; haystack[i] != needle[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t return (i - needle.size() + 1); } } return -1; } };","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://nefelibata.icu/tags/LeetCode/"}]},{"title":"LeetCode笔记-哈希表","date":"2022-06-12T10:19:48.000Z","path":"2022/064cfc9b66.html","text":"哈希表 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 哈希表 哈希表是根据关键码的值而直接进行访问的数据结构。一般哈希表都是用来快速判断一个元素是否出现在集合里。 哈希碰撞两个元素同时映射到哈希表中同一位置，这一现象叫做哈希碰撞，如下例： 20220612173210 一般处理方法有两种，拉链法和线性探测法。 拉链法 20220612173630 其实拉链法就是要选择合适的哈希表大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间 线性探测法使用线性探测法，一定要保证tablesize大于datasize，需要依靠哈希表中的空位来解决碰撞问题。 20220612174935 常见的三种哈希结构当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。 数组 set （集合） map(映射) 在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： 20220612183010 std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 20220612183049 std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。 那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 三种数据结构的选择 数据量给定而且没有太大需求的可以直接选择数组。 数据量未知而且如果哈希值比较少、特别分散、跨度非常大，使用set，使用数组就造成空间的极大浪费 直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的，所以可以用数组的优先选择数组 map是采用了key-value的方式，一般可以用来保存一一对应的键值对","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nefelibata.icu/tags/Leetcode/"}]},{"title":"LeetCode笔记-链表","date":"2022-06-12T10:19:16.000Z","path":"2022/064d5af563.html","text":"链表 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 链表链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链接的入口节点称为链表的头结点也就是head。 20220526212803 双链表： 20220526212848 循环链表：循环链表可用来解决约瑟夫环问题 20220526212919 链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。 // 单链表 struct ListNode { int val; // 节点上存储的元素 ListNode *next; // 指向下一个节点的指针 // ListNode *prev; //指向前一个元素 双链表，记得构造函数初始化 ListNode(int x) : val(x), next(NULL) {} // 节点的构造函数 }; 性能分析 插入/删除 查询 适用场景 数组 O(n) O(1) 数据量固定，频繁查询，较少增删 链表 O(1) O(n) 数据量不固定，频繁增删，较少查询 单链表的删除操作一般有两类： 设置虚拟头，将头节点当作普通节点处理，最后在删除虚拟头 头节点和其他节点分开处理 Pyhton、Java等语言可以自动释放内存，C++记得要手动释放内存节约空间。 C++示例class MyLinkedList { public: // 定义链表节点结构体 struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点 _size = 0; } // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点 int get(int index) { if (index &gt; (_size - 1) || index &lt; 0) { return -1; } LinkedNode* cur = _dummyHead-&gt;next; while(index--){ // 如果--index 就会陷入死循环 cur = cur-&gt;next; } return cur-&gt;val; } // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点 void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-&gt;next = _dummyHead-&gt;next; _dummyHead-&gt;next = newNode; _size++; } // 在链表最后面添加一个节点 void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(cur-&gt;next != nullptr){ cur = cur-&gt;next; } cur-&gt;next = newNode; _size++; } // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。 // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点 // 如果index大于链表的长度，则返回空 void addAtIndex(int index, int val) { if (index &gt; _size) { return; } LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(index--) { cur = cur-&gt;next; } newNode-&gt;next = cur-&gt;next; cur-&gt;next = newNode; _size++; } // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的 void deleteAtIndex(int index) { if (index &gt;= _size || index &lt; 0) { return; } LinkedNode* cur = _dummyHead; while(index--) { cur = cur -&gt;next; } LinkedNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; _size--; } // 打印链表 void printLinkedList() { LinkedNode* cur = _dummyHead; while (cur-&gt;next != nullptr) { cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; \" \"; cur = cur-&gt;next; } cout &lt;&lt; endl; } private: int _size; LinkedNode* _dummyHead; }; 关于环形链表和入口问题链表是否存在环可以用双指针快速判定，fast每次移动两个节点，slow一个节点，如果相遇（即fast == slow），则必定存在环 环的入口可以这样求：在相遇位置设置tmp1，在链表头结点处设置tmp2，每次走一个节点，相遇位置即为环入口节点 理论比较简单，详细可参见链表：环找到了，那入口呢？,dalao写的非常详细","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nefelibata.icu/tags/Leetcode/"}]},{"title":"C++中string、char *、char[]、const char*的转换","date":"2022-06-02T14:49:17.000Z","path":"2022/066dcc5737.html","text":"在C++中string、const char、 char 、char[]四者类型经常会需要转化。 转化方法 char*转string：可以直接赋值。 char[]转string：可以直接赋值。 char*转char[]：不能直接赋值，可以循环char*字符串逐个字符赋值,也可以使用strcpy_s等函数。 string转char[]:不能直接赋值，可以循环char*字符串逐个字符赋值,也可以使用strcpy_s等函数 string转char*:调用string对象的c_str函数或data函数或copy函数。 char[]转char*:直接赋值即可。使用时，要对源格式和目标格式进行初始化。源格式赋值为具体的内容，目标格式赋值为空。 20220608193144 总结如下：A. 变成string,直接赋值。B. char[]变成别的，直接赋值。C. char*变const char*容易，const char*变char*麻烦。&lt;char*&gt;(const char*);D. string变char*要通过const char*中转。E. 变成char[]。string逐个赋值，char* const char* strncpy_s() C和C++中char和string区别在C语言中，string 是定义一个字符串，存储的是一段如“abcd”的数据，而且最后还有一个结束符’\\0’; char 是定义一个字符，存储一个字符，占一个字节。 在C++中，string有两种，一种是字符串char[]，另外一种是封装好的字符串类，要区别理解。例如’a’是char, “a”是char string，这两者都是普通的字符和字符串，和C语言中没什么不同值得注意的是后者包含两个字符，末尾有一个隐身的’\\0’ 而 string str = “a” 是C++ 封装好的string。C++中的char string和string不是一回事。当用到了”string”这个关键词，就不是普通的字符串，而是用到了封装后的类。在C++中，char仍然是一个primitive type（原始类型），而string已经经过封装，成为了一个class（类）用到它时，我们需要 #include ，它是C++ Standard Library （C++标准库）的一部分。 参考：c/c++中string与char的区别C++中string、char *、char[]、const char*的转换","tags":[{"name":"C++","slug":"C","permalink":"https://nefelibata.icu/tags/C/"}]},{"title":"VS Code集成终端字体修改 & 字体颜色、大小修改方法","date":"2022-06-02T08:45:00.000Z","path":"2022/068a4c5ed0.html","text":"摘要待补充 打开VScode，Ctrl + ,或者设置 -&gt; 设置搜索workbenck，如下图： ![](imageVS-Code集成终端字体修改-字体颜色、大小修改方法1654159805450.png) 点击Edit in settings.json在配置文件最后加上以下参数： //终端颜色配置 \"workbench.colorCustomizations\" : { //可以将鼠标放到下面的色号上根据自己的偏好进行选择 \"terminal.foreground\" : \"#37FF13\",//字体颜色 \"terminal.background\" : \"#2b2424\"//背景颜色 }, \"terminal.integrated.cursorBlinking\": true, \"terminal.integrated.lineHeight\": 1.2, \"terminal.integrated.letterSpacing\": 0.1, \"terminal.integrated.fontSize\": 14, //字体大小设置 \"terminal.integrated.fontFamily\": \"Lucida Console\", //字体设置 保存即可 具体颜色可根据个人喜好配置，如果想恢复默认颜色或者背景，删除该行代码即可 配置之后效果如下： ![](imageVS-Code集成终端字体修改-字体颜色、大小修改方法1654160184142.png)","tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://nefelibata.icu/tags/VSCode/"}]},{"title":"LeetCode笔记-数组","date":"2022-05-25T11:55:34.000Z","path":"2022/05fcf9ff47.html","text":"数组 本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 数组需要两点注意的是： 数组下标都是从0开始的 数组内存空间的地址是连续的 正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址，而且数组不能增删，只能覆盖。在C++中二维数组在地址空间上是连续的。但是Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。所以看不到每个元素的地址情况。 二分使用二分的前提是： 有序数组 无重复元素 使用二分时一般需要注意边界条件的处理，一般包括以下两种情况： 左闭右闭 左闭右开 二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 双指针使用双指针可以实现滑动窗口等操作，避免了循环嵌套，大大降低了时间复杂度 螺旋矩阵要注意四个方向临界条件以及区间类型都要一致","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://nefelibata.icu/tags/Leetcode/"}]},{"title":"关于Eclipse安卓开发中的文件调用","date":"2022-05-17T18:35:09.000Z","path":"2022/05442e8a7e.html","text":"Java项目读取resources资源文件路径那点事 问题描述最近在用Eclipse做Android的时候使用jxl库简单处理了xls文件，由于我对xls文件处理不太熟练，于是创建了一个Java项目进行简单测试，没问题之后直接在安卓项目使用，但是却发现即使我把xls文件放在assets文件夹下并在Build Path里面勾选了assets文件夹依旧会抛出找不到文件的错误：FileNotFoundException，采用了 file:///android_asset/xxx.html 和 /assets/xxx.xls 均没有效果，依旧会抛出错误。 问题原因一般情况下我们在本地项目引用文件，直接用绝对路径或者相对路径都可以，这两者都可以在资源文件的属性里面查看，如下图所示： image-20220518100916219 Android项目打包生成APK之后，会将项目打包成Jar包或者war包，此时就不会存在 assets/resources 目录，JVM会在编译项目时，主动将 java文件编译成 class文件 和 resources 下的静态文件放在 target/classes目录下； 也就是说我们在打包之后上述目录结构已经发生变化，此时再用原来的路径去索引文件，必然是索引不到的，那么我们还想去索引这个文件怎么办呢？ 解决方案我们可以用Java提供的方法获取文件流 InputStream input = this.getClass().getResourceAsStream(\"/assets/xxx.xls\"); 从而去使用文件。 需要注意的是，路径的开头的 / 是不能少的，它代表的就是从src目录-根目录，而资源文件路径就是从src开始找，这样工程打包以后同样可以找到路径。 参考：Java项目读取resources资源文件路径那点事","tags":[{"name":"Java","slug":"Java","permalink":"https://nefelibata.icu/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://nefelibata.icu/tags/Android/"}]}]