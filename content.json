[{"title":"Vim操作指令及配置","date":"2023-05-14T09:01:53.000Z","path":"2023/056dad740.html","text":"本篇使用Vim编辑，个人笔记使用待使用到补充，自己用到才有体会 模式 命令模式：使用vim打开一个文件时默认模式，也叫命令模式，允许用户通过各种命令浏览代码、滚屏等操作。 插入模式：也可以叫做编辑模式，在普通模式下敲击 i 、a 或 o 就进入插入模式，允许用户通过键盘输入、编辑。 命令行模式：在普通模式下，先输入冒号:，接着输入命令，就可以通过配置命令对vim进行配置了，如改变颜色主题、显示行号等，这些配置命令也可以保存到/etc/vim/vimrc配置文件中，每次打开默认配置执行。 可视化模式：在普通模式下敲击前盘上的 v 键，就进入可视化模式，然后移动光标就可以选中一块文本，常用来完成文本的复制、粘贴、删除等操作。 替换模式：如果我们想修改某个字符，不需要先进入插入模式，删除，然后再输入新的字符，直接在普通模式下，敲击R键就可以直接替换。 EX模式：类似于命令行模式，可以一次运行多个命令 Vim的各种工作模式可以通过按键进行更换，按下Esc键均可返回默认模式，然后再更换为其他模式。 指令保存按下Ecs返回默认模式后，进行保存、保存退出、不保存退出、本次操作不进行更改等 :q 若文件没有修改，直接退出 :q! 文件已经被修改，放弃修改退出 :wq 文件已经被修改，保存修改并退出 :e! 放弃修改，重新回到文件打开时的状态","tags":[]},{"title":"Hello kpl!","date":"2023-05-06T17:10:39.353Z","path":"2023/054a17b156.html","text":"","tags":[]},{"title":"Linux指令","date":"2023-05-02T12:54:51.000Z","path":"2023/0589550d80.html","text":"转载自Engineer-Yao 一、基础知识1.1 Linux系统的文件结构/bin 二进制文件，系统常规命令 /boot 系统启动分区，系统启动时读取的文件 /dev 设备文件 /etc 大多数配置文件 /home 普通用户的家目录 /lib 32位函数库 /lib64 64位库 /media 手动临时挂载点 /mnt 手动临时挂载点 /opt 第三方软件安装位置 /proc 进程信息及硬件信息 /root 临时设备的默认挂载点 /sbin 系统管理命令 /srv 数据 /var 数据 /sys 内核相关信息 /tmp 临时文件 /usr 用户相关设定 1.2 Linux系统命令行的含义示例：root@app00:~# root //用户名，root为超级用户 @ //分隔符 app00 //主机名称 ~ //当前所在目录，默认用户目录为~，会随着目录切换而变化，例如：（root@app00:/bin# ，当前位置在bin目录下） # //表示当前用户是超级用户，普通用户为$，例如：（\"yao@app00:/root$\" ，表示使用用户\"yao\"访问/root文件夹） 1.3 命令的组成示例：命令 参数名 参数值 二、基础操作2.1 重启系统(1)立刻关机 shutdown -h now 或者 poweroff (2)两分钟后关机 shutdown -h 2 2.2 关闭系统(1)立刻重启 shutdown -r now 或者 reboot (2)两分钟后重启 shutdown -r 2 2.3 帮助命令（help）ifconfig --help //查看 ifconfig 命令的用法 2.4 命令说明书（man）man shutdown //打开命令说明后，可按\"q\"键退出 2.5 切换用户（su）su yao //切换为用户\"yao\",输入后回车需要输入该用户的密码 exit //退出当前用户 三、目录操作3.1 切换目录（cd）cd / //切换到根目录 cd /bin //切换到根目录下的bin目录 cd ../ //切换到上一级目录 或者使用命令：cd .. cd ~ //切换到home目录 cd - //切换到上次访问的目录 cd xx(文件夹名) //切换到本目录下的名为xx的文件目录，如果目录不存在报错 cd /xxx/xx/x //可以输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全 3.2 查看目录（ls）ls //查看当前目录下的所有目录和文件 ls -a //查看当前目录下的所有目录和文件（包括隐藏的文件） ls -l //列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令\"ll\"效果一样 ls /bin //查看指定目录下的所有目录和文件 3.3 创建目录（mkdir）mkdir tools //在当前目录下创建一个名为tools的目录 mkdir /bin/tools //在指定目录下创建一个名为tools的目录 3.3 删除目录与文件（rm）rm 文件名 //删除当前目录下的文件 rm -f 文件名 //删除当前目录的的文件（不询问） rm -r 文件夹名 //递归删除当前目录下此名的目录 rm -rf 文件夹名 //递归删除当前目录下此名的目录（不询问） rm -rf * //将当前目录下的所有目录和文件全部删除 rm -rf /* //将根目录下的所有文件全部删除【慎用！相当于格式化系统】 3.4 修改目录（mv）mv 当前目录名 新目录名 //修改目录名，同样适用与文件操作 mv /usr/tmp/tool /opt //将/usr/tmp目录下的tool目录剪切到 /opt目录下面 mv -r /usr/tmp/tool /opt //递归剪切目录中所有文件和文件夹 3.5 拷贝目录（cp）cp /usr/tmp/tool /opt //将/usr/tmp目录下的tool目录复制到 /opt目录下面 cp -r /usr/tmp/tool /opt //递归剪复制目录中所有文件和文件夹 3.6 搜索目录（find）find /bin -name 'a*' //查找/bin目录下的所有以a开头的文件或者目录 3.7 查看当前目录（pwd）pwd //显示当前位置路径 四、文件操作4.1 新增文件（touch）touch a.txt //在当前目录下创建名为a的txt文件（文件不存在），如果文件存在，将文件时间属性修改为当前系统时间 4.2 删除文件（rm）rm 文件名 //删除当前目录下的文件 rm -f 文件名 //删除当前目录的的文件（不询问） 4.3 编辑文件（vi、vim）vi 文件名 //打开需要编辑的文件 --进入后，操作界面有三种模式：命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode） 命令模式 -刚进入文件就是命令模式，通过方向键控制光标位置， -使用命令\"dd\"删除当前整行 -使用命令\"/字段\"进行查找 -按\"i\"在光标所在字符前开始插入 -按\"a\"在光标所在字符后开始插入 -按\"o\"在光标所在行的下面另起一新行插入 -按\"：\"进入底行模式 插入模式 -此时可以对文件内容进行编辑，左下角会显示 \"-- 插入 --\"\" -按\"ESC\"进入底行模式 底行模式 -退出编辑： :q -强制退出： :q! -保存并退出： :wq ## 操作步骤示例 ## 1.保存文件：按\"ESC\" -&gt; 输入\":\" -&gt; 输入\"wq\",回车 //保存并退出编辑 2.取消操作：按\"ESC\" -&gt; 输入\":\" -&gt; 输入\"q!\",回车 //撤销本次修改并退出编辑 ## 补充 ## vim +10 filename.txt //打开文件并跳到第10行 vim -R /etc/passwd //以只读模式打开文件 4.4 查看文件cat a.txt //查看文件最后一屏内容 less a.txt //PgUp向上翻页，PgDn向下翻页，\"q\"退出查看 more a.txt //显示百分比，回车查看下一行，空格查看下一页，\"q\"退出查看 tail -100 a.txt //查看文件的后100行，\"Ctrl+C\"退出查看 五、文件权限5.1 权限说明文件权限简介：'r' 代表可读（4），'w' 代表可写（2），'x' 代表执行权限（1），括号内代表\"8421法\" ##文件权限信息示例：-rwxrw-r-- -第一位：'-'就代表是文件，'d'代表是文件夹 -第一组三位：拥有者的权限 -第二组三位：拥有者所在的组，组员的权限 -第三组三位：代表的是其他用户的权限 5.2 文件权限普通授权 chmod +x a.txt 8421法 chmod 777 a.txt //1+2+4=7，\"7\"说明授予所有权限 六、打包与解压6.1 说明.zip、.rar //windows系统中压缩文件的扩展名 .tar //Linux中打包文件的扩展名 .gz //Linux中压缩文件的扩展名 .tar.gz //Linux中打包并压缩文件的扩展名 6.2 打包文件tar -zcvf 打包压缩后的文件名 要打包的文件 参数说明：z：调用gzip压缩命令进行压缩; c：打包文件; v：显示运行过程; f：指定文件名; 示例： tar -zcvf a.tar file1 file2,... //多个文件压缩打包 6.3 解压文件tar -zxvf a.tar //解包至当前目录 tar -zxvf a.tar -C /usr------ //指定解压的位置 unzip test.zip //解压*.zip文件 unzip -l test.zip //查看*.zip文件的内容 七、其他常用命令7.1 findfind . -name \"*.c\" //将目前目录及其子目录下所有延伸档名是 c 的文件列出来 find . -type f //将目前目录其其下子目录中所有一般文件列出 find . -ctime -20 //将目前目录及其子目录下所有最近 20 天内更新过的文件列出 find /var/log -type f -mtime +7 -ok rm {} \\; //查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们 find . -type f -perm 644 -exec ls -l {} \\; //查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件 find / -type f -size 0 -exec ls -l {} \\; //为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径 7.2 whereiswhereis ls //将和ls文件相关的文件都查找出来 7.3 which说明：which指令会在环境变量$PATH设置的目录里查找符合条件的文件。 which bash //查看指令\"bash\"的绝对路径 7.4 sudo说明：sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。需要输入自己账户密码。 使用权限：在 /etc/sudoers 中有出现的使用者 sudo -l //列出目前的权限 $ sudo -u yao vi ~www/index.html //以 yao 用户身份编辑 home 目录下www目录中的 index.html 文件 7.5 grepgrep -i \"the\" demo_file //在文件中查找字符串(不区分大小写) grep -A 3 -i \"example\" demo_text //输出成功匹配的行，以及该行之后的三行 grep -r \"ramesh\" * //在一个文件夹中递归查询包含指定字符串的文件 7.6 service说明：service命令用于运行System V init脚本，这些脚本一般位于/etc/init.d文件下，这个命令可以直接运行这个文件夹里面的脚本，而不用加上路径 service ssh status //查看服务状态 service --status-all //查看所有服务状态 service ssh restart //重启服务 7.7 free说明：这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况 free -g //以G为单位输出内存的使用量，-g为GB，-m为MB，-k为KB，-b为字节 free -t //查看所有内存的汇总 7.8 toptop //显示当前系统中占用资源最多的一些进程, shift+m 按照内存大小查看 7.9 df说明：显示文件系统的磁盘使用情况 df -h //一种易看的显示 7.10 mountmount /dev/sdb1 /u01 //挂载一个文件系统，需要先创建一个目录，然后将这个文件系统挂载到这个目录上 dev/sdb1 /u01 ext2 defaults 0 2 //添加到fstab中进行自动挂载，这样任何时候系统重启的时候，文件系统都会被加载 7.11 uname说明：uname可以显示一些重要的系统信息，例如内核名称、主机名、内核版本号、处理器类型之类的信息 uname -a 7.12 yum说明：安装插件命令 yum install httpd //使用yum安装apache yum update httpd //更新apache yum remove httpd //卸载/删除apache 7.13 rpm说明：插件安装命令 rpm -ivh httpd-2.2.3-22.0.1.el5.i386.rpm //使用rpm文件安装apache rpm -uvh httpd-2.2.3-22.0.1.el5.i386.rpm //使用rpm更新apache rpm -ev httpd //卸载/删除apache 7.14 datedate -s \"01/31/2010 23:59:53\" ///设置系统时间 7.15 wget说明：使用wget从网上下载软件、音乐、视频 示例：wget http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz //下载文件并以指定的文件名保存文件 wget -O nagios.tar.gz http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz 7.16 ftpftp IP/hostname //访问ftp服务器 mls *.html - //显示远程主机上文件列表 7.17 scpscp /opt/data.txt 192.168.1.101:/opt/ //将本地opt目录下的data文件发送到192.168.1.101服务器的opt目录下 八、系统管理8.1 防火墙操作service iptables status //查看iptables服务的状态 service iptables start //开启iptables服务 service iptables stop //停止iptables服务 service iptables restart //重启iptables服务 chkconfig iptables off //关闭iptables服务的开机自启动 chkconfig iptables on //开启iptables服务的开机自启动 ##centos7 防火墙操作 systemctl status firewalld.service //查看防火墙状态 systemctl stop firewalld.service //关闭运行的防火墙 systemctl disable firewalld.service //永久禁止防火墙服务 8.2 修改主机名（CentOS 7）hostnamectl set-hostname 主机名 8.3 查看网络ifconfig 8.4 修改IP修改网络配置文件，文件地址：/etc/sysconfig/network-scripts/ifcfg-eth0 ------------------------------------------------ 主要修改以下配置： TYPE=Ethernet //网络类型 BOOTPROTO=static //静态IP DEVICE=ens00 //网卡名 IPADDR=192.168.1.100 //设置的IP NETMASK=255.255.255.0 //子网掩码 GATEWAY=192.168.1.1 //网关 DNS1=192.168.1.1 //DNS DNS2=8.8.8.8 //备用DNS ONBOOT=yes //系统启动时启动此设置 ------------------------------------------------- 修改保存以后使用命令重启网卡：service network restart 8.5 配置映射修改文件： vi /etc/hosts 在文件最后添加映射地址，示例如下： 192.168.1.101 node1 192.168.1.102 node2 192.168.1.103 node3 配置好以后保存退出，输入命令：ping node1 ，可见实际 ping 的是 192.168.1.101。 8.6 查看进程ps -ef //查看所有正在运行的进程 8.7 结束进程kill pid //杀死该pid的进程 kill -9 pid //强制杀死该进程 8.8 查看链接ping IP //查看与此IP地址的连接情况 netstat -an //查看当前系统端口 netstat -an | grep 8080 //查看指定端口 8.9 快速清屏ctrl+l //清屏，往上翻可以查看历史操作 8.10 远程主机ssh IP //远程主机，需要输入用户名和密码","tags":[]},{"title":"Git常用指令","date":"2023-04-07T09:43:00.000Z","path":"2023/044b8db958.html","text":"创建仓库 git clone &lt;url&gt; [directory] git init git config –global user.name ‘你的用户名’ git config –global user.email ‘你的邮箱’ git remote add origin &lt;远程仓库&gt; git add git add .:添加所有 git add &lt;文件名&gt;：添加指定文件 git commit -m “message” git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 基本指令 git config：配置信息 git remote -v：查看当前关联的远程主机地址 git remote rm origin：删除远程地址 git add：添加文件到缓存命令 git status：查看文件的状态命令 git diff：尚未缓存的改动 git diff –cached：查看已缓存的改动 git diff HEAD：查看已缓存的与未缓存的所有改动 git diff –stat：显示摘要而非整个 git diff：查看更新的详细信息命令 git commit：提交命令 git commit -m “第一次版本提交” git commit -am “第一次版本提交” git reset HEAD：取消缓存命令 git reset HEAD test.txt git rm：删除命令 git mv：移动或重命名命令 分支 git branch：查看分支命令 git branch (branchname)：创建分支命令 git checkout (branchname)：切换分支命令 git merge：合并分支命令 git branch -d (branchname)：删除分支命令 标签 可以使用 git tag -a vx.x来创建一个标签。a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解 git tag：查看标签 log git log：查看记录 –oneline ：查看历史记录的简洁版本 –graph ：查看历史中什么时候出现了分支、合并 –reverse ：逆向显示所有日志 –author ：查找指定用户的提交日志 –since、–before、 –until、–after： 指定帅选日期 –no-merges ：选项以隐藏合并提交 查看提交版本，如果想要回退到指定版本只需使用git checkout 版本ID即可，版本ID在git log之后会显示每个版本的ID","tags":[]},{"title":"C++数组的机理","date":"2023-04-07T06:52:16.000Z","path":"2023/0445fbc665.html","text":"深入理解C++二维数组 提问：定义一个3 * 3的数组arr，值分别为1~9，问arr[0][5]的值为多少？ 首先定义一个二维数组，然后获取其地址： int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { std::cout &lt;&lt; \"arr[\" &lt;&lt; i &lt;&lt; \"][\" &lt;&lt; j &lt;&lt; \"] = \" &lt;&lt; arr[i][j] &lt;&lt; \", address = \" &lt;&lt; &amp;arr[i][j] &lt;&lt; std::endl; } } 通过打印地址发现每个元素地址之间差4，也就是一个int的长度(一般情况下int型变量为4个字节)，而且地址也是连续的，说明申请了一个二维数组，然后申请了一段连续的地址空间来存放这些数据。 然后我们打印一下arr、arr[0]、arr[0][0]的地址： std::cout &lt;&lt; \"Address of arr: \" &lt;&lt; &amp;arr &lt;&lt; std::endl; std::cout &lt;&lt; \"Address of arr[0]: \" &lt;&lt; &amp;arr[0] &lt;&lt; std::endl; std::cout &lt;&lt; \"Address of arr[0][0]: \" &lt;&lt; &amp;arr[0][0] &lt;&lt; std::endl; 可以看出，三者地址是一样的，这说明三者都指向数组起始地址，变量名arr也就是数组的起始地址，那么arr是什么数据类型呢？ 打印一下arr、arr + 1、 arr + 2、arr[0]、arr[1]、arr[2]的地址: // 打印arr的地址 std::cout &lt;&lt; \"Address of arr: \" &lt;&lt; arr &lt;&lt; std::endl; // 打印arr + 1的地址 std::cout &lt;&lt; \"Address of arr + 1: \" &lt;&lt; arr + 1 &lt;&lt; std::endl; // 打印arr + 2的地址 std::cout &lt;&lt; \"Address of arr + 2: \" &lt;&lt; arr + 2 &lt;&lt; std::endl; // 打印arr[0]的地址 std::cout &lt;&lt; \"Address of arr[0]: \" &lt;&lt; arr[0] &lt;&lt; std::endl; // 打印arr[1]的地址 std::cout &lt;&lt; \"Address of arr[1]: \" &lt;&lt; arr[1] &lt;&lt; std::endl; // 打印arr[2]的地址 std::cout &lt;&lt; \"Address of arr[2]: \" &lt;&lt; arr[2] &lt;&lt; std::endl; 显而易见，arr + n 等价于 arr[n],arr[n]是指针类型，那么arr就是比arr[n]多一维的维指针 再来看一下arr[0][0]、arr[1][0]、arr[2][0]的地址和值（前面已经打印出来）： // 打印arr[0][0]、arr[1][0]、arr[2][0]的地址和值 std::cout &lt;&lt; \"Address of arr[0][0]: \" &lt;&lt; &amp;arr[0][0] &lt;&lt; \", value = \" &lt;&lt; arr[0][0] &lt;&lt; std::endl; std::cout &lt;&lt; \"Address of arr[1][0]: \" &lt;&lt; &amp;arr[1][0] &lt;&lt; \", value = \" &lt;&lt; arr[1][0] &lt;&lt; std::endl; std::cout &lt;&lt; \"Address of arr[2][0]: \" &lt;&lt; &amp;arr[2][0] &lt;&lt; \", value = \" &lt;&lt; arr[2][0] &lt;&lt; std::endl; 可以看到和上述arr[n]地址一样，表示的每一行第一列的值，显而易见arr[n]指向的就是每行首元素的地址，也就是一维指针，那么arr就是二维指针，来验证一下： int *p = a; // 不通过 实验发现报错，继续看 int* p = *arr; std::cout &lt;&lt; \"Address of p: \" &lt;&lt; p &lt;&lt; \", Address of arr: \" &lt;&lt; arr &lt;&lt; std::endl; std::cout &lt;&lt; \"the value of p is: \" &lt;&lt; p &lt;&lt; std::endl; std::cout &lt;&lt; \"the value of *p is: \" &lt;&lt; *p &lt;&lt; std::endl; std::cout &lt;&lt; \"the value of p+1 is: \" &lt;&lt; p+1 &lt;&lt; std::endl; std::cout &lt;&lt; \"the value of *(p+1) is: \" &lt;&lt; *(p+1) &lt;&lt; std::endl; std::cout &lt;&lt; \"a[1][1] inferred from p : \" &lt;&lt; *(p+1*3+1) &lt;&lt; std::endl; 对a解引用后确实是一个地址，所以可以定义指针，并且可以用加偏移量的方式得到a[1][1] 对于二维数组arr[i][j],a[m][n]表示其中的一个值: arr[m][n] == *(*(arr + m) + n) == *(*arr + m * i + j) 总的来说数组的本质还是由指针封装起来的数据类型，所以从根本上来说可以从地址上解决，遇到一些奇奇怪怪的问题也可以由地址来解决，比如本文的问题： 另外，数组可以越界，这是C++所决定的，想要不越界只能人为的去限制","tags":[]},{"title":"VSCode设置自动识别文件编码格式","date":"2023-04-06T11:38:30.000Z","path":"2023/041be02434.html","text":"vscode打开文件默认是utf-8编码，当我们打开其他编码文件（例如gb2312）时就会产生乱码现象，如下图所示： 这个时候可以通过VSCode右下角的编码方式点击来修改可以看到有两个选项 以其他编码方式重新打开，此时就可以选择对应编码打开文件即可 第二个选项不建议选择，他会修改你的文件编码方式，内容会被修改 但是按选项一修改之后，下次我们重新打开这个文件，依旧会以UTF-8编码打开，如果需要频繁打开，就会很浪费时间。 其实VSCode自带有的自动识别编码方式，只需要选中即可（默认是不选中），打开Settings,搜索Files.AutoGuessEncoding选中即可，下次打开文件VSCode就会自动识别文件编码方式，并以对应编码方式打开","tags":[]},{"title":"SVM","date":"2023-03-06T07:59:48.000Z","path":"2023/0375378e04.html","text":"个人笔记 【数之道】支持向量机SVM是什么 概念 间隔Margin 支持向量（Support Vector）：只是指临界向量吗 正超平面、决策超平面、负超平面 损失因子：异常值 软间隔（Soft Margin）：考虑异常值的间隔 硬间隔（Hard Margin）：不考虑异常值的间隔 KKT条件： 对偶性： 升维转换对于在低纬度下无法轻松区分的数据可以增加维度进行区分，如下图（图源B站FunInCode，侵删）：因此可以考虑合适的方法进行升维转换： 采用合适的升维函数在高纬度下求解SVM模型，找到对应的高维决策超平面，预测数据时先对数据进行升维，再根据高维决策边界超平面进行判断，但是这种方法需要确定的升维函数，以及更多的数据存储和计算需求 但是一般这种方法耗费很大，因此就要用到核技巧了 核技巧(Kernel Trick)核技巧可以使SVM在低维就可以进行高维的区别对比 高斯核函数（RBF，Radial Basis Kernel） 取$\\lambda$ 为$\\frac{1}{2}$ ,高斯核函数可以转化为自然对数的形式，对其进行泰勒展开，即可通过控制参数获得从0维到无穷维的表达式","tags":[]},{"title":"排序","date":"2022-10-15T03:08:40.000Z","path":"2022/10a444b428.html","text":"冒泡排序（Bubble Sort）（稳定排序）（超出时间限制）比较相邻元素，如果第一个比第二个大，则交换。 时间复杂度$n^2$，空间复杂度1 代码： class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // bubbleSort int n = nums.size(); for (int i = 0; i &lt; n - 1; ++i) { bool flag = false; for (int j = 0; j &lt; n - 1 - i; ++j) { if (nums[j] &gt; nums[j + 1]) { swap(nums[j], nums[j + 1]); flag = true; } } if (flag == false) break; //无交换，代表当前序列已经最优 } return nums; } }; 选择排序（Select Sort）（非稳定排序）（超出时间限制）依次给每个位置选择当前位置及以后最小的元素（交换当前元素与之后最小元素的位置）。 不稳定举例：排序前：5, 5*, 1, 7排序后：1, 5*, 5, 7 时间复杂度$n^2$，空间复杂度1 代码： class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // selectSort 选择排序 int minIndex; int n = nums.size(); for (int i = 0; i &lt; n - 1; ++i) { minIndex = i; for (int j = i + 1; j &lt; n; ++j) { if (nums[j] &lt; nums[minIndex]) { minIndex = j; } } swap(nums[i], nums[minIndex]); } return nums; } }; 插入排序（Insect Sort）（稳定排序）（超出时间限制）在前 1~i - 1元素有序的情况下，（依次）将第 i 个元素插入前面已经有序的小序列，使其有序。使用哨兵减少比较 时间复杂度$n^2$，空间复杂度1 代码： class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int i, j; for (i = 2; i &lt;= nums.size(); i++) { if (nums[i] &lt; nums[i - 1]) { nums[0] = nums[i]; //nums[0]为哨兵 for (j = i - 1; nums[0] &lt; nums[j]; j--) { nums[j + 1] =nums[j]; } nums[j + 1] = nums[0]; } } return nums; } }; 插入排序在此基础上也可以将搜索和移动分开，使用二分查找先找到要插入位置，然后再移动 class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int i, j, low, high, mid; for (i = 2; i &lt;= nums.size(); i++) { nums[0] = nums[i]; low = 1; high = i - 1; while (low &lt;= high) { mid = (low + high) / 2; if (nums[mid] &gt; nums[0]) high = mid - 1; else low = mid + 1; } for (j = i - 1; j &gt; high + 1; j--) nums[j + 1] = nums[j]; nums[high + 1] = nums[0]; } return nums; } }; 希尔排序（Shell Sort）（非稳定排序）改进的插入排序（优化：原数组的一个元素距离正确位置很远的情况）先让间隔 h 的元素有序，在使得间隔为 h / 2，一直缩小，一直到 h = 1（此时数组有序）。 时间复杂度介于nlogn和$n^2$之间，空间复杂度1 代码： class Solution { void shellSort(vector&lt;int&gt;&amp;nums, int gap, int i) { int j, tmp = nums[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; tmp &lt; nums[j]; j -= gap) { // 依次后移 nums[j + gap] = nums[j]; } nums[j + gap] = tmp; } public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); // 分组，最开始时，间隔 gap 为数组的一半 for (int gap = n / 2; gap &gt;= 1 ; gap /= 2) { // 对各个分组进行插入分组 for (int i = gap; i &lt; n; ++i) { shellSort(nums, gap, i); } } return nums; } }; 归并排序（Merge Sort）（稳定排序）将无序数组拆分，排序后再合并成大的有序数组。 时间复杂度nlogn，空间复杂度n 代码： class Solution { vector&lt;int&gt; tmp; void merge (vector&lt;int&gt;&amp; nums, int low, int mid, int high) { for (int k = low; k &lt;= high; k++) { tmp[k] = nums[k]; } int i, j; for (i = low, j = mid + 1, k = i; i &lt;= mid &amp;&amp; j &lt;=high; k++) { if (tmp[i] &lt;= tmp[j]) { nums[k] = tmp[i++]; } else { nums[k] = tmp[j++]; } } while (i &lt;= mid) nums[k++] = tmp[i++]; while (j &lt;= high) nums[k++] = tmp[j++]; } public: vector&lt;int&gt; mergeSort(vector&lt;int&gt;&amp; nums, int low, int high) { if (low &lt; high) { int mid = (low + high) / 2; mergeSort(nums, low, mid + 1); mergeSort(nums, mid + 1, high); merge(nums, low, mid, high); } } }; 快速排序（Quick Sort）（非稳定排序）随机选取一个数（x = rand() % len + startIndex）作为基准；把比基准小的数交换到前面，比基准大的数交换到后面；对左右区间递归重复。 时间复杂度nlogn，空间复杂度logn 代码： class Solution { void quickSort(vector&lt;int&gt;&amp;nums, int startIndex, int endIndex) { if (startIndex &gt;= endIndex) return; int x = rand() % (endIndex - startIndex + 1) + startIndex; // 基于随机的原则 swap(nums[startIndex], nums[x]); int firstNum = nums[startIndex]; int l = startIndex, r = endIndex; while (l &lt; r) { // 从后往前走，将比第一个小的移到前面 while (l &lt; r &amp;&amp; nums[r] &gt;= firstNum) --r; if (l &lt; r) { nums[l] = nums[r]; } // 从前往后走，将比第一个大的移到后面 while (l &lt; r &amp;&amp; nums[l] &lt;= firstNum) ++l; if (l &lt; r) { nums[r] = nums[l]; } } nums[l] = firstNum; // 自顶向下 quickSort(nums, startIndex, l - 1); quickSort(nums, l + 1, endIndex); } public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); quickSort(nums, 0, n - 1); return nums; } }; 堆排序（Heap Sort）（非稳定排序）先在原先数组的基础上构造大根堆（时间复杂度nlogn）；再依次弹出最大元素（每次弹出的时间复杂度为logk，k为当前大根堆中元素数目）。 时间复杂度nlogn，空间复杂度1 代码： class Solution { void buildMaxHeap(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = (n - 1) / 2; i &gt;= 0; --i) { maxHeapify(nums, i, n); } } void maxHeapify(vector&lt;int&gt;&amp; nums, int i, int n) { while (i * 2 + 1 &lt; n) { // 代表当前 i 节点的左右儿子； // 超出数组大小则代表当前 i 节点为叶子节点，不需要移位 int lSon = 2 * i + 1; int rSon = 2 * i + 2; int large = i; if (lSon &lt; n &amp;&amp; nums[lSon] &gt; nums[i]) large = lSon; if (rSon &lt; n &amp;&amp; nums[rSon] &gt; nums[large]) large = rSon; if (large != i) { swap(nums[i], nums[large]); // 迭代判断对应子节点及其儿子节点的大小关系 i = large; } else { break; } } } public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // heapSort 堆排序 int n = nums.size(); // 将数组整理成大根堆 buildMaxHeap(nums); for (int i = n - 1; i &gt;= 1; --i) { // 依次弹出最大元素，放到数组最后，当前排序对应数组大小 - 1 swap(nums[0], nums[i]); --n; maxHeapify(nums, 0, n); } return nums; } }; 计数排序（Count Sort）（稳定排序）创建数组 counts，用于统计原数组 nums 中各元素值的出现次数；再依次将元素值赋值到 nums 中对应位置。 计数排序，时间复杂度n + k，空间复杂度k（k = maxNum - minNum + 1） 代码： class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // CountSort 计数排序 int n = nums.size(); int minNum = INT_MAX, maxNum = INT_MIN; // 找到数组中的最小和最大元素 for (int i = 0; i &lt; n; ++i) { if (nums[i] &lt; minNum) minNum = nums[i]; if (nums[i] &gt; maxNum) maxNum = nums[i]; } // 构造计数数组 vector&lt;int&gt; counts(maxNum - minNum + 1, 0); for (int i = 0; i &lt; n; ++i) { ++counts[nums[i] - minNum]; } // 计数排序 int index = 0; for (int i = 0; i &lt; counts.size(); ++i) { while (counts[i] != 0) { nums[index++] = i + minNum; counts[i]--; } } return nums; } }; 桶排序（Bucket Sort）（稳定排序）将原数组的元素分到有限数量的桶里（大编号桶里的所有元素均大于小编号桶里的任意元素）；分别对每个桶进行排序；依次合并。 时间复杂度n + k，空间复杂度n + k（k为桶的数量） 代码： class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // BucketSort 桶排序 int n = nums.size(); // 获取数组的最小值和最大值 int maxNum = nums[0], minNum = nums[0]; for (int i = 1; i &lt; n; ++i) { if (nums[i] &gt; maxNum) maxNum = nums[i]; if (nums[i] &lt; minNum) minNum = nums[i]; } // 初始化桶 int bucketNum = 5, bucketSize = (maxNum - minNum) / bucketNum + 1; vector&lt;vector&lt;int&gt;&gt; buckets(bucketNum, vector&lt;int&gt;(0)); // 小至大分桶 for (int num : nums) { int bucketIndex = (num - minNum) / bucketSize; buckets[bucketIndex].emplace_back(num); } // 桶内排序 for (int i = 0; i &lt; buckets.size(); ++i) { sort(buckets[i].begin(), buckets[i].end()); } // 从桶中依次取数 int index = 0; for (auto&amp; bucket : buckets) { for (int num : bucket) { nums[index++] = num; } } return nums; } }; 基数排序（Radix Sort）（稳定排序）对数组中所有数依次按由低到高的位数进行多次排序；每次排序都基于上次排序的结果。（相对位置顺序保持不变） 例：原始数组 1，23，21，11，32第一次排序后 1，21，11，32，23第二次排序后 1，11，21，23，32时间复杂度n x k，空间复杂度k（k为最大元素的位数） 代码： class Solution { vector&lt;int&gt; counts; void radixSort(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; tmp, int divisor) { int n = nums.size(); counts = vector&lt;int&gt;(10, 0); // 统计个、十、百、千、万上对应 0 ~ 9 的出现次数 for (int i = 0; i &lt; n; ++i) { int x = (nums[i] / divisor) % 10; ++counts[x]; } // 前缀和 for (int i = 1; i &lt;= 9; ++i) { counts[i] += counts[i - 1]; } // 从后向前赋值 for (int i = n - 1; i &gt;= 0; --i) { int x = (nums[i] / divisor) % 10; int index = counts[x] - 1; tmp[index] = nums[i]; --counts[x]; } } public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { // RadixSort 基数排序 int n = nums.size(); // 预处理，让所有的数都大于等于0 for (int i = 0; i &lt; n; ++i) { nums[i] += 50000; // 50000为最小可能的数组大小 } // 找出最大的数字，并获得其最大位数 int maxNum = nums[0]; for (int i = 0; i &lt; n; ++i) { if (nums[i] &gt; maxNum) { maxNum = nums[i]; } } int num = maxNum, maxLen = 0; while (num) { ++maxLen; num /= 10; } // 基数排序，低位优先 int divisor = 1; vector&lt;int&gt; tmp(n, 0); for (int i = 0; i &lt; maxLen; ++i) { radixSort(nums, tmp, divisor); swap(tmp, nums); divisor *= 10; } // 减去预处理量 for (int i = 0; i &lt; n; ++i) { nums[i] -= 50000; } return nums; } };","tags":[]},{"title":"中缀表达式转后缀表达式","date":"2022-10-08T06:36:51.000Z","path":"2022/1072a96e3d.html","text":"后缀表达式后缀表达式也叫逆波兰表达式 ，其表达式表述严谨，没有括号，并严格遵循“从左到右”的后缀表达式表示方法 后缀表达式求值后缀表达式求值过程用到栈做辅助存储，假设给定后缀表达式字符串s为6523+8*+3+*,借用栈来存储数字，顺序读取，遇到数字则入栈，遇到表达符c则依次从栈中取出a和b，计算bca，并将其值入栈，最后栈中的值即为最终结果，下面演示求值过程： 读取6，入栈，栈中为6 读取5，入栈，栈中为6、5 读取2，入栈，栈中为6、5、2 读取3，入栈，栈中为6、5、2、3 读取+，从栈中依次取出3、2，计算2+3，将结果5入栈，栈中为6、5、5 读取8，入栈，栈中为6、5、5、8 读取*，从栈中依次取出8、5,计算5*8，将结果40入栈，栈中为6、5、40 读取+，从栈中依次取出40、5，计算40+5，将结果45入栈，栈中为6、45 读取3，入栈，栈中为6、45、3 读取+，从栈中依次取出3、45，计算45+3，将结果48入栈，栈中为6、48 读取*，从栈中依次取出48、6，计算6*48，将结果288入栈，栈中为288 读取到行末提示符，运算结束，结果即为栈中元素288 中缀表达式转后缀表达式简便方法以中缀表达式a+b*c+(d*e+f)*g为例，转换为后缀表达式： 对每一次运算（只要出现加减乘除符号）及其运算数加括号，为((a+(b*c))+(((d*e)+f)*g)) 将运算符移到括号后面，为((a(bc)*)+(((de)*f)+g)*)+ 去掉括号，为abc*+de*f+g*+ 一般方法待补充","tags":[]},{"title":"win10时间显示精确到秒","date":"2022-10-06T01:43:49.000Z","path":"2022/1091d7ef4e.html","text":"任意位置新建txt文件，打开编辑 复制以下代码 @echo off reg add \"HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\" /v ShowSecondsInSystemClock /t REG_DWORD /d 1 /f TASKKILL /F /IM explorer.exe echo. echo 重启explorer.exe START %windir%\\explorer.exe echo. pause 更改后缀为.bat，之后双击执行该文件即可 效果如下","tags":[]},{"title":"原码、反码、补码、移码","date":"2022-09-25T05:55:49.000Z","path":"2022/0920d1f156.html","text":"真值： 通常用正负号来表示正负数，如+15，-13等，这种带符号的数称为真值，真值是机器数所代表的实际值 计算机中通常用0表示正，1表示负，若没有特殊规定，通常按这种表示方式 在现代计算机中，通常用定点补码表示整数 ，用定点原码表示小数 ，用移码表示浮点数的阶码 原码 反码 补码 移码 正整数 本身，符号位为0 与原码相同 与原码相同 符号位取反 负整数 本身，符号位为1 符号位不变，数值位按位取反 反码末位加1 符号位取反 正小数 本身，符号位为0 与原码相同 与原码相同 小数无移码 负小数 本身，符号位为1 符号位不变，数值位按位取反 反码末位加1 小数无移码 补码变原码：正数为本身，负数依然是先取反，然后末位加一 表示范围（机器字长为n + 1） 特征 整数原码 $-（2^n -1）\\le x \\le 2^n - 1$ 0的表示方法有两种,原点对称 小数原码 $-(1 - 2^{-n}) \\le x \\le 1 - 2^{-n}$ 0的表示方法有两种,原点对称 整数反码 $-（2^n -1）\\le x \\le 2^n - 1$ 0的表示方法有两种,原点对称 小数反码 $-(1 - 2^{-n}) \\le x \\le 1 - 2^{-n}$ 0的表示方法有两种,原点对称 整数补码 $- 2^n \\le x \\le 2^n - 1$ 真值0只有一种形式，并规定1000，0000表示$x = -2^7$ 小数补码 $-1 \\le \\le 1 - 2^{-n}$ 真值0只有一种格式，规定1.000，0000表示x = -1 整数移码 $- 2^n \\le x \\le 2^n - 1$ 移码只能用于表示整数，0同样只有一种表示形式，很容易对比大小，移码表示数依次真值递增 由$[x]{补}$ 求$[-x]{补}$，将所有位取反，末尾加一 原码实现乘除运算比较简单，加减比较麻烦","tags":[]},{"title":"矩阵的等价、相似、合同之间的关系","date":"2022-08-23T02:26:39.000Z","path":"2022/082689765e.html","text":"矩阵等价 定义：对同型矩阵A、B，存在可逆阵P和Q，使得$B=PAQ$ 充要条件：A和B的秩相等 矩阵合同 定义：对同型方阵A、B，存在可逆阵P使得$P^{T}AP = B$,记作$A ≃ B$ 矩阵相似 比等价严苛 定义：对同型方阵A、B，存在可逆阵P，使得$P^{-1}AP = B$,记作$A ∼ B$ 三者关系等价（只有秩相同）$\\rightarrow$ 合同（秩和正负惯性指数相同）$\\rightarrow$ 相似（秩，正负惯性指数，特征值均相同），矩阵亲密关系的一步步深化。 相似矩阵必为等价矩阵，但等价矩阵未必为相似矩阵 PQ = E的等价矩阵是相似矩阵 合同矩阵必为等价矩阵，等价矩阵未必为合同矩阵 正惯性指数相同的等价矩阵是合同矩阵 合同矩阵未必是相似矩阵 相似矩阵未必合同 正交相似矩阵必为合同矩阵，正交合同矩阵必为相似矩阵 如果A与B都是n阶实对称矩阵，且有相同的特征根．则A与B既相似又合同","tags":[]},{"title":"背包理论基础多重背包","date":"2022-08-10T05:42:04.000Z","path":"2022/0871e46bfb.html","text":"转载自代码随想录，侵删 建议按照如下顺序观看：背包理论基础01背包1背包理论基础01背包2背包基础理论完全背包背包基础理论多重背包（本文） 动态规划：关于多重背包，你该了解这些！这次我们再来说一说多重背包 多重背包对于多重背包，我在力扣上还没发现对应的题目，所以这里就做一下简单介绍，大家大概了解一下。 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。 多重背包和01背包是非常像的， 为什么和01背包像呢？ 每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。 例如： 背包最大重量为10。 物品为： 重量 价值 数量 物品0 1 15 2 物品1 3 20 3 物品2 4 30 2 问背包能背的物品最大价值是多少？ 和如下情况有区别么？ 重量 价值 数量 物品0 1 15 1 物品0 1 15 1 物品1 3 20 1 物品1 3 20 1 物品1 3 20 1 物品2 4 30 1 物品2 4 30 1 毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。 这种方式来实现多重背包的代码如下： void test_multi_pack() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; vector&lt;int&gt; nums = {2, 3, 2}; int bagWeight = 10; for (int i = 0; i &lt; nums.size(); i++) { while (nums[i] &gt; 1) { // nums[i]保留到1，把其他物品都展开 weight.push_back(weight[i]); value.push_back(value[i]); nums[i]--; } } vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } for (int j = 0; j &lt;= bagWeight; j++) { cout &lt;&lt; dp[j] &lt;&lt; \" \"; } cout &lt;&lt; endl; } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl; } int main() { test_multi_pack(); } 时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量 也有另一种实现方式，就是把每种商品遍历的个数放在01背包里面在遍历一遍。 代码如下：（详看注释） void test_multi_pack() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; vector&lt;int&gt; nums = {2, 3, 2}; int bagWeight = 10; vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 // 以上为01背包，然后加一个遍历个数 for (int k = 1; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= 0; k++) { // 遍历个数 dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]); } } // 打印一下dp数组 for (int j = 0; j &lt;= bagWeight; j++) { cout &lt;&lt; dp[j] &lt;&lt; \" \"; } cout &lt;&lt; endl; } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl; } int main() { test_multi_pack(); } 时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量 从代码里可以看出是01背包里面在加一个for循环遍历一个每种商品的数量。 和01背包还是如出一辙的。 当然还有那种二进制优化的方法，其实就是把每种物品的数量，打包成一个个独立的包。 和以上在循环遍历上有所不同，因为是分拆为各个包最后可以组成一个完整背包，具体原理我就不做过多解释了，大家了解一下就行，面试的话基本不会考完这个深度了，感兴趣可以自己深入研究一波。 总结多重背包在面试中基本不会出现，力扣上也没有对应的题目，大家对多重背包的掌握程度知道它是一种01背包，并能在01背包的基础上写出对应代码就可以了。 至于背包九讲里面还有混合背包，二维费用背包，分组背包等等这些，大家感兴趣可以自己去学习学习，这里也不做介绍了，面试也不会考。 背包理论基础01背包1背包理论基础01背包2背包基础理论完全背包背包基础理论多重背包（本文）","tags":[]},{"title":"背包理论基础完全背包","date":"2022-08-10T05:22:02.000Z","path":"2022/08806f2082.html","text":"转载自代码随想录，侵删 建议按照如下顺序观看：背包理论基础01背包1背包理论基础01背包2背包基础理论完全背包（本文）背包基础理论多重背包 动态规划：关于完全背包，你该了解这些！完全背包有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。 同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。 在下面的讲解中，我依然举这个例子： 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 每件商品都有无限个！ 问背包能背的物品最大价值是多少？ 01背包和完全背包唯一不同就是体现在遍历顺序上，所以本文就不去做动规五部曲了，我们直接针对遍历顺序经行分析！ 关于01背包我如下两篇已经进行深入分析了： 动态规划：关于01背包问题，你该了解这些！ 动态规划：关于01背包问题，你该了解这些！（滚动数组） 首先在回顾一下01背包的核心代码 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } 我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。 而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即： // 先遍历物品，再遍历背包 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight ; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } 至于为什么，我在动态规划：关于01背包问题，你该了解这些！（滚动数组）中也做了讲解。 dp状态图如下： 相信很多同学看网上的文章，关于完全背包介绍基本就到为止了。 其实还有一个很重要的问题，为什么遍历物品在外层循环，遍历背包容量在内层循环？ 这个问题很多题解关于这里都是轻描淡写就略过了，大家都默认 遍历物品在外层，遍历背包容量在内层，好像本应该如此一样，那么为什么呢？ 难道就不能遍历背包容量在外层，遍历物品在内层？ 看过这两篇的话： 动态规划：关于01背包问题，你该了解这些！ 动态规划：关于01背包问题，你该了解这些！（滚动数组） 就知道了，01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。 在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！ 因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。 遍历物品在外层循环，遍历背包容量在内层循环，状态如图： 遍历背包容量在外层循环，遍历物品在内层循环，状态如图： 看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。 先遍历背包在遍历物品，代码如下： // 先遍历背包，再遍历物品 for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } cout &lt;&lt; endl; } C++测试代码完整的C++测试代码如下： // 先遍历物品，在遍历背包 void test_CompletePack() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; int bagWeight = 4; vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl; } int main() { test_CompletePack(); } // 先遍历背包，再遍历物品 void test_CompletePack() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; int bagWeight = 4; vector&lt;int&gt; dp(bagWeight + 1, 0); for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl; } int main() { test_CompletePack(); } 总结细心的同学可能发现，全文我说的都是对于纯完全背包问题，其for循环的先后循环是可以颠倒的！ 但如果题目稍稍有点变化，就会体现在遍历顺序上。 如果问装满背包有几种方式的话？ 那么两个for循环的先后顺序就有很大区别了，而leetcode上的题目都是这种稍有变化的类型。 这个区别，我将在后面讲解具体leetcode题目中给大家介绍，因为这块如果不结合具题目，单纯的介绍原理估计很多同学会越看越懵！ 别急，下一篇就是了！哈哈 最后，又可以出一道面试题了，就是纯完全背包，要求先用二维dp数组实现，然后再用一维dp数组实现，最后在问，两个for循环的先后是否可以颠倒？为什么？这个简单的完全背包问题，估计就可以难住不少候选人了。 背包理论基础01背包1背包理论基础01背包2背包基础理论完全背包（本文）背包基础理论多重背包","tags":[]},{"title":"背包理论基础01背包2","date":"2022-08-10T05:21:14.000Z","path":"2022/08517e3a8f.html","text":"转载自代码随想录，侵删 建议按照如下顺序观看：背包理论基础01背包1背包理论基础01背包2（本文）背包基础理论完全背包背包基础理论多重背包 动态规划：关于01背包问题，你该了解这些！（滚动数组）昨天背包理论基础01背包1中是用二维dp数组来讲解01背包。 今天我们就来说一说滚动数组，其实在前面的题目中我们已经用到过滚动数组了，就是把二维dp降为一维dp，一些录友当时还表示比较困惑。 那么我们通过01背包，来彻底讲一讲滚动数组！ 接下来还是用如下这个例子来进行讲解 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 问背包能背的物品最大价值是多少？ 一维dp数组（滚动数组）对于背包问题其实状态都是可以压缩的。 在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]); 与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。 这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。 读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。 dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 一定要时刻记住这里i和j的含义，要不然很容易看懵了。 动规五部曲分析如下： 确定dp数组的定义 在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 一维dp数组的递推公式 dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？ dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。 dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]） 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值， 所以递归公式为： dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。 一维dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。 那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？ 看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。 这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。 那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。 一维dp数组遍历顺序 代码如下： for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } 这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！ 二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。 为什么呢？ 倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！ 举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15 如果正序遍历 dp[1] = dp[1 - weight[0]] + value[0] = 15 dp[2] = dp[2 - weight[0]] + value[0] = 30 此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。 为什么倒序遍历，就可以保证物品只放入一次呢？ 倒序就是先算dp[2] dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0） dp[1] = dp[1 - weight[0]] + value[0] = 15 所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。 那么问题又来了，为什么二维dp数组历的时候不用倒序呢？ 因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！ （如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！） 再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？ 不可以！ 因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。 倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。 （这里如果读不懂，就在回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！） 所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！，这一点大家一定要注意。 举例推导dp数组 一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下： 一维dp01背包完整C++测试代码void test_1_wei_bag_problem() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; int bagWeight = 4; // 初始化 vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl; } int main() { test_1_wei_bag_problem(); } 可以看出，一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了。 所以我倾向于使用一维dp数组的写法，比较直观简洁，而且空间复杂度还降了一个数量级！ 在后面背包问题的讲解中，我都直接使用一维dp数组来进行推导。 总结以上的讲解可以开发一道面试题目（毕竟力扣上没原题）。 就是本文中的题目，要求先实现一个纯二维的01背包，如果写出来了，然后再问为什么两个for循环的嵌套顺序这么写？反过来写行不行？再讲一讲初始化的逻辑。 然后要求实现一个一维数组的01背包，最后再问，一维数组的01背包，两个for循环的顺序反过来写行不行？为什么？ 注意以上问题都是在候选人把代码写出来的情况下才问的。 就是纯01背包的题目，都不用考01背包应用类的题目就可以看出候选人对算法的理解程度了。 相信大家读完这篇文章，应该对以上问题都有了答案！ 此时01背包理论基础就讲完了，我用了两篇文章把01背包的dp数组定义、递推公式、初始化、遍历顺序从二维数组到一维数组统统深度剖析了一遍，没有放过任何难点。 大家可以发现其实信息量还是挺大的。 如果把背包理论基础01背包1和本篇的内容都理解了，后面我们在做01背包的题目，就会发现非常简单了。 不用再凭感觉或者记忆去写背包，而是有自己的思考，了解其本质，代码的方方面面都在自己的掌控之中。 即使代码没有通过，也会有自己的逻辑去debug，这样就思维清晰了。 背包理论基础01背包1背包理论基础01背包2（本文）背包基础理论完全背包背包基础理论多重背包","tags":[]},{"title":"背包理论基础01背包1","date":"2022-08-10T05:21:02.000Z","path":"2022/08c8776b35.html","text":"转载自代码随想录，侵删 建议按照如下顺序观看：背包理论基础01背包1（本文）背包理论基础01背包2背包基础理论完全背包背包基础理论多重背包 动态规划：关于01背包问题，你该了解这些！这周我们正式开始讲解背包问题！ 如果这几种背包，分不清，我这里画了一个图，如下： 至于背包九讲其其他背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。 而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。 所以背包问题的理论基础重中之重是01背包，一定要理解透！ leetcode上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要转化为01背包问题。 所以我先通过纯01背包问题，把01背包原理讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为01背包问题了。 之前可能有些录友已经可以熟练写出背包了，但只要把这个文章仔细看完，相信你会意外收获！ 01 背包有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。 这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？ 每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。 所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！ 在下面的讲解中，我举一个例子： 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 问背包能背的物品最大价值是多少？ 以下讲解和图示中出现的数字都是以这个例子为例。 二维dp数组01背包依然动规五部曲分析一波。 确定dp数组以及下标的含义 对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 只看这个二维数组的定义，大家一定会有点懵，看下面这个图： 要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。 确定递推公式 再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 那么可以有两个方向推出来dp[i][j]， 不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。) 放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。 首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图： 在看其他情况。 状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。 dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。 那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。 当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。 代码初始化如下： for (int j = 0 ; j &lt; weight[0]; j++) { // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。 dp[0][j] = 0; } // 正序遍历 for (int j = weight[0]; j &lt;= bagweight; j++) { dp[0][j] = value[0]; } 此时dp数组初始化情况如图所示： dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？ 其实从递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。 初始-1，初始-2，初始100，都可以！ 但只不过一开始就统一把dp数组统一初始为0，更方便一些。 如图： 最后初始化代码如下： // 初始化 dp vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0)); for (int j = weight[0]; j &lt;= bagweight; j++) { dp[0][j] = value[0]; } 费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的。 确定遍历顺序 在如下图中，可以看出，有两个遍历的维度：物品与背包重量 那么问题来了，先遍历 物品还是先遍历背包重量呢？ 其实都可以！！ 但是先遍历物品更好理解。 那么我先给出先遍历物品，然后遍历背包重量的代码。 // weight数组的大小 就是物品个数 for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } 先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组） 例如这样： // weight数组的大小 就是物品个数 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } 为什么也是可以的呢？ 要理解递归的本质和递推的方向。 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的。 dp[i-1][j]和dp[i - 1][j - weight[i]] 都在dp[i][j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示： 再来看看先遍历背包，再遍历物品呢，如图： 大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！ 但先遍历物品再遍历背包这个顺序更好理解。 其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了。 举例推导dp数组 来看一下对应的dp数组的数值，如图： 最终结果就是dp[2][4]。 建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。 做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！ 很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。 主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了。 完整c++测试代码void test_2_wei_bag_problem1() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; int bagweight = 4; // 二维数组 vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0)); // 初始化 for (int j = weight[0]; j &lt;= bagweight; j++) { dp[0][j] = value[0]; } // weight数组的大小 就是物品个数 for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } cout &lt;&lt; dp[weight.size() - 1][bagweight] &lt;&lt; endl; } int main() { test_2_wei_bag_problem1(); } 总结讲了这么多才刚刚把二维dp的01背包讲完，这里大家其实可以发现最简单的是推导公式了，推导公式估计看一遍就记下来了，但难就难在如何初始化和遍历顺序上。 可能有的同学并没有注意到初始化 和 遍历顺序的重要性，我们后面做力扣上背包面试题目的时候，大家就会感受出来了。 下一篇 还是理论基础，我们再来讲一维dp数组实现的01背包（滚动数组），分析一下和二维有什么区别，在初始化和遍历顺序上又有什么差异，敬请期待！ 背包理论基础01背包1（本文）背包理论基础01背包2背包基础理论完全背包背包基础理论多重背包","tags":[]},{"title":"LeetCode笔记-动态规划","date":"2022-08-06T09:41:48.000Z","path":"2022/0826e7783f.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的 动规的五部曲 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 如果代码写出来了，一直AC不了，灵魂三问： 这道题目我举例推导状态转移公式了么？ 我打印dp数组的日志了么？ 打印出来了dp数组和我想的一样么？ 首先要明白dp数组的含义是什么，下表代表什么，确定了这个之后按照套路走就行，手动推导dp数组本质上也是一种检验的过程，当打印出结果符合预期手动推导结果时，基本就没太大问题 2022.8.9动态规划的习题我认为最重要的就是要确定dp数组的定义，下标代表什么，该如何初始化，举个例子： LeetCode304：整数拆分 给定一个正整数&nbsp;n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1: 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例&nbsp;2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 ×&nbsp;3 ×&nbsp;4 = 36。 说明: 你可以假设&nbsp;n&nbsp;不小于 2 且不大于 58。 这道题在我的做法中dp数组表示的是i这个数字的最大拆分乘积，初始化dp[2] = 1,这是易知的，而在一些题解中就把dp[0]和dp[1]也进行了初始化，这么做当然也可以AC，但是dp数组的意义已经模糊了，暂不谈题目限制`$$2 \\le n \\ge 58$$,就按照题目说明，0和1就不能拆分为两个正整数的和，更不用谈乘积，虽然这么初始化问题也不大，但是我感觉要透过题去理解，要明白dp数组的含义，下标表示了什么更为重要，下面是本题C++代码： class Solution { public: int integerBreak(int n) { vector&lt;int&gt; dp(n + 1); dp[2] = 1; for (int i = 3; i &lt;= n ; i++) { for (int j = 1; j &lt; i - 1; j++) { dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)); } } return dp[n]; } }; 时间复杂度：O(n^2) 空间复杂度：O(n) 背包问题2022.08.10 转载自代码随想录，侵删 建议按照如下顺序观看：背包理论基础01背包1背包理论基础01背包2背包基础理论完全背包背包基础理论多重背包 01背包和完全背包2022.08.13 背包问题大概描述是：有一个承重m的背包，旁边有一堆物品共n个，每个物品重量不一，价值不易，weight[i]和value[i]分别代表第i个物品的重量和价值，求背包最多能装下物品的价值 01背包是说每个物品只有一个，怎么装价值最大完全背包是说每种物品有无限多个，怎么装价值最大，比如一辆卡车去进货，每种货占的空间不同，价值也不同，但是每种货数量是不限制的，怎么装，一卡车货价值最大 01背包-二维-先物品后背包采用二维数组遍历必然要考虑遍历顺序，是先遍历背包，还是先遍历物品，不妨设先遍历物品，那么循环内层遍历的就是背包了 当对于num[i]，无非两种情况: 背包可以装的下，继续装那么价值就是dp[i - 1][j - weight[i]] + value[i],表示未装num[i]物品前，背包最大容量必然是j - weight[i]（因为还要装第i件物品，所以预留出weight[i]的空间，剩下的空间可以装的最大值就是dp[i - 1][j - weight[i]]） 装不下，背包里面物品价值还是不变，就是dp[i - 1][j] 那么二者取最大值，就是i件物品容量为j的背包可以装的物品最大价值，依次递推即可 for (int i = 0; i &lt; num[i]; i++) { for (int j = weight[i]; j &lt;= target; j++) { //j从weight[i]开始，是因为小于weight[i]的背包根本装不下第i件物品，所以一定都是dp[i - 1][j] dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } 01背包-二维-先背包后物品转变一下遍历顺序二维时是完全可以的，观察上述递归公式可以发现，dp[i][j]完全是由上一行的值和weight数组和value数组决定的，而后面两个是已知的，所以不管按照什么顺序遍历，dp[i][j]仅由其左上位置数值决定，所以遍历顺序怎么样都可以，下面给出先遍历背包，后遍历物品的代码： for (int j = 0; j &lt;= target; j++) { for (int i = 1; i &lt; nums.size(); i++) { if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; //装不下 else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); //装得下 } } 01背包-一维前面也已经说明过了，dp[i][j]只依赖上一行的数值，所以我们可以将dp数组降为一维，节约空间，但是要注意，二维的时候我们依赖的是上一行（i - 1行）的值，降为一维后，当不做任何变化时，当前数值就是上一行数值，但是如果j还是从前往后遍历，那么当为j时，从0 ~ （j - 1）的数值已经变为新值了，不再是上一行的值，所以不能从前往后遍历，而当我们从后往前遍历则是可以的，原因也很简单，前面说过，dp[i][j]只依赖左上方的值，当降为一维数组之后，就是只依赖左方的值，而我们从后往前遍历，左方的值一直都未变化，当然是可以的，代码如下： for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } 顺序在这里也很重要，一定要是先物品后背包容量，反之则不行 观察二维时候的递推公式 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); dp[i][j]依赖的是上一行，不是上一列，是j - weight[i]列，所以滚动数组完全不可行 完全背包完全背包相比01背包就是物品可以用无数次，仅仅在01背包的基础上略微修改即可，从前往后遍历即可 上文知道，01背包从后往前遍历是为了保证每个物品仅仅使用一次，而完全背包可以用无数次，从前往后即可，代码如下： // 先遍历物品，再遍历背包 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight ; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } // 先遍历背包，再遍历物品 for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } cout &lt;&lt; endl; } 至于遍历顺序，则同01背包 关于排列和组合完全背包往往会涉及到排列和组合的问题 就比如这个组合总数Ⅳ,求数字总和为target 这道题目要求数字顺序不一样也是一种组合，其本质上就是排列问题，那么使用循环遍历时就需要注意遍历顺序了 先物品后背包肯定是行不通的，因为物品只能按顺序出现，比如说{1， 3}，不可能出现{3，1}，因为物品是在外侧循环，只能按照数组顺序出现，所以说不能使用先物品后背包的方式，而要用先背包后物品才可以 一句话总结就是先物品后背包是组合 ， 先背包后物品是排列 多重背包多重背包其实跟01背包如出一辙，只是原本数量为1的物品现在数量不再一定为1了，而是由一个数量数组nums记录每件物品的数量有多少，针对多重背包，有以下两种解决方法： 把多重背包拆分为01背包，把同一种物品拆分为一个一个的，问题就简化为了01背包，按照01背包的解决方法即可 在双重遍历的时候内嵌一个for循环，遍历这个物品对应的数量即可，本质上还是把同一个物品拆分为了一个一个的 背包总结 图源代码随想录知识星球 (opens new window)成员：海螺人","tags":[]},{"title":"LeetCode笔记-贪心算法","date":"2022-07-25T12:03:50.000Z","path":"2022/072a2449dc.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。 思路贪心的题目没有固定套路，但都遵循着一个思想：局部最优从而达到全局最优 简单的问题直接遵循这个思想解决即可，稍微麻烦一点的可能会涉及到两个维度最优，且两个维度相互有联系，相互牵制，就比如下面这道题，首先要根据题目确定一个合适的维度保持最优，然后调整另一个维度。 eg 406.根据身高重建队列 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [$h_i$, $k_i$] 表示第 i 个人的身高为 $h_i$ ，前面 正好 有 $k_i$ 个身高大于或等于 $h_i$ 的人。 请你重新构造并返回输入数组&nbsp;people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例 1： 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 解释： 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 示例 2： 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示： 1 &lt;= people.length &lt;= 2000 0 &lt;= $h_i$ &lt;= 10^6 0 &lt;= $k_i$ &lt; people.length 题目数据确保队列可以被重建 本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。 如果两个维度一起考虑一定会顾此失彼。 对于本题究竟先按h排序呢，还先按照k排序呢？ 如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。 那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。 此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！ 那么只需要按照k为下标重新插入队列即可。 局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性 全局最优：最后都做完插入操作，整个队列满足题目队列属性 本题整个插入过程如下： 排序完的people：[[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]] 插入的过程： 插入[7,0]：[[7,0]] 插入[7,1]：[[7,0],[7,1]] 插入[6,1]：[[7,0],[6,1],[7,1]] 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]] 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]] 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 此时就按照题目的要求完成了重新排列。 class Solution { public: static bool cmp (vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) { if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &gt; b[0]; } vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) { sort(people.begin(), people.end(), cmp); vector&lt;vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; people.size(); i++) { res.insert(res.begin() + people[i][1], people[i]); } return res; } }; 时间复杂度：$O(nlog n + n^2)$ 空间复杂度：O(n) 2022/8/6有一类区间最优问题非常适合贪心，比如下面几题： 用最少数量的箭引爆气球 无重叠区间 划分字母区间 合并区间 这类区间问题有一个套路就是可以先对区间排序，至于是根据左边界排序还是右边界没有太大影响，个人习惯左边界排序，之后通过控制右边界即可轻松解决问题，上文也提到不要一起考虑，不然容易顾此失彼。 根据左边界排序之后，所有的区间左边界必定是递增的（当然不是严格递增，存在相等的情况），而右边界无非三种情况，相对于我们选定的右边界来说，大于，小于，等于，此时只需要根据题目要求针对三种情况处理即可，这样就可以保证处理位置之前的区间都是最优的，也就是局部最优，待遍历到末尾之后，前面都是局部最优解，最终也就是全局最优，总之还是贪心没有固定套路，最多只能是几类问题有相似之处而已，从问题中找到局部最优解，然后扩展到全局即可。 最后附上贪心的知识图（图源知识星球：海螺人）：","tags":[]},{"title":"VSCode+PicGo+Aliyun配置MarkDown图床","date":"2022-07-25T09:04:42.000Z","path":"2022/07b93436c8.html","text":"VSCode作为一款非常轻便的编辑器，以轻量，插件丰富收到大家欢迎，我个人是非常喜欢使用VSCode的，用VSCode去编辑Markdown文件也十分方便，当然Typora在这方便也很受欢迎，但是Typora正式版上线之后要收费，不可避免地会损失一部分用户，接下来我就介绍一下使用VSCode来进行编辑Markdown文件时图传的配置方法 前置要求:安装VSCode即可 插件只需安装一个Markdown All in One即可使用VSCode编辑Markdown文件，非常方便 但是这个插件不提供图床功能，仍需要将图片转换成网络链接复制到md文件中，非常不方便 接下来继续安装一个PicGo插件即可 Aliyun对象存储OSS PicGo默认存储为SMMS，我也一直在用这个，但是今天突然就打不开了，Github也可以，但是其服务器在国外，国内使用经常会显示不了图片，所以综合一下选择了Aliyun，而且新用户免费体验三个月，作为图床仓库，40G存储量一年的价格为5元，也可以说是非常划算了，接下来讲一下详细配置。 打开阿里云官网，登陆或注册，在产品里面找到对象存储OSS 根据需要直接购买，作为图床使用40G空间已经足够了，选项默认的即可，直接购买即可 购买之后直接进入OSS管理控制台 在Bucket列表中新建一个Bucket，地域选择离自己最近的，复制下这个地域名称英文，待会要用读写权限选择公共读其他选择默认配置即可。 创建成功之后进入创建的Bucket，进入概述界面，下方的访问域名中有一个外网访问，记录后面的Bucket域名，待会要使用 然后点击头像的AccessKey管理创建一个AccessKey记录AccessKey ID和AccessKey Secret即可 配置VSCode PicGo配置打开VSCode设置，搜索PicGo,首先找到Pic Bed：current，将其更换为aliyun 然后找到aliyun的配置，进行如下配置： 到此为止图床就已经全部配置完成了 快捷键PicGo默认上传快捷键如下：我们可以直接按下Ctrl+Alt+U直接从剪贴板复制图片，非常好用，当然也可以更改为自己更加方便的快捷键。","tags":[]},{"title":"如何利用网易云盘同步歌曲歌词","date":"2022-07-25T07:47:47.000Z","path":"2022/0762e9162.html","text":"起源：版权限制一个音乐软件很难拥有所有我们想要的歌曲来源，周杰伦的就只有咪咕有版权，如此一来，就要在各个软件之间切换，很不方便而利用网盘可以很好解决这一问题，以网易云举例 音频文件下载这个不难，直接面向百度,搜索下载即可 歌词文件解决了音频文件问题之后，很容易遇到的就是网盘收藏歌曲只有音频文件，没有歌词，而由于是本地文件，我们也无法从网络获取歌词，就像下面这样 在网易云云盘中上传歌曲时会自动识别是否有歌词文件，比如这样，我们将歌词文件（lrc文件）和歌曲文件放在同一个文件夹下，注意：这两个文件除了后缀，文件名要完全相同，然后转网易云网盘上传文件即可，如下图所示：然后，我们就可以拥有带歌词的网盘文件了，像这样： 制作lrc歌词文件面向百度一般的歌词文件都是lrc格式的，我们用记事本打开文件可以看到基本的歌曲信息，至于歌词就是下面的格式 [时间]歌词 这些歌词信息直接面向百度很轻易就可以获取 获取之后直接新建一个lrc文件，将歌词内容复制进去保存之后，上传到网易云即可 LRC Maker当然网络歌词文件并不一定和我们的音频文件匹配，同源的当然更好，不是同源的也没关系，推荐一个在线歌词编辑器LRC Maker 介绍很详细，我们首先添加音频文件 在上方的编辑界面可以直接编辑歌词，编辑完成之后，点击右上方第二个打轴选项，可以试听，并且对歌词进行微调 点击下方播放之后歌词会随着我们编辑的时间和音频文件进行滚动，并且上方也有时间定位，如果歌词时间有点误差（过快或过慢）都可以暂停进行微调 微调之后再次进入编辑界面导出lrc文件即可，注意音频文件一定要和歌词文件同名 这样我们就可以不用频繁的去切换软件了，甚是方便。","tags":[]},{"title":"LeetCode笔记-回溯","date":"2022-07-02T07:43:02.000Z","path":"2022/079716a2d4.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 回溯法回溯法也可以叫做回溯搜索法，它是一种搜索的方式。 回溯是递归的副产品，只要有递归就会有回溯。 本质上回溯就是穷举，穷举所有可能，然后找到答案，效率上并不高，如果想让回溯法高效一些，可以加一些剪枝(回溯可以归结为对于树的节点的操作，要遍历所有节点，当遍历到一个节点时，已经不符合设定条件，那么他的子树也必定不符合我们的预设条件，他的子节点就没有必要遍历了，这也在一定程度上减少了运算量)的操作，但即便这样也改不了回溯法就是穷举的本质。 回溯法解决的问题回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 另外，关于组合和排列： 组合是不强调元素顺序的，排列是强调元素顺序 例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。 如何理解回溯法回溯法解决的问题都可以抽象为树形结构 因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。 回溯法三部曲 回溯函数模板返回值以及参数 回溯算法中函数返回值一般为void 参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。 回溯函数伪代码如下： void backtracking(参数) 回溯函数终止条件 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。 所以回溯函数终止条件伪代码如下： if (终止条件) { 存放结果; return; } 回溯搜索的遍历过程 上面提到，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。 如图： 注意图中，特意举例集合大小和孩子的数量是相等的！ 回溯函数遍历过程伪代码如下： for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。 backtracking这里自己调用自己，实现递归。 从图中看出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。 分析完过程，回溯算法模板框架如下： void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 剪枝前面已经说过，剪枝就是减少一些遍历的节点，因此我们只需要控制递归的终止条件即可 LeetCode题目 77. 组合 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。示例:输入:&nbsp;n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 这是未经剪枝优化的代码 class Solution { private: vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件结果的集合 vector&lt;int&gt; path; // 用来存放符合条件结果 void backtracking(int n, int k, int startIndex) { if (path.size() == k) { result.push_back(path); return; } for (int i = startIndex; i &lt;= n; i++) { path.push_back(i); // 处理节点 backtracking(n, k, i + 1); // 递归 path.pop_back(); // 回溯，撤销处理的节点 } } public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { result.clear(); // 可以不写 path.clear(); // 可以不写 backtracking(n, k, 1); return result; } }; 容易知道当按顺序遍历到3为第一个数字时，已经没必要遍历下去了，因为4是最后一个数字，不能凑出两个数字的组合，但是由于判定条件，4依旧会被进行计算，这样就增加了计算量 for (int i = startIndex; i &lt;= n; i++) { path.push_back(i); backtracking(n, k, i + 1); path.pop_back(); } 这样减少的计算量或许没多少，换个例子，当n = 4，k = 4时，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。 本来四层for循环要经历3 + 2 + 1 + 1 = 7次计算，但是对for循环条件加以优化之后就变为了1次计算，效率大大提升，当然这个例子有点夸张，但是举这个例子目的就是说明确实可以提高效率。 这么说有点抽象，如图所示： 图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。 所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。 如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。 注意代码中i，就是for循环里选择的起始位置。 for (int i = startIndex; i &lt;= n; i++) { 接下来看一下优化过程如下： 已经选择的元素个数：path.size(); 还需要的元素个数为: k - path.size(); 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历,为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。 举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。 从2开始搜索都是合理的，可以是组合[2, 3, 4]。 所以优化之后的for循环是： for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置 优化后整体代码如下： class Solution { private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(int n, int k, int startIndex) { if (path.size() == k) { result.push_back(path); return; } for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) { // 优化的地方 path.push_back(i); // 处理节点 backtracking(n, k, i + 1); path.pop_back(); // 回溯，撤销处理的节点 } } public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { backtracking(n, k, 1); return result; } };","tags":[]},{"title":"LeetCode笔记-二叉树","date":"2022-06-17T11:07:45.000Z","path":"2022/0621aed2ac.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 树的基本知识 节点：包含一个数据元素及若干指向子树分支的信息 节点的度：一个节点拥有子树的数目称为节点的度 叶子节点：也称为终端节点，没有子树的节点或者度为零的节点 分支节点：也称为非终端节点，度不为零的节点称为非终端节点 树的度：树中所有节点的度的最大值 节点的层次：从根节点开始，假设根节点为第1层，根节点的子节点为第2层，依此类推，如果某一个节点位于第L层，则其子节点位于第L+1层 树的深度：也称为树的高度，树中所有节点的层次最大值称为树的深度 有序树：如果树中各棵子树的次序是有先后次序，则称该树为有序树 无序树：如果树中各棵子树的次序没有先后次序，则称该树为无序树 森林：由m（m≥0）棵互不相交的树构成一片森林。如果把一棵非空的树的根节点删除，则该树就变成了一片森林，森林中的树由原来根节点的各棵子树构成 树的基本性质 二叉树的第i层上至多有$2^(i-1)（i≥1）$个节点 深度为h的二叉树中至多含有$2^h - 1$个节点 若在任意一棵二叉树中，有$n_0$个叶子节点，有$n_2$个度为2的节点，则必有$n_0 = n_2 + 1$ 具有n个节点的满二叉树深为$log_2 (n + 1)$ 若对一棵有n个节点的完全二叉树进行顺序编号（1≤i≤n），那么，对于编号为i（i≥1）的节点： 当i=1时，该节点为根，它无双亲节点 当i&gt;1时，该节点的双亲节点的编号为$\\frac{i}{2}$ 若2i≤n，则有编号为2i的左节点，否则没有左节点 若2i+1≤n，则有编号为2i+1的右节点，否则没有右节点 二叉树二叉树的种类二叉树有两种主要的形式：满二叉树和完全二叉树。 满二叉树满二叉树： 如果一棵二叉树只有度 (简单理解为孩子节点个数)为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 如图所示： 这棵二叉树为满二叉树，也可以说深度 (就是有几层)为k，有$2^k - 1$个节点的二叉树，比如本图，4层，那么4层的满二叉树就有$2^4 - 1 = 15$个节点 完全二叉树 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 $1~&nbsp;2^(h-1)$ &nbsp;个节点。 优先级队列其实是一个堆，而堆就是一棵完全二叉树，同时保证父子节点的顺序关系。 二叉搜索树二叉搜索树是有数值的树，二叉搜索树是一个有序树，它有一下几条性质： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值 它的左、右子树也分别为二叉排序树 eg： 平衡二叉搜索树 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and&nbsp;Landis）树，且具有以下性质： 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。(递归定义) 如图： 最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。 C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是$log n$，而unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。 二叉树的存储方式 二叉树可以链式存储，也可以顺序存储 链式存储用指针， 顺序存储用数组。 顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。 链式存储如图： 顺序存储呢其实就是用数组来存储二叉树，顺序存储的方式如图： 用数组来存储二叉树如何遍历的呢？ 如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 但是用链式表示的二叉树，更有利于理解，所以一般都是用链式存储二叉树。 所以大家要了解，用数组依然可以表示二叉树。 二叉树的遍历方式二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历(层级遍历)：一层一层的去遍历。 这两种遍历是图论中最基本的两种遍历方式那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式： 深度优先遍历 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 广度优先遍历 层次遍历（迭代法） 这里前中后，其实指的就是中间节点的遍历顺序，只要记住 前中后序指的就是中间节点的位置就可以了。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。 而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 二叉树的代码实现C++代码如下： struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; 相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。 递归和迭代 在讲二叉树的遍历方式前，首先要搞明白递归和遍历的区别 递归（recursion）： 递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在函数定义中使用函数自身的方法。（A调用A） 迭代（iteration）： 重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B） 递归是一个树结构，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。 迭代是一个环结构，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。 理论上递归和迭代时间复杂度方面是一样的，但实际应用中（函数调用和函数调用堆栈的开销）递归比迭代效率要低。 二叉树的递归遍历(递归非常重要！！！) 一看就会，一写就废！ 首先要知道递归算法的三个要素： 确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件：写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 以下以前序遍历为例： 确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数里需要传入vector在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下： void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) 确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下： if (cur == NULL) return; 确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下： vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 单层递归的逻辑就是按照中左右的顺序来处理的，代码如下： class Solution { public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; traversal(root, result); return result; } }; 中序和后序代码如下： 中序遍历： void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // 左 vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;right, vec); // 右 } 后序遍历： void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) { if (cur == NULL) return; traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 vec.push_back(cur-&gt;val); // 中 } 二叉树的迭代遍历 听说还可以用非递归的方式 递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。 前序遍历（迭代法）前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。 为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。 动画如下： 不难写出如下代码: （注意代码中空节点不入栈） class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); // 右（空节点不入栈） if (node-&gt;left) st.push(node-&gt;left); // 左（空节点不入栈） } return result; } }; 中序遍历（迭代法） 注意：中序遍历不能像递归那样微调前序遍历的代码 在迭代的过程中，有两个操作： 处理：将元素放进result数组中 访问：遍历节点 分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。 那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。 那么在使用迭代法写中序遍历，我们就可以添加一个栈用来存放左孩子节点，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。 动画如下： 中序遍历，可以写出如下代码： class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-&gt;left; // 左 } else { cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-&gt;val); // 中 cur = cur-&gt;right; // 右 } } return result; } }; 后序遍历（迭代法） 数组部分更改前后顺序，要考虑向更改局部，然后整体反转这种思路能不能行的通 再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图： 所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下： class Solution { public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); result.push_back(node-&gt;val); if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈 } reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; } }; 二叉树的统一迭代法中序遍历代码如下：（详细注释）class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node != NULL) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node-&gt;right) st.push(node-&gt;right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node-&gt;left) st.push(node-&gt;left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.top(); // 重新取出栈中元素 st.pop(); result.push_back(node-&gt;val); // 加入到结果集 } } return result; } }; 同理，前序和后续只需要微调一下加入栈的顺序就可以了，我们利用根节点先把所有节点按照我们需要的遍历方法存储到栈里面，然后把需要特定顺序遍历的节点用NULL节点标记，即可实现迭代的统一写法。 迭代法前序遍历class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node != NULL) { st.pop(); if (node-&gt;right) st.push(node-&gt;right); // 右 if (node-&gt;left) st.push(node-&gt;left); // 左 st.push(node); // 中 st.push(NULL); } else { st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); } } return result; } }; 迭代法后序遍历class Solution { public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) { TreeNode* node = st.top(); if (node != NULL) { st.pop(); st.push(node); // 中 st.push(NULL); if (node-&gt;right) st.push(node-&gt;right); // 右 if (node-&gt;left) st.push(node-&gt;left); // 左 } else { st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); } } return result; } }; 二叉树的层序遍历层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。 需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; tmp; for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); tmp.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(tmp); } return result; } };","tags":[]},{"title":"C++中STL常用库函数","date":"2022-06-17T09:40:03.000Z","path":"2022/06b47eaf04.html","text":"总结下C++中STL常用函数 sort()快排函数原型：sort(起始地址, 末尾地址, cmp),其中cmp是可以自己定义的函数名,默认递增排列 cmp函数示例: bool cmp(int &amp;a, int &amp;b){ return a &gt; b; } reverse()逆置函数原型：reverse(起始地址, 末尾地址) stoi()函数原型:stoi(string类型)将string类型转换为int类型 unique()去重函数原型：unique(起始地址, 末尾地址, fun);其中fun为自定义的函数名。 注意：unique函数去重并不是真正的去重，它是不断的将后面不重复的元素覆盖前面重复的元素，最后返回最后一个不重复的元素的地址。 二分查找函数lower_bound(起始地址, 末尾地址, target)：查找第一个大于等于target目标值的位置 upper_bound(起始地址, 末尾地址, target)：查找第一个大于target目标值的位置 binary_search(起始地址, 末尾地址, target)：查找target是否存在于数组或vector中，找到返回true，否则返回false 字符串查找函数s1.find(s2)：在s1字符串中查找s2，查找到返回第一个字符的位置，查找失败返回s1.npos set.count(a)：本来是计算a出现的次数，但是由于集合中是没有重复元素的，于是count函数也就被作为查找函数了，因为a只能出现1次或者0次，查找成功，返回1；查找失败返回0. map.find()：主要用于查找key是否存在map中，不存在返回map.end()，用法和set一样 vector vector, 变长数组，倍增的思想 函数 功能 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() 访问第一个元素/最后一个元素 push_back()/pop_back() 插入/弹出最后一个元素 begin()/end() 开始元素迭代器/结尾元素迭代器 pair&lt;int, int&gt; 函数 功能 first 第一个元素 second 第二个元素 string，字符串 函数 功能 size()/length() 返回字符串长度 empty() 返回是否为空 clear() 清空 substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 queue, 队列 函数 功能 size() 返回队列长度 empty() 返回是否为空 push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue 优先队列，默认是大根堆 函数 功能 size() 返回队列长度 empty() 返回是否为空 push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式： priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; stack, 栈 函数 功能 size() 返回栈长度 empty() 返回是否为空 push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 函数 功能 size() 返回队列长度 empty() 返回是否为空 clear() 清空队列 front()/back() 返回队头元素 push_back()/pop_back() 插入/弹出最后一个元素 push_front()/pop_front() 插入/弹出第一个元素 begin()/end() 开始元素迭代器/结尾元素迭代器","tags":[{"name":"STL","slug":"STL","permalink":"https://kpl0111.github.io/blog/tags/STL/"},{"name":"C++","slug":"C","permalink":"https://kpl0111.github.io/blog/tags/C/"}]},{"title":"添加公式渲染功能","date":"2022-06-16T13:27:50.000Z","path":"2022/06c538da4.html","text":"主题添加公式渲染功能 本文以 Hexo 主题 one-paper (其他博客理论上都可以使用这种方法配置)为例，介绍如何添加对数学公式的显示支持。 配置过程安装渲染插件首先执行以下命令卸载掉hexo默认的渲染插件hexo-renderer-marked ，替换为hexo-renderer-markdown-it-plus 。 npm un hexo-renderer-marked --save npm i hexo-renderer-markdown-it-plus --save 修改文章模板修改hexo_root/scaffolds/post.md 文件，在末尾添加一行 math: true。 之后当你执行hexo new title生成一篇新的文章时，文章内部默认配置如下所示： 这样公式渲染默认是开启的，我们直接编写文章正文即可，如果想关闭数学公式支持，将true修改为false即可。 修改主题布局模板有以下两种选择： 阅读全文后启用支持编辑hexo_root/themes/landscape/layout/_partial/article.ejs ，在 &lt;/article&gt; (即article标签结束前)前加入一行代码，添加后效果如下： &lt;% if (!index &amp;&amp; post.math){ %&gt; &lt;script&gt; var assetsString = '&lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;' var pHead = document.getElementsByTagName('head')[0]; pHead.innerHTML = pHead.innerHTML + assetsString; &lt;/script&gt; &lt;% } %&gt; &lt;/article&gt; 故需将 &lt;!--more--&gt; 放在公式之前。 直接全部启用支持(推荐使用)编辑 hexo_root/themes/landscape/layout/_partial/head.ejs ，在 &lt;/head&gt; (即head标签结束前)前加入一行代码，添加后效果如下： &lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt; &lt;/head&gt; 编辑配置文件在根目录下配置站点配置文件 _config.yml，在最后面加入如下配置： markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight 测试效果整行$$sin^2\\theta + cos^2\\theta = 1$$ $$sin^2\\theta + cos^2\\theta = 1$$ 行内这是一个行内公式： $sin^2\\theta + cos^2\\theta = 1$ 效果：这是一个行内公式： $sin^2\\theta + cos^2\\theta = 1$ 数学公式测试$$ \\begin{aligned} f_Y(y) &amp; = f_X[h(y)]|h'(y)| \\\\[2ex] &amp; = f_X[h(y)]h'(y) \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{x}{\\theta}}[\\frac{dx}{dy}(-\\frac{\\theta}{ln(1-y)})] \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{-\\frac{\\theta}{ln(1-y)}}{\\theta}}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{ln(1-y)}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1-y}{\\theta}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = 1 \\end{aligned} \\tag{1} $$ 效果：$$\\begin{aligned}f_Y(y) &amp; = f_X[h(y)]|h’(y)| \\[2ex]&amp; = f_X[h(y)]h’(y) \\[2ex]&amp; = \\frac{1}{\\theta}e^{-\\frac{x}{\\theta}}[\\frac{dx}{dy}(-\\frac{\\theta}{ln(1-y)})] \\[2ex]&amp; = \\frac{1}{\\theta}e^{-\\frac{-\\frac{\\theta}{ln(1-y)}}{\\theta}}\\frac{\\theta}{1-y} \\[2ex]&amp; = \\frac{1}{\\theta}e^{ln(1-y)}\\frac{\\theta}{1-y} \\[2ex]&amp; = \\frac{1-y}{\\theta}\\frac{\\theta}{1-y} \\[2ex]&amp; = 1\\end{aligned}\\tag{1}$$ $$ \\frac{1}{\\sigma} \\tag{this is a test} $$ 效果：$$\\frac{1}{\\sigma}\\tag{this is a test}$$ Latex语法测试$$\\underline{给这条语句加一个下划线}$$ 效果：$$\\underline{给这条语句加一个下划线}$$ 参考：Hexo 博客启用对数学公式的支持","tags":[]},{"title":"公式渲染测试","date":"2022-06-16T13:16:17.000Z","path":"2022/06784dd132.html","text":"主题添加公式渲染功能，测试 整行： $$sin^2\\theta + cos^2\\theta = 1$$ $$sin^2\\theta + cos^2\\theta = 1$$ 行内： 这是一个行内公式： $sin^2\\theta + cos^2\\theta = 1$ 效果：这是一个行内公式： $sin^2\\theta + cos^2\\theta = 1$ 数学公式测试： $$ \\begin{aligned} f_Y(y) &amp; = f_X[h(y)]|h'(y)| \\\\[2ex] &amp; = f_X[h(y)]h'(y) \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{x}{\\theta}}[\\frac{dx}{dy}(-\\frac{\\theta}{ln(1-y)})] \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{-\\frac{-\\frac{\\theta}{ln(1-y)}}{\\theta}}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1}{\\theta}e^{ln(1-y)}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = \\frac{1-y}{\\theta}\\frac{\\theta}{1-y} \\\\[2ex] &amp; = 1 \\end{aligned} \\tag{1} $$ 效果：$$\\begin{aligned}f_Y(y) &amp; = f_X[h(y)]|h’(y)| \\[2ex]&amp; = f_X[h(y)]h’(y) \\[2ex]&amp; = \\frac{1}{\\theta}e^{-\\frac{x}{\\theta}}[\\frac{dx}{dy}(-\\frac{\\theta}{ln(1-y)})] \\[2ex]&amp; = \\frac{1}{\\theta}e^{-\\frac{-\\frac{\\theta}{ln(1-y)}}{\\theta}}\\frac{\\theta}{1-y} \\[2ex]&amp; = \\frac{1}{\\theta}e^{ln(1-y)}\\frac{\\theta}{1-y} \\[2ex]&amp; = \\frac{1-y}{\\theta}\\frac{\\theta}{1-y} \\[2ex]&amp; = 1\\end{aligned}\\tag{1}$$ $$ \\frac{1}{\\sigma} \\tag{this is a test} $$ 效果：$$\\frac{1}{\\sigma}\\tag{this is a test}$$ Latex语法测试： $$\\underline{给这条语句加一个下划线}$$ 效果：$$\\underline{给这条语句加一个下划线}$$","tags":[]},{"title":"LeetCode笔记-栈和队列","date":"2022-06-16T06:37:39.000Z","path":"2022/0638ccdfc.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 栈和队列不为人知的一面 栈是先进后出，队列是先进先出： 基础知识栈先进后出，提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。 栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。 所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。 那么问题来了，STL 中栈是用什么容器实现的？ 从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。 常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。 deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。 SGI STL中 队列底层实现缺省情况下一样使用deque实现的。 也可以指定vector为栈的底层实现，初始化语句如下： std::stack&lt;int, std::vector&lt;int&gt; &gt; third; // 使用vector为底层容器的栈 对应的队列的情况是一样的。 队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。 也可以指定list 为起底层实现，初始化queue的语句如下： std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列 所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。 用栈模拟实现队列class MyQueue { public: stack&lt;int&gt; stIn; stack&lt;int&gt; stOut; /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { stIn.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据） if (stOut.empty()) { // 从stIn导入数据直到stIn为空 while(!stIn.empty()) { stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } /** Get the front element. */ int peek() { int res = this-&gt;pop(); // 直接使用已有的pop函数 stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去 return res; } /** Returns whether the queue is empty. */ bool empty() { return stIn.empty() &amp;&amp; stOut.empty(); } }; 用队列模拟实现栈class MyStack { public: queue&lt;int&gt; que1; queue&lt;int&gt; que2; MyStack() { } void push(int x) { que1.push(x); } int pop() { if (!this-&gt;empty()) { while (que1.size() &gt; 1) { que2.push(que1.front()); que1.pop(); } int result = que1.front(); que1.pop(); while (!que2.empty()) { que1.push(que2.front()); que2.pop(); } return result; } return 0; } int top() { return que1.back(); } bool empty() { return que1.empty() &amp;&amp; que2.empty(); } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 有效括号问题class Solution { public: bool isValid(string s) { stack&lt;char&gt; sta; for (int i = 0; i &lt; s.size(); i++) { if (s[i] == '(') sta.push(')'); else if (s[i] == '[') sta.push(']'); else if (s[i] == '{') sta.push('}'); else if (sta.empty() || sta.top() != s[i]) return false; else sta.pop(); } return sta.empty(); } };","tags":[]},{"title":"LeetCode笔记-双指针大法","date":"2022-06-15T10:15:41.000Z","path":"2022/06c54e8d28.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 双指针法非常实用，但是他并不隶属于任何一种数据结构。 双指针法在数组原地反转，双重循环降低时间复杂度一般都有很好的效果。","tags":[]},{"title":"LeetCode笔记-字符串","date":"2022-06-15T10:15:24.000Z","path":"2022/063572401b.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 什么是字符串字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定。 在C语言中，把一个字符串存入一个数组时，也把结束符 ‘\\0’存入数组，并以此作为该字符串是否结束的标志。 例如这段代码： char a[5] = \"asd\"; for (int i = 0; a[i] != '\\0'; i++) { } 在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用’\\0’来判断是否结束。 例如这段代码: string a = \"asd\"; for (int i = 0; i &lt; a.size(); i++) { } 那么vector&lt; char &gt; 和 string 又有什么区别呢？ 其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。 所以想处理字符串，我们还是会定义一个string类型。 双指针法双指针法在数组，链表和字符串中很常用。其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。 KMPKMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 KMP的精髓所在就是前缀表 前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。 那么使用KMP可以解决两类经典问题： 匹配问题：28. 实现 strStr() 重复子串问题：459.重复的子字符串 再一次强调了什么是前缀，什么是后缀，什么又是最长相等前后缀。 前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。 后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。 然后针对前缀表到底要不要减一，这其实是不同KMP实现的方式，在KMP精讲 中针对之前两个问题，分别给出了两个不同版本的的KMP实现。 其中主要理解j=next[x]这一步最为关键！","tags":[]},{"title":"LeetCode笔记-KMP","date":"2022-06-13T13:30:27.000Z","path":"2022/06e8411ac8.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 字符串操作主要考虑格式的转换。 实现strStr()LeetCode题目链接 KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 KMP精讲文字版 KMP精讲视频 摘要构造next数组 next数组的本质就是前缀后缀相同的字符位数表实现方式常见的有减一、右移和保持不变三种，但是本质都是一样的，只在细微地方有区别，本文采用减一方式，其他方式代码详见前缀表（不减一）C++实现 我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下： void getNext(int* next, const string&amp; s) 构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步： 初始化 处理前后缀不相同的情况 处理前后缀相同的情况 接下来我们详解详解一下。 初始化：定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。 然后还要对next数组进行初始化赋值，如下： int j = -1; next[0] = j; j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。 next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j） 所以初始化next[0] = j 。 处理前后缀不相同的情况因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。 所以遍历模式串s的循环下标i 要从 1开始，代码如下： for (int i = 1; i &lt; s.size(); i++) { 如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。 怎么回退呢？ next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。 那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。 所以，处理前后缀不相同的情况代码如下： while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } 处理前后缀相同的情况如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。 代码如下： if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; 最后整体构建next数组的函数代码如下： void getNext(int* next, const string&amp; s){ int j = -1; next[0] = j; for(int i = 1; i &lt; s.size(); i++) { // 注意i从1开始 while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] } } 代码构造next数组的逻辑流程动画如下： 得到了next数组之后，就要用这个来做匹配了。 使用next数组来做匹配在文本串s里 找是否出现过模式串t。 定义两个下标j 指向模式串起始位置，i指向文本串起始位置。 那么j初始值依然为-1，为什么呢？ 依然因为next数组里记录的起始位置为-1。 i就从0开始，遍历文本串，代码如下： for (int i = 0; i &lt; s.size(); i++) 接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。 如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。 代码如下： while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) { j = next[j]; } 如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下： if (s[i] == t[j + 1]) { j++; // i的增加在for循环里 } 如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。 本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。 代码如下： if (j == (t.size() - 1) ) { return (i - t.size() + 1); } 那么使用next数组，用模式串匹配文本串的整体代码如下： int j = -1; // 因为next数组里记录的起始位置为-1 for (int i = 0; i &lt; s.size(); i++) { // 注意i就从0开始 while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t return (i - t.size() + 1); } } 此时所有逻辑的代码都已经写出来了，力扣 28.实现strStr 题目的整体代码如下： 前缀表统一减一 C++代码实现class Solution { public: void getNext(int* next, const string&amp; s) { int j = -1; next[0] = j; for(int i = 1; i &lt; s.size(); i++) { // 注意i从1开始 while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) { // 前后缀不相同了 j = next[j]; // 向前回退 } if (s[i] == s[j + 1]) { // 找到相同的前后缀 j++; } next[i] = j; // 将j（前缀的长度）赋给next[i] } } int strStr(string haystack, string needle) { if (needle.size() == 0) { return 0; } int next[needle.size()]; getNext(next, needle); int j = -1; // // 因为next数组里记录的起始位置为-1 for (int i = 0; i &lt; haystack.size(); i++) { // 注意i就从0开始 while(j &gt;= 0 &amp;&amp; haystack[i] != needle[j + 1]) { // 不匹配 j = next[j]; // j 寻找之前匹配的位置 } if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动 j++; // i的增加在for循环里 } if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t return (i - needle.size() + 1); } } return -1; } };","tags":[]},{"title":"LeetCode笔记-哈希表","date":"2022-06-12T10:19:48.000Z","path":"2022/064cfc9b66.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 哈希表 哈希表是根据关键码的值而直接进行访问的数据结构。一般哈希表都是用来快速判断一个元素是否出现在集合里。 哈希碰撞两个元素同时映射到哈希表中同一位置，这一现象叫做哈希碰撞，如下例： 一般处理方法有两种，拉链法和线性探测法。 拉链法其实拉链法就是要选择合适的哈希表大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间 线性探测法使用线性探测法，一定要保证tablesize大于datasize，需要依靠哈希表中的空位来解决碰撞问题。 常见的三种哈希结构当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。 数组 set （集合） map(映射) 在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示： std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。 std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。 那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。 三种数据结构的选择 数据量给定而且没有太大需求的可以直接选择数组。 数据量未知而且如果哈希值比较少、特别分散、跨度非常大，使用set，使用数组就造成空间的极大浪费 直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的，所以可以用数组的优先选择数组 map是采用了key-value的方式，一般可以用来保存一一对应的键值对","tags":[]},{"title":"LeetCode笔记-链表","date":"2022-06-12T10:19:16.000Z","path":"2022/064d5af563.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 链表链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链接的入口节点称为链表的头结点也就是head。 双链表： 循环链表：循环链表可用来解决约瑟夫环问题 链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。 // 单链表 struct ListNode { int val; // 节点上存储的元素 ListNode *next; // 指向下一个节点的指针 // ListNode *prev; //指向前一个元素 双链表，记得构造函数初始化 ListNode(int x) : val(x), next(NULL) {} // 节点的构造函数 }; 性能分析 插入/删除 查询 适用场景 数组 O(n) O(1) 数据量固定，频繁查询，较少增删 链表 O(1) O(n) 数据量不固定，频繁增删，较少查询 单链表的删除操作一般有两类： 设置虚拟头，将头节点当作普通节点处理，最后在删除虚拟头 头节点和其他节点分开处理 Pyhton、Java等语言可以自动释放内存，C++记得要手动释放内存节约空间。 C++示例class MyLinkedList { public: // 定义链表节点结构体 struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; // 初始化链表 MyLinkedList() { _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点 _size = 0; } // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点 int get(int index) { if (index &gt; (_size - 1) || index &lt; 0) { return -1; } LinkedNode* cur = _dummyHead-&gt;next; while(index--){ // 如果--index 就会陷入死循环 cur = cur-&gt;next; } return cur-&gt;val; } // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点 void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-&gt;next = _dummyHead-&gt;next; _dummyHead-&gt;next = newNode; _size++; } // 在链表最后面添加一个节点 void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(cur-&gt;next != nullptr){ cur = cur-&gt;next; } cur-&gt;next = newNode; _size++; } // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。 // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点 // 如果index大于链表的长度，则返回空 void addAtIndex(int index, int val) { if (index &gt; _size) { return; } LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = _dummyHead; while(index--) { cur = cur-&gt;next; } newNode-&gt;next = cur-&gt;next; cur-&gt;next = newNode; _size++; } // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的 void deleteAtIndex(int index) { if (index &gt;= _size || index &lt; 0) { return; } LinkedNode* cur = _dummyHead; while(index--) { cur = cur -&gt;next; } LinkedNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; _size--; } // 打印链表 void printLinkedList() { LinkedNode* cur = _dummyHead; while (cur-&gt;next != nullptr) { cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; \" \"; cur = cur-&gt;next; } cout &lt;&lt; endl; } private: int _size; LinkedNode* _dummyHead; }; 关于环形链表和入口问题链表是否存在环可以用双指针快速判定，fast每次移动两个节点，slow一个节点，如果相遇（即fast == slow），则必定存在环 环的入口可以这样求：在相遇位置设置tmp1，在链表头结点处设置tmp2，每次走一个节点，相遇位置即为环入口节点 理论比较简单，详细可参见链表：环找到了，那入口呢？,dalao写的非常详细","tags":[]},{"title":"智能电灯","date":"2022-06-03T02:53:20.000Z","path":"2022/06373cfef8.html","text":"ESP8266实现智能电灯本实验目的是要通过腾讯云服务器和ESP8266芯片实现远程操纵一个LED灯的颜色和亮度 实验原理首先在腾讯云物联网开发平台注册一个项目，并设置一个电灯产品，采用Wifi通信，然后在芯片上编写代码实现对LED灯的控制以及对信号的接收，然后用腾讯云配套小程序即可实现远程控制。 实验步骤 使用一根提供USB数据线将NodeMCU开发板和电脑连接起来，在命令行执行指令pip install esptool,然后执行esptool read_mac·查看开发板信息图中红框内即为使用的接口，如果缺少驱动可以通过驱动精灵下载 烧录固件，首先执行esptool --port COM9 erase_flash擦除flash芯片，接口名称要更换为自己的设备名称，然后执行esptool --port COM9 write_flash --flash_size=detect 0 esp8266-20220117-v1.18.bin重新烧录固件,之后重启即可 在腾讯云物联网开发平台注册一个项目，命名为智能家居 进入项目创建一个新产品’智能电灯’，设置几个参数 产品品类：直接选择“智能生活”–&gt;“电工照明”–&gt;“灯” 认证方式：选择密钥认证，这个比较简单，而且适合我们的开发板 NodeMCU。 通信方式：选择 Wi-Fi。 数据协议：选择物模型来解析数据。 设置完成后其他默认配置就可以，这样即可生成一个新产品，之后再测试设备列表里面可以查看我们的设备信息记录下设备名称、设备密钥、和产品ID，然后在调试标签页点击下图中二维码然后利用腾讯连连小程序添加该设备即可 代码部分我们需要将产品信息的三元组和利用password生成器生成的Username和Password替换main文件里面对应部分，并完善Button.py和LED.py文件实现NodeMCU开发板引脚和LED灯的绑定 实现远程控制需要在 NodeMCU 开发板上安装一个 MQTT 客户端代码库 umqtt.simple 库。它来自MicroPython 官方维护的非内核标准库 micropython-lib 使用Putty，协议选择Serial，频率设置为115200,流控制选择None即可使用Putty来连接开发板，执行以下指令连接WiFi并安装库 import network wifi = network.WLAN(network.STA_IF) wifi.active(True) wifi.scan() #扫描WIFI列表 wifi.isconnected() #查看当前连接状态，理论上应该是False wifi.connect('Wi-Fi的SSID', 'Wi-Fi密码') # 连接对应WiFi wifi.isconnected() #再次查看状态，应该是True import upip upip.install('micropython-umqtt.simple') 烧写代码，执行ampy --port COM9 --baud 115200 --delay 0.5 put main.py烧写main文件,同样方式烧写其他三个文件，烧写完成之后重启即可实现远程控制 按照下图连接LED灯和开发板要注意面包板的正负极，连接好如下图所示 打开小程序即可操控LED灯 演示见演示视频Esp8266.mp4 Esp32实现光照传感器原理因为光照传感器设备的部署位置比较灵活，不太可能像智能电灯一样连接房间里的电源线，所以我们要用一种比 Wi-Fi 功耗更低的通信技术。这样的话，就算使用电池供电，也可以长时间（一年以上）持续工作。因此选择 BLE 低功耗蓝牙技术。 BLE 设备可以在 4 种模式下工作： 广播模式（Broadcaster），这里特指单纯的广播模式。这种模式下设备不可以被连接，只能够以一定的时间间隔把数据广播出来，供其他设备使用，比如手机扫描处理。蓝牙 Beacon 设备就是工作在这种模式。 从机模式（Peripheral），这种模式下设备仍然可以广播数据，同时也可以被连接。建立连接后，双方可以进行双向通信。比如你用手机连接一个具有蓝牙功能的体温计，这时体温计就是从机（Peripheral）。 主机模式（Central），这种模式下设备不进行广播，但是可以扫描周围的蓝牙广播包，发现其他设备，然后主动对这些设备发起连接。还是刚才那个例子，主动连接蓝牙体温计的手机就是主机（Central）角色。 观察者模式（Observer），这种模式下设备像主机模式一样，也不进行广播，而是扫描周围的蓝牙广播包，但是不同的地方是，它不会与从机设备建立连接。一般收集蓝牙设备广播包的网关就是在这种模式下工作的，它会将收集的广播数据通过网线、Wi-Fi 或者 4G 等蜂窝网络上传到云平台。 实验步骤 用面包板连接NodeMCU和感光元件，如下图所示： 基于 PT550 环保型光敏二极管的光照传感器元器件，它的灵敏度更高，测量范围是 0Lux～6000Lux。这个元器件通过信号管脚输出模拟量，我们读取 NodeMCU ESP32 的 ADC 模数转换器（ADC0，对应GPIO36）的数值，就可以得到光照强度。这个数值越大，表示光照强度越大。因为 ADC 支持的最大位数是 12bit，所以这个数值范围是 0~4095 之间。这里我们粗略地按照线性关系做一个转换,代码如下： class LightSensor(): def __init__(self, pin): self.light = ADC(Pin(pin)) def value(self): value = self.light.read() print(\"Light ADC value:\",value) return int(value / 4095 * 6000) 和Esp8266一样，擦除固件，然后重装固件，将补充好的代码文件写入开发板 esptool --chip esp32 --port COM9 erase_flash #擦除固件 esptool --chip esp32 --port COM9 write_flash -z 0x1000 esp32-20220117-v1.18.bin #烧写固件 验证光照传感器使用nRF Connect，扫描到开发板如下： Esp32的网关实现NodeMCU ESP32 开发板是蓝牙设备，本身无法直接联网上报数据，因此需要借助网关来实现联网的目的。 网关的主要功能是协议转换，一方面它需要接收低功耗蓝牙技术的光照传感器的广播数据，另一方面，它需要把解析的数据上传到云平台：配置完虚拟机环境之后，虚拟机即充当了树莓派的作用 在腾讯云物联网开发平台同样按照上述方式配置一个Lightsensor_1部件，把光照值在智能联动配置里面设置为联动值，后面要用到光照值为灯泡提供光照数据，记录下三元组。 接下来补充gateway.py缺失部分代码，把三元组替换为我们的生成的三元组以及username和password,中间光照的loop函数调用bles成员函数读取扫描到的光照强度数值并上传扫描到的光照强度数值，代码如下： 部署接下来就是可以让程序作为后台服务运行，首先打开虚拟机，执行以下几条命令,为虚拟机增添Pi Gateway服务 $ sudo cp /home/pi/pi-gateway/pi-gateway.service /etc/systemd/system/ $ sudo systemctl daemon-reload $ sudo systemctl start pi-gateway $ sudo systemctl status pi-gateway $ sudo systemctl enable pi-gateway 执行之后，网关程序就在虚拟机上运行起来了，在腾讯云平台上可以看到，光照传感器变为在线状态。 设置场景联动我们希望实现的联动场景是，基于环境的光照强度自动控制电灯的开和关。具体来说，这个目标可以拆解为 3 个自动触发任务： 当光照强度大于 1024Lux 时，关闭电灯。 当光照强度小于 1024Lux 时，打开电灯。 至于光照强度等于 1024Lux 时，也打开电灯。 在腾讯连连小程序上面添加上述三个场景 源代码智能电灯# main.py from LED import Led from Button import Button from Relay import Relay import time import uasyncio import network import ujson from umqtt.simple import MQTTClient \"\"\" Wi-Fi Gateway : SSID and Password \"\"\" WIFI_AP_SSID = \"Xiaomi_301\" WIFI_AP_PSW = \"76780211\" \"\"\" QCloud Device Info \"\"\" DEVICE_NAME = \"Led_1\" PRODUCT_ID = \"XICW4V8C51\" DEVICE_KEY = \"sBgj/K/mb+/F01FYk5IJcw==\" \"\"\" MQTT topic \"\"\" MQTT_CONTROL_TOPIC = \"$thing/down/property/\"+PRODUCT_ID+\"/\"+DEVICE_NAME MQTT_CONTROL_REPLY_TOPIC = \"$thing/up/property/\"+PRODUCT_ID+\"/\"+DEVICE_NAME led = Led(5, 4, 0) relay = Relay(16) button = Button(14) mqtt_client = None color = 0 #enum 0=red, 1=green, 2=blue name= \"\" #light name. it is optional brightness = 100 # 0%~100% light_changed = False async def wifi_connect(ssid, pwd): sta = network.WLAN(network.STA_IF) sta.active(True) sta.connect(ssid, pwd) while not sta.isconnected(): print(\"Wi-Fi Connecting...\") time.sleep_ms(500) def mqtt_callback(topic, msg): global led, relay, button global color, name, brightness, light_changed print((topic, msg)) msg_json = ujson.loads(msg) if msg_json['method'] == 'control': params = msg_json['params'] power_switch_tmp = params.get('power_switch') if power_switch_tmp is not None: power_switch = power_switch_tmp relay.set_state(power_switch) brightness_tmp = params.get('brightness') if brightness_tmp is not None: brightness = brightness_tmp color_tmp = params.get('color') if color_tmp is not None: color = color_tmp name_tmp = params.get('name') if name_tmp is not None: name = name_tmp if brightness_tmp is not None or color_tmp is not None: light_changed = True async def mqtt_connect(): global mqtt_client MQTT_SERVER = PRODUCT_ID + \".iotcloud.tencentdevices.com\" MQTT_PORT = 1883 MQTT_CLIENT_ID = PRODUCT_ID+DEVICE_NAME MQTT_USER_NAME = \"XICW4V8C51Led_1;12010126;DUQ2I;1655185098\" MQTTT_PASSWORD = \"c8e0d3a2c3b568091747e5eba7de4a6edb6280dd20d1dade64efa6debd3492cd;hmacsha256\" mqtt_client = MQTTClient(MQTT_CLIENT_ID, MQTT_SERVER, MQTT_PORT,MQTT_USER_NAME, MQTTT_PASSWORD, 60) mqtt_client.set_callback(mqtt_callback) mqtt_client.connect() def mqtt_report(client, color, name, switch, brightness): msg = { \"method\": \"report\", \"clientToken\": \"clientToken-2444532211\", \"params\": { \"color\": color, \"color_temp\": 0, \"name\": name, \"power_switch\": switch, \"brightness\": brightness } } client.publish(MQTT_CONTROL_REPLY_TOPIC.encode(), ujson.dumps(msg).encode()) async def light_loop(): global led, relay, button global color, name, brightness, light_changed switch_status_last = 1 LED_status = 0 color = 2 #blue brightness = 100 #here 100% == 1 led.rgb_light(0, 0, 255, brightness/100.0) # 该循环为测试LED等的开闭循环 # while True: # relay.set_on() # await uasyncio.sleep_ms(2000) # relay.set_off() # await uasyncio.sleep_ms(2000) time_cnt = 0 mqtt_client.subscribe(MQTT_CONTROL_TOPIC.encode()) while True: mqtt_client.check_msg() switch_status = button.state() LED_status = relay.state() if switch_status != switch_status_last: if switch_status == 0 and switch_status_last == 1: LED_status = 0 if LED_status else 1 relay.set_state(LED_status) switch_status_last = switch_status if light_changed: light_changed = False led.rgb_light(255 if color==0 else 0, 255 if color==1 else 0, 255 if color==2 else 0, brightness/100.0) # 调整为0.02*100=2秒上报一次 if time_cnt &gt;= 100: mqtt_report(mqtt_client, color, name, LED_status, brightness) time_cnt = 0 time_cnt = time_cnt+1 await uasyncio.sleep_ms(20)# 时间间隔最好别超过50ms，否则按钮按下时间在休眠期间的话会无效，导致按钮很不好操作 async def main(): global mqtt_client # Wi-Fi connection try: await uasyncio.wait_for(wifi_connect(WIFI_AP_SSID, WIFI_AP_PSW), 20) except uasyncio.TimeoutError: print(\"wifi connected timeout!\") # MQTT connection try: await uasyncio.wait_for(mqtt_connect(), 20) except uasyncio.TimeoutError: print(\"mqtt connected timeout!\") await uasyncio.gather(light_loop()) uasyncio.run(main()) # Relay.py from machine import ADC from machine import Pin, Signal class Relay(): def __init__(self, pin): self.relaypin = Pin(pin, Pin.OUT) self.relayled = Signal(self.relaypin, invert=True) # 将信号置反, 实现开与关和输入信号对应 #self.last_status = 1 def set_state(self, state): self.relayled.value(state) #self.relaypin.value(state) #self.last_status = state def set_on(self): #self.relaypin.on() value: 1 but light is off self.relayled.value(1) print('Relay on value: ' + str(self.relayled.value())) def set_off(self): # self.relaypin.off() value: 0 but light is on self.relayled.value(0) print('Relay off value: ' + str(self.relayled.value())) def state(self): return self.relayled.value() #LED.py from machine import PWM from machine import Pin class Led(): \"\"\" 创建LED类 \"\"\" def __init__(self, rpin, gpin, bpin, sfreq=1000): \"\"\" 构造函数 :param pin: 接LED的管脚，必须支持PWM :param freq: PWM的默认频率是1000 \"\"\" #以rpin, gpin, bpin为参数，使用Pin和PWM来绑定三个引脚来控制led灯的红黄蓝的三个PWM信号 self.led_red = PWM(Pin(rpin), freq = sfreq) self.led_green = PWM(Pin(gpin), freq = sfreq) self.led_blue = PWM(Pin(bpin), freq = sfreq) def rgb_light(self, red, green, blue, brightness): #red green blue的范围在range(256)内，brightness的范围在[0,1]内，如果取值不在正确范围内，什么也不做 #调用duty成员函数来设置三种颜色的占空比 if brightness &gt;= 0 and brightness &lt;= 1: if red in range(256): self.led_red.duty(int(red/255*brightness*1023)) if green in range(256): self.led_green.duty(int(green/255*brightness*1023)) if blue in range(256): self.led_blue.duty(int(blue/255*brightness*1023)) def deinit(self): \"\"\" 析构函数 \"\"\" self.led_red.deinit() self.led_green.deinit() self.led_blue.deinit() # Button.py from machine import ADC from machine import Pin class Button(): def __init__(self, pin): self.button = Pin(pin, Pin.IN) def state(self): return self.button.value() 光照传感器# main.py from ble_lightsensor import BLELightSensor from lightsensor import LightSensor import time import bluetooth def main(): ble = bluetooth.BLE() ble.active(True) ble_light = BLELightSensor(ble) light = LightSensor(36) light_density = light.value() i = 0 while True: # Write every second, notify every 10 seconds. i = (i + 1) % 10 ble_light.set_light(light_density, notify=i == 0) print(\"Light Lux:\", light_density) light_density = light.value() time.sleep_ms(1000) if __name__ == \"__main__\": main() # ble_advertising.py # Helpers for generating BLE advertising payloads. from micropython import const import struct import bluetooth # Advertising payloads are repeated packets of the following form: # 1 byte data length (N + 1) # 1 byte type (see constants below) # N bytes type-specific data _ADV_TYPE_FLAGS = const(0x01) _ADV_TYPE_NAME = const(0x09) _ADV_TYPE_UUID16_COMPLETE = const(0x3) _ADV_TYPE_UUID32_COMPLETE = const(0x5) _ADV_TYPE_UUID128_COMPLETE = const(0x7) _ADV_TYPE_UUID16_MORE = const(0x2) _ADV_TYPE_UUID32_MORE = const(0x4) _ADV_TYPE_UUID128_MORE = const(0x6) _ADV_TYPE_APPEARANCE = const(0x19) _ADV_TYPE_SERVICE_DATA = const(0x16) # Generate a payload to be passed to gap_advertise(adv_data=...). def advertising_payload(limited_disc=False, br_edr=False, name=None, services=None, appearance=0, service_data = None): payload = bytearray() def _append(adv_type, value): nonlocal payload payload += struct.pack(\"BB\", len(value) + 1, adv_type) + value _append( _ADV_TYPE_FLAGS, struct.pack(\"B\", (0x01 if limited_disc else 0x02) + (0x18 if br_edr else 0x04)), ) if name: _append(_ADV_TYPE_NAME, name) if services: for uuid in services: b = bytes(uuid) if len(b) == 2: _append(_ADV_TYPE_UUID16_COMPLETE, b) elif len(b) == 4: _append(_ADV_TYPE_UUID32_COMPLETE, b) elif len(b) == 16: _append(_ADV_TYPE_UUID128_COMPLETE, b) # See org.bluetooth.characteristic.gap.appearance.xml if appearance: _append(_ADV_TYPE_APPEARANCE, struct.pack(\"&lt;h\", appearance)) if service_data: _append(_ADV_TYPE_SERVICE_DATA, service_data) return payload def decode_field(payload, adv_type): i = 0 result = [] while i + 1 &lt; len(payload): if payload[i + 1] == adv_type: result.append(payload[i + 2 : i + payload[i] + 1]) i += 1 + payload[i] return result def decode_name(payload): n = decode_field(payload, _ADV_TYPE_NAME) return str(n[0], \"utf-8\") if n else \"\" def decode_services(payload): services = [] for u in decode_field(payload, _ADV_TYPE_UUID16_COMPLETE): services.append(bluetooth.UUID(struct.unpack(\"&lt;h\", u)[0])) for u in decode_field(payload, _ADV_TYPE_UUID32_COMPLETE): services.append(bluetooth.UUID(struct.unpack(\"&lt;d\", u)[0])) for u in decode_field(payload, _ADV_TYPE_UUID128_COMPLETE): services.append(bluetooth.UUID(u)) return services def demo(): payload = advertising_payload( name=\"micropython\", services=[bluetooth.UUID(0x181A), bluetooth.UUID(\"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\")], ) print(payload) print(decode_name(payload)) print(decode_services(payload)) if __name__ == \"__main__\": demo() # ble_lightsensor.py import bluetooth import struct import time from ble_advertising import advertising_payload from micropython import const _IRQ_CENTRAL_CONNECT = const(1) _IRQ_CENTRAL_DISCONNECT = const(2) _IRQ_GATTS_INDICATE_DONE = const(20) _FLAG_READ = const(0x0002) _FLAG_NOTIFY = const(0x0010) _ADV_SERVICE_DATA_UUID = 0xFE95 _SERVICE_UUID_ENV_SENSE = 0x181A _CHAR_UUID_AMBIENT_LIGHT = 'FEC66B35-937E-4938-9F8D-6E44BBD533EE' # Service environmental sensing _ENV_SENSE_UUID = bluetooth.UUID(_SERVICE_UUID_ENV_SENSE) # Characteristic ambient light density _AMBIENT_LIGHT_CHAR = ( bluetooth.UUID(_CHAR_UUID_AMBIENT_LIGHT), _FLAG_READ | _FLAG_NOTIFY , ) _ENV_SENSE_SERVICE = ( _ENV_SENSE_UUID, (_AMBIENT_LIGHT_CHAR,), ) # https://specificationrefs.bluetooth.com/assigned-values/Appearance%20Values.pdf _ADV_APPEARANCE_GENERIC_AMBIENT_LIGHT = const(1344) class BLELightSensor: def __init__(self, ble, name='Nodemcu'): self._ble = ble self._ble.active(True) self._ble.irq(self._irq) ((self._handle,),) = self._ble.gatts_register_services((_ENV_SENSE_SERVICE,)) self._connections = set() time.sleep_ms(500) self._payload = advertising_payload( name=name, services=[_ENV_SENSE_UUID], appearance=_ADV_APPEARANCE_GENERIC_AMBIENT_LIGHT ) self._sd_adv = None self._advertise() def _irq(self, event, data): # Track connections so we can send notifications. if event == _IRQ_CENTRAL_CONNECT: conn_handle, _, _ = data self._connections.add(conn_handle) elif event == _IRQ_CENTRAL_DISCONNECT: conn_handle, _, _ = data self._connections.remove(conn_handle) # Start advertising again to allow a new connection. self._advertise() elif event == _IRQ_GATTS_INDICATE_DONE: conn_handle, value_handle, status = data def set_light(self, light_den, notify=False): self._ble.gatts_write(self._handle, struct.pack(\"!h\", int(light_den))) self._sd_adv = self.build_mi_sdadv(light_den) self._advertise() if notify: for conn_handle in self._connections: if notify: # Notify connected centrals. self._ble.gatts_notify(conn_handle, self._handle) def build_mi_sdadv(self, density): uuid = 0xFE95 fc = 0x0010 pid = 0x0002 fcnt = 0x01 mac = self._ble.config('mac') objid = 0x1007 objlen = 0x03 objval = density #service_data = struct.pack(\"&lt;3HB\",uuid,fc,pid,fcnt)+mac+struct.pack(\"&lt;H2BH\",objid,objlen,0,objval) #mac获取得到的是一个tuple对象 ex: (0, b'4\\\\x86]\\\\xb6\\\\xeb\\\\x0e'), 取第二个 service_data = struct.pack(\"&lt;3HB\",uuid,fc,pid,fcnt)+mac[1]+struct.pack(\"&lt;H2BH\",objid,objlen,0,objval) print(\"Service Data:\",service_data) return advertising_payload(service_data=service_data) def _advertise(self, interval_us=500000): self._ble.gap_advertise(interval_us, adv_data=self._payload) time.sleep_ms(100) print(\"sd_adv\",self._sd_adv) if self._sd_adv is not None: print(\"sdddd_adv\",self._sd_adv) self._ble.gap_advertise(interval_us, adv_data=self._sd_adv) # lightsensor.py from machine import ADC from machine import Pin class LightSensor(): def __init__(self, pin): self.light = ADC(Pin(pin)) def value(self): value = self.light.read() print(\"Light ADC value:\",value) return int(value / 4095 * 6000) esp32的网关实现# blescan.py import time from threading import Thread from interruptingcow import timeout from bluepy.btle import DefaultDelegate, Peripheral, Scanner, UUID, capitaliseName, BTLEInternalError from bluepy.btle import BTLEDisconnectError, BTLEManagementError, BTLEGattError class LightScanner(): SCAN_TIMEOUT = 5 def __init__(self, name): self._name = name def status_update(self): results = self._get_data() # messages = [ # MqttMessage( # topic=self.format_topic(\"property/light\"), # payload=results.lightlevel, # ) # ] return results def _get_data(self): \"\"\" 获取光照强度数据，并对超时异常进行处理 \"\"\" scan_processor = ScanProcessor(self._name) scanner = Scanner().withDelegate(scan_processor) scanner.scan(self.SCAN_TIMEOUT, passive=True) with timeout( self.SCAN_TIMEOUT, exception=Exception( \"Retrieving data from {} device {} timed out after {} seconds\".format( repr(self), self._name, self.SCAN_TIMEOUT ) ), ): while not scan_processor.ready: time.sleep(1) return scan_processor.results return scan_processor.results class ScanProcessor: ADV_TYPE_SERVICE_DATA = 0x16 #设置数据格式为十六进制 def __init__(self, name): self._ready = False self._name = name self._results = MiBeaconData() def handleDiscovery(self, dev, isNewDev, _): is_nodemcu = False if isNewDev: for (adtype, desc, value) in dev.getScanData(): #Service Data UUID == 0xFE95 according to MiBeacon if adtype == self.ADV_TYPE_SERVICE_DATA and value.startswith(\"95fe\"): print(\"FOUND service Data:\",adtype, desc, value) #Object ID == 0x1007 according to MiBeacon if len(value) == 38 and value[26:30] == '0710': light_den = int((value[-2:] + value[-4:-2]), 16) mac = value[14:26] self._results.lightlevel = light_den self._results.mac = mac self.ready = True @property def mac(self): return self._mac @property def ready(self): return self._ready @ready.setter def ready(self, var): self._ready = var @property def results(self): return self._results class MiBeaconData: def __init__(self): self._lightlevel = None self._mac = None @property def lightlevel(self): return self._lightlevel @lightlevel.setter def lightlevel(self, var): self._lightlevel = var @property def mac(self): return self._mac @mac.setter def mac(self, var): self._mac = var # gateway.py from blescan import LightScanner, MiBeaconData import time import asyncio import json import uuid import paho.mqtt.client as MQTTClient \"\"\" QCloud Device Info \"\"\" DEVICE_NAME = \"Lightsensor_1\" PRODUCT_ID = \"X2OQT7NRTP\" DEVICE_KEY = \"h0ftJ153maTi6jJWg9KCQA==\" \"\"\" MQTT topic \"\"\" MQTT_CONTROL_TOPIC = \"$thing/down/property/\"+PRODUCT_ID+\"/\"+DEVICE_NAME MQTT_CONTROL_REPLY_TOPIC = \"$thing/up/property/\"+PRODUCT_ID+\"/\"+DEVICE_NAME def mqtt_callback(client, userdata, msg): # Callback # print(f\"Received `{msg.payload.decode()}` from `{msg.topic}` topic\") return async def mqtt_connect(): #connect callback def on_connect(client, userdata, flags, rc): if rc == 0: print(\"Connected to MQTT Broker!\") else: print(\"Failed to connect, return code %d\\n\", rc) mqtt_client = None MQTT_SERVER = PRODUCT_ID + \".iotcloud.tencentdevices.com\" MQTT_PORT = 1883 MQTT_CLIENT_ID = PRODUCT_ID+DEVICE_NAME MQTT_USER_NAME = \"X2OQT7NRTPLightsensor_1;12010126;DTXFZ;1655263739\" MQTTT_PASSWORD = \"c02c6980d125f3846de11e1ab1d256f864e78f7377d2d4f94d992c5703a056c1;hmacsha256\" mqtt_client = MQTTClient.Client(MQTT_CLIENT_ID) mqtt_client.username_pw_set(MQTT_USER_NAME, MQTTT_PASSWORD) mqtt_client.on_connect = on_connect mqtt_client.connect(MQTT_SERVER, MQTT_PORT, 60) return mqtt_client def mqtt_report(client, light_level): client_token = \"clientToken-\" + str(uuid.uuid4()) msg = { \"method\": \"report\", \"clientToken\": client_token, \"params\": { \"Illuminance\": light_level } } client.publish(MQTT_CONTROL_REPLY_TOPIC, json.dumps(msg)) async def light_loop(mclient): bles = LightScanner('Nodemcu') mclient.subscribe(MQTT_CONTROL_TOPIC) mclient.on_message = mqtt_callback mclient.loop_start() while True: try: #调用bles成员函数读取扫描到的光照强度数值 data = bles._get_data() except Exception as e: print(\"BLE SCAN error:\", e) continue #上传扫描到的光照强度数值 mqtt_report(mclient, data) await time.sleep(0.3) async def main(): mqtt_client = None # MQTT connection try: mqtt_client = await asyncio.wait_for(mqtt_connect(), 20) except asyncio.TimeoutError: print(\"mqtt connected timeout!\") if mqtt_client is not None: await asyncio.gather(light_loop(mqtt_client)) asyncio.get_event_loop().run_until_complete(main())","tags":[]},{"title":"C++中string、char *、char[]、const char*的转换","date":"2022-06-02T14:49:17.000Z","path":"2022/066dcc5737.html","text":"在C++中string、const char、 char 、char[]四者类型经常会需要转化。 转化方法 char*转string：可以直接赋值。 char[]转string：可以直接赋值。 char*转char[]：不能直接赋值，可以循环char*字符串逐个字符赋值,也可以使用strcpy_s等函数。 string转char[]:不能直接赋值，可以循环char*字符串逐个字符赋值,也可以使用strcpy_s等函数 string转char*:调用string对象的c_str函数或data函数或copy函数。 char[]转char*:直接赋值即可。使用时，要对源格式和目标格式进行初始化。源格式赋值为具体的内容，目标格式赋值为空。 总结如下：A. 变成string,直接赋值。B. char[]变成别的，直接赋值。C. char*变const char*容易，const char*变char*麻烦。&lt;char*&gt;(const char*);D. string变char*要通过const char*中转。E. 变成char[]。string逐个赋值，char* const char* strncpy_s() C和C++中char和string区别在C语言中，string 是定义一个字符串，存储的是一段如“abcd”的数据，而且最后还有一个结束符’\\0’; char 是定义一个字符，存储一个字符，占一个字节。 在C++中，string有两种，一种是字符串char[]，另外一种是封装好的字符串类，要区别理解。例如’a’是char, “a”是char string，这两者都是普通的字符和字符串，和C语言中没什么不同值得注意的是后者包含两个字符，末尾有一个隐身的’\\0’ 而 string str = “a” 是C++ 封装好的string。C++中的char string和string不是一回事。当用到了”string”这个关键词，就不是普通的字符串，而是用到了封装后的类。在C++中，char仍然是一个primitive type（原始类型），而string已经经过封装，成为了一个class（类）用到它时，我们需要 #include ，它是C++ Standard Library （C++标准库）的一部分。 参考：c/c++中string与char的区别C++中string、char *、char[]、const char*的转换","tags":[]},{"title":"VS Code集成终端字体修改 & 字体颜色、大小修改方法","date":"2022-06-02T08:45:00.000Z","path":"2022/068a4c5ed0.html","text":"打开VScode，Ctrl + ,或者设置 -&gt; 设置搜索workbenck，如下图：点击Edit in settings.json在配置文件最后加上以下参数： //终端颜色配置 \"workbench.colorCustomizations\" : { //可以将鼠标放到下面的色号上根据自己的偏好进行选择 \"terminal.foreground\" : \"#37FF13\",//字体颜色 \"terminal.background\" : \"#2b2424\"//背景颜色 }, \"terminal.integrated.cursorBlinking\": true, \"terminal.integrated.lineHeight\": 1.2, \"terminal.integrated.letterSpacing\": 0.1, \"terminal.integrated.fontSize\": 14, //字体大小设置 \"terminal.integrated.fontFamily\": \"Lucida Console\", //字体设置 保存即可 具体颜色可根据个人喜好配置，如果想恢复默认颜色或者背景，删除该行代码即可 配置之后效果如下：","tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://kpl0111.github.io/blog/tags/VSCode/"}]},{"title":"利用RSA加密算法和MD5哈希算法实现加密通信（C++）","date":"2022-05-31T09:40:39.000Z","path":"2022/052824aa7.html","text":"本篇为作者个人作业，仅供参考，转载请注明出处 实验目的在保密通信过程中，对消息完整性的检验和对消息来源的认证，是一个非常重要的问题，本次大作业的内容为： 设计一个协议，利用rsa公钥加密算法和MD5哈希算法，实现对消息的完整性检验和发送者身份验证的功能，并编程实现这个协议。程序的要求是假设通讯双方为A和B，并假设发方拥有自己的RSA公钥PKA和私钥SKA ，同时收方B已经通过某种方式知道了发方的公钥PKA 。协议要求对发方A发来的消息，收方B通过检验，能够确定： B收到的消息是完整的，即消息在传送过程中没有遭到非法修改； B收到的消息来源是真实的，即该消息的确是由A发来的，而不是由其他人伪造的。 实验要求 分别编写两个程序，一个为发方程序，一个为收方程序，写清楚两个程序分别要完成的功能，并能够在两个程序间进行通讯。 大作业的提交方式同实验报告的提交，也就是说既要提交程序实现的说明文档，也要提交源代码和可执行程序。 设计思路RSA公钥加密算法可以实现对消息的加密和解密，而MD5仅可对消息进行加密处理，且在之前的实验中经过测试均满足雪崩效应，因此初步思路是： 利用MD5算法实现对发送方和接收方的身份确认 双方均知道对方身份，因此可以发送方对自己的ID使用MD5算法进行加密，并把加密后的密文ID发送给接收方 接收方接收到发送方的密文ID之后，利用自己已知的发送方ID（ID双方均已知，攻击者未知）同样对发送方原始ID进行MD5加密，并与发送方发送的密文ID进行比较， 如果一致，由于MD5算法具有雪崩效应，因此可认为发送方即为本人 如果不一致，则立即中止对话，保证信息的安全性 身份确认之后即可进行消息发送接收 身份确认之后利用RSA公钥体系对双方发送消息进行加密和解密 双方输入消息，利用RSA对消息进行加密，并把加密后消息使用TCP协议进行发送，这样即便消息被截获没有密钥也无法破译 接收方接收到密文后，利用密钥对其进行解密即可获取消息内容，同样也可发送消息利用TCP协议进行消息的收发，这里仅用来实现发送消息，TCP协议的安全性暂不考虑 实验设计流程图实验流程图如下： RSA算法流程图如下： MD5算法流程图如下： MD5算法实现身份验证 获取输入，该模块用于获取一段明文字符，不定长 对获取的不定长字符串进行填充,使其字节长度满足n*512 + 448, 填充规则是第一位填充1，后续填充0，直至满足上述条件，最后再用一个64为二进制字符串表示明文长度，这样填充之后长度为(n + 1)*512 // 填充字符串 vector&lt;unsigned int&gt; padding(string src) { // 以512位,64个字节为一组 unsigned int num = ((src.length() + 8) / 64) + 1; vector&lt;unsigned int&gt; rec(num*16); strlength = num*16; for(unsigned int i = 0; i &lt; src.length(); i++){ // 一个unsigned int对应4个字节，保存4个字符信息 rec[i&gt;&gt;2] |= (int)(src[i]) &lt;&lt; ((i % 4) * 8); } // 补充1000...000 rec[src.length() &gt;&gt; 2] |= (0x80 &lt;&lt; ((src.length() % 4)*8)); // 填充原文长度 rec[rec.size()-2] = (src.length() &lt;&lt; 3); return rec; } 字符串分块函数，将上述填充之后的字符串分割为L个512字节长度的字符串 循环压缩函数：对每个512-bit分组进行64轮迭代运算 对分组（A, B, C, D）中的A进行迭代运算 公式为：A &lt;= B + ((A + f(B,C,D) + X[k] + T[i])) &lt;&lt; S[i] 其中： A,B,C,D代表MD5缓冲区当前的数值 f为轮函数，1-16轮迭代使用F函数，17-32轮迭代使用G函数，33-48轮迭 代使用H函数，49-64轮迭代使用I函数 // F函数 unsigned int F(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; c) | ((~b) &amp; d); } // G函数 unsigned int G(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; d) | (c &amp; (~d)); } // H函数 unsigned int H(unsigned int b, unsigned int c, unsigned int d) { return b ^ c ^ d; } // I函数 unsigned int I(unsigned int b, unsigned int c, unsigned int d) { return c ^ (b | (~d)); } // 移位操作函数 unsigned int shift(unsigned int a, unsigned int n) { return (a &lt;&lt; n) | (a &gt;&gt; (32 - n)); } X[k]代表当前处理消息分组的第k个32位字，X[k]由第n轮迭代对应的顺序表决定 T[i]代表T表的第i项的值，T[i] = int(2^32 * |sin(i)|) S[i]对应第i轮的左循环移位的s值 对分组（A,B,C,D）作循环轮换 公式为：（B,C,D,A）&lt;=（A,B,C,D） 按照1， 2步骤进行四轮循环压缩 // 循环压缩 void iterateFunc(unsigned int* X, int size = 16) { unsigned int a = tempA, b = tempB, c = tempC, d = tempD, rec = 0, g, k; for(int i = 0; i &lt; 64; i++) { if(i &lt; 16) { // F迭代 g = F(b, c, d); k = i; } else if(i &lt; 32) { // G迭代 g = G(b, c, d); k = (1 + 5*i) % 16; } else if(i &lt; 48) { // H迭代 g = H(b, c, d); k = (5 + 3*i) % 16; } else { // I迭代 g = I(b, c, d); k = (7*i) % 16; } rec = d; d = c; c = b; b = b + shift(a + g + X[k] + T[i], s[i]); a = rec; } tempA += a; tempB += b; tempC += c; tempD += d; } MD5编码主函数：用于调用前面的功能函数对明文字符串进行MD5编码 输入待加密的明文字符串 对明文字符串进行填充 对填充后的明文字符串进行分块（$Y_q$） 使用预设的初始值初始化MD5缓冲区间（IV） 对各个分块字符串利用公式HMD5($CV_(i-1), Y_i$)进行循环压缩，运算结果作为下一块的输入（$CV_i$） 当所有的分块迭代完成后，输出结果$CV_L$，L表示最后一个分块的序号 // MD5加密函数 string encode(string src) { vector&lt;unsigned int&gt; rec = padding(src); for(unsigned int i = 0; i &lt; strlength/16; i++) { unsigned int num[16]; for(int j = 0; j &lt; 16; j++) { num[j] = rec[i*16+j]; } iterateFunc(num, 16); } return format(tempA) + format(tempB) + format(tempC) + format(tempD); } RSA实现信息加密解密RSA原理 公钥 选择两个不同的大素数p和q，n是二者的乘积，即$ n=pq $， 使$$ \\varphi (n)=(p-1)(q-1) $$为欧拉函数。 随机选取正整数e，使其满足$ gcd(e,\\varphi (n))=1 $，即e和$\\phi (n)$互素，则将(e,n)作为公钥。 私钥 求出正数d，使其满足$ e \\times d \\equiv 1mod\\varphi (n) $，则将(d,n)作为私钥。 加密算法 对于明文m，由$ c \\equiv m^emodn $，得到密文c，这里需要注意明文的分组方法。 解密算法 对于密文c，由$ m \\equiv c^dmodn $，得到明文m。 实现过程C++中大数需要用到gmp库,简单说下怎么安装 Linux一行命令的事情 sudo apt-get install libgmp-dev Windows下需要MinGW,打开MinGW Installation Manager,左侧All Packages选中，然后找到MinGW-gmp，版本的话选择dev，右键Mark for Installation，然后菜单栏Installation选择Apply Changes即可，等待安装即可。 首先定义一个密钥对结构体： struct key_pair { string n; string d; int e; }; 利用GMP的素性测试和数据生成完成两个大素数p，q的生成 //生成两个大素数 mpz_t * gen_primes() { gmp_randstate_t grt; gmp_randinit_default(grt); gmp_randseed_ui(grt, time(NULL)); mpz_t key_p, key_q; mpz_init(key_p); mpz_init(key_q); mpz_urandomb(key_p, grt, KEY_LENGTH / 2); mpz_urandomb(key_q, grt, KEY_LENGTH / 2); //随机生成两个大整数 mpz_t * result = new mpz_t[2]; mpz_init(result[0]); mpz_init(result[1]); mpz_nextprime(result[0], key_p); //使用GMP自带的素数生成函数 mpz_nextprime(result[1], key_q); mpz_clear(key_p); mpz_clear(key_q); return result; } 根据RSA原理生成密钥对 //生成密钥对 key_pair * gen_key_pair() { mpz_t * primes = gen_primes(); mpz_t key_n, key_e, key_f; mpz_init(key_n); mpz_init(key_f); mpz_init_set_ui(key_e, 65537); //设置e为65537 mpz_mul(key_n, primes[0], primes[1]); //计算n=p*q mpz_sub_ui(primes[0], primes[0], 1); //p=p-1 mpz_sub_ui(primes[1], primes[1], 1); //q=q-1 mpz_mul(key_f, primes[0], primes[1]); //计算欧拉函数φ(n)=(p-1)*(q-1) mpz_t key_d; mpz_init(key_d); mpz_invert(key_d, key_e, key_f); //计算数论倒数 key_pair * result = new key_pair; char * buf_n = new char[KEY_LENGTH + 10]; char * buf_d = new char[KEY_LENGTH + 10]; mpz_get_str(buf_n, BASE, key_n); result-&gt;n = buf_n; mpz_get_str(buf_d, BASE, key_d); result-&gt;d = buf_d; result-&gt;e = 65537; mpz_clear(primes[0]); //释放内存 mpz_clear(primes[1]); mpz_clear(key_n); mpz_clear(key_d); mpz_clear(key_e); mpz_clear(key_f); delete []primes; return result; } 加密函数 char * encrypt(char * plain_text, const char * key_n, int key_e) { mpz_t M, C1, n; mpz_init_set_str(M, plain_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_ui(C1, 0); mpz_powm_ui(C1, M, key_e, n); //使用GMP中模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, C1); return result; } 解密函数 char * decrypt(char * cipher_text, const char * key_n, const char * key_d) { mpz_t M, C1, n, d; mpz_init_set_str(C1, cipher_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_str(d, key_d, BASE); mpz_init(M); mpz_powm(M, C1, d, n); //使用GMP中的模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, M); return result; } 主程序 对A,B双方分别创建套接字，采用TCP，IPv4协议，输入自己的昵称之后经过TCP的三次握手即可连接成功 接下来进入身份确认环节，对AB双方发送的身份信息进行确认，利用对方昵称生成MD5密文，对比发送密文即可判断 MD5 tmp_name; string tmp_s = tmp_name.encode(client_name_tmp); for (int i = 0; i &lt; tmp_s.length(); i++) { client_name[i] = tmp_s[i]; } send_len = send(client, client_name, sizeof(client_name), 0); receive_len = recv(client, server_name, sizeof(server_name), 0); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED); cout &lt;&lt; endl; if (IdConfirm(server_name, \"lkp1\")) { cout &lt;&lt; \"ID Confirm success, Let's chatting...\" &lt;&lt; endl &lt;&lt; endl; } else { cout &lt;&lt; \"ID Confirm failed, Conversation aborted...\"; return 0; } 身份确认成功之后即可进入发送环节，双方回合制发送信息 如果输入12582则表示当前回合结束，对方可发送信息 如果输入12581则表示想要退出聊天，则发送双方结束本次聊天 如果是其他信息，则相对信息进行加密然后发送，为了演示加密过程，在发送信息下方打印出密文和明文详情 实验演示截图为了演示清晰，程序对文字进行了颜色处理，采用最原始聊天的蓝绿风格，并对身份确认环节进行红色处理。 默认双方昵称为lkp1和lkp2。 双方正常对话发送消息 client结束本轮对话，由server发送消息 server发送完消息之后输入12581结束本次对话 接下来演示身份错误环节 实验实现了目标里面的功能并且能够双向通信。 源代码文件树├───Client│——|——client.cpp│——|——client.exe│——|——client.h│——|——MD5.h├───Server│——|——generateKey.cpp│——|——generateKey.exe│——|——MD5.h│——|——server.cpp│——|——server.exe│——|——server.h MD5.h#pragma once #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; using namespace std; #define A 0x67452301 #define B 0xefcdab89 #define C 0x98badcfe #define D 0x10325476 const char str16[] = \"0123456789abcdef\"; const unsigned int T[] = { 0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee, 0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501, 0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be, 0x6b901122,0xfd987193,0xa679438e,0x49b40821, 0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa, 0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8, 0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed, 0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a, 0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c, 0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70, 0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05, 0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665, 0xf4292244,0x432aff97,0xab9423a7,0xfc93a039, 0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1, 0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1, 0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391 }; const unsigned int s[] = { 7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22, 5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20, 4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23, 6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21}; // 第一部分是要进行 HASH 运算的原始明文，第二部分则是其对应的 HASH 值 static const struct data{ string msg; unsigned char hash[16]; }tests[] = { { \"\", { 0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04, 0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e } }, { \"a\", {0x0c, 0xc1, 0x75, 0xb9, 0xc0, 0xf1, 0xb6, 0xa8, 0x31, 0xc3, 0x99, 0xe2, 0x69, 0x77, 0x26, 0x61 } }, { \"abc\", { 0x90, 0x01, 0x50, 0x98, 0x3c, 0xd2, 0x4f, 0xb0, 0xd6, 0x96, 0x3f, 0x7d, 0x28, 0xe1, 0x7f, 0x72 } }, { \"message digest\", { 0xf9, 0x6b, 0x69, 0x7d, 0x7c, 0xb7, 0x93, 0x8d, 0x52, 0x5a, 0x2f, 0x31, 0xaa, 0xf1, 0x61, 0xd0 } }, { \"abcdefghijklmnopqrstuvwxyz\", { 0xc3, 0xfc, 0xd3, 0xd7, 0x61, 0x92, 0xe4, 0x00, 0x7d, 0xfb, 0x49, 0x6c, 0xca, 0x67, 0xe1, 0x3b } }, { \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", { 0xd1, 0x74, 0xab, 0x98, 0xd2, 0x77, 0xd9, 0xf5, 0xa5, 0x61, 0x1c, 0x2c, 0x9f, 0x41, 0x9d, 0x9f } }, { \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", { 0x57, 0xed, 0xf4, 0xa2, 0x2b, 0xe3, 0xc9, 0x55, 0xac, 0x49, 0xda, 0x2e, 0x21, 0x07, 0xb6, 0x7a } }, }; class MD5 { private: unsigned int tempA, tempB, tempC, tempD, strlength; public: MD5() { tempA = A; tempB = B; tempC = C; tempD = D; strlength = 0; } // 填充字符串 vector&lt;unsigned int&gt; padding(string src) { // 以512位,64个字节为一组 unsigned int num = ((src.length() + 8) / 64) + 1; vector&lt;unsigned int&gt; rec(num*16); strlength = num*16; for(unsigned int i = 0; i &lt; src.length(); i++){ // 一个unsigned int对应4个字节，保存4个字符信息 rec[i&gt;&gt;2] |= (int)(src[i]) &lt;&lt; ((i % 4) * 8); } // 补充1000...000 rec[src.length() &gt;&gt; 2] |= (0x80 &lt;&lt; ((src.length() % 4)*8)); // 填充原文长度 rec[rec.size()-2] = (src.length() &lt;&lt; 3); return rec; } // F函数 unsigned int F(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; c) | ((~b) &amp; d); } // G函数 unsigned int G(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; d) | (c &amp; (~d)); } // H函数 unsigned int H(unsigned int b, unsigned int c, unsigned int d) { return b ^ c ^ d; } // I函数 unsigned int I(unsigned int b, unsigned int c, unsigned int d) { return c ^ (b | (~d)); } // 移位操作函数 unsigned int shift(unsigned int a, unsigned int n) { return (a &lt;&lt; n) | (a &gt;&gt; (32 - n)); } // 循环压缩 void iterateFunc(unsigned int* X, int size = 16) { unsigned int a = tempA, b = tempB, c = tempC, d = tempD, rec = 0, g, k; for(int i = 0; i &lt; 64; i++) { if(i &lt; 16) { // F迭代 g = F(b, c, d); k = i; } else if(i &lt; 32) { // G迭代 g = G(b, c, d); k = (1 + 5*i) % 16; } else if(i &lt; 48) { // H迭代 g = H(b, c, d); k = (5 + 3*i) % 16; } else { // I迭代 g = I(b, c, d); k = (7*i) % 16; } rec = d; d = c; c = b; b = b + shift(a + g + X[k] + T[i], s[i]); a = rec; } tempA += a; tempB += b; tempC += c; tempD += d; } // 整理输出 string format(unsigned int num) { string res = \"\"; unsigned int base = 1 &lt;&lt; 8; for(int i = 0; i &lt; 4; i++) { string tmp = \"\"; unsigned int b = (num &gt;&gt; (i * 8)) % base &amp; 0xff; for(int j = 0; j &lt; 2; j++) { tmp = str16[b%16] + tmp; b /= 16; } res += tmp; } return res; } // 编码函数 string encode(string src) { vector&lt;unsigned int&gt; rec = padding(src); for(unsigned int i = 0; i &lt; strlength/16; i++) { unsigned int num[16]; for(int j = 0; j &lt; 16; j++) { num[j] = rec[i*16+j]; } iterateFunc(num, 16); } return format(tempA) + format(tempB) + format(tempC) + format(tempD); } }; generateKey.cpp#include &lt;cstdio&gt; #include &lt;ctime&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;gmp.h&gt; #define KEY_LENGTH 2048 //公钥的长度 #define BASE 16 //输入输出的数字进制 using namespace std; struct key_pair { string n; string d; int e; }; //生成两个大素数 mpz_t * gen_primes() { gmp_randstate_t grt; gmp_randinit_default(grt); gmp_randseed_ui(grt, time(NULL)); mpz_t key_p, key_q; mpz_init(key_p); mpz_init(key_q); mpz_urandomb(key_p, grt, KEY_LENGTH / 2); mpz_urandomb(key_q, grt, KEY_LENGTH / 2); //随机生成两个大整数 mpz_t * result = new mpz_t[2]; mpz_init(result[0]); mpz_init(result[1]); mpz_nextprime(result[0], key_p); //使用GMP自带的素数生成函数 mpz_nextprime(result[1], key_q); mpz_clear(key_p); mpz_clear(key_q); return result; } //生成密钥对 key_pair * gen_key_pair() { mpz_t * primes = gen_primes(); mpz_t key_n, key_e, key_f; mpz_init(key_n); mpz_init(key_f); mpz_init_set_ui(key_e, 65537); //设置e为65537 mpz_mul(key_n, primes[0], primes[1]); //计算n=p*q mpz_sub_ui(primes[0], primes[0], 1); //p=p-1 mpz_sub_ui(primes[1], primes[1], 1); //q=q-1 mpz_mul(key_f, primes[0], primes[1]); //计算欧拉函数φ(n)=(p-1)*(q-1) mpz_t key_d; mpz_init(key_d); mpz_invert(key_d, key_e, key_f); //计算数论倒数 key_pair * result = new key_pair; char * buf_n = new char[KEY_LENGTH + 10]; char * buf_d = new char[KEY_LENGTH + 10]; mpz_get_str(buf_n, BASE, key_n); result-&gt;n = buf_n; mpz_get_str(buf_d, BASE, key_d); result-&gt;d = buf_d; result-&gt;e = 65537; mpz_clear(primes[0]); //释放内存 mpz_clear(primes[1]); mpz_clear(key_n); mpz_clear(key_d); mpz_clear(key_e); mpz_clear(key_f); delete []primes; return result; } key_pair* getKey (char name) { key_pair * p = gen_key_pair(); cout &lt;&lt; \"n = \" &lt;&lt; p-&gt;n &lt;&lt; endl; cout &lt;&lt; \"d = \" &lt;&lt; p-&gt;d &lt;&lt; endl; cout &lt;&lt; \"e = \" &lt;&lt; p-&gt;e &lt;&lt; endl; cout &lt;&lt; name &lt;&lt; \"s public key is:(\" &lt;&lt; p-&gt;n &lt;&lt; \", \" &lt;&lt; p-&gt;e &lt;&lt; \")\" &lt;&lt; endl &lt;&lt; endl; //输出公钥(n, e) cout &lt;&lt; name &lt;&lt; \"s private key is:(\" &lt;&lt; p-&gt;n &lt;&lt; \", \" &lt;&lt; p-&gt;d &lt;&lt; \")\" &lt;&lt; endl &lt;&lt; endl; //输出私钥(n, d) return p; } void generateABKey() { key_pair * A = getKey('A'); key_pair * B = getKey('B'); } int main() { generateABKey(); return 0; } Server.h#pragma once #include &lt;cstdio&gt; #include &lt;ctime&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;gmp.h&gt; #include \"MD5.h\" #define KEY_LENGTH 2048 //公钥的长度 #define BASE 16 //输入输出的数字进制 using namespace std; struct key_pair { string n; string d; int e; string k; }; key_pair* key = new key_pair; void keyInit() { key-&gt;n = \"42ed95a8c26d10e856d7ac17e9451037457d5f6e66b824471229ac1422d28f868d6699492c7c31b6d10ed32ee6ad3cbb00bbefe2e76de75b924342781f3f67fd09a3d67c639363c97af569fb52863901f1b6b5e7901c00c989dd7847fc7f55989bf4775969254c2dc0d8e9f7e7dbb5e158c97f5d7d18de47766ee1efb2a3d7e899d019240701e2dec5ca8473a34cea6b6dcb62cff25d40858df7b37e3c14bac390d26926cf30c977b7417130bced9fcce5b7ff6923ab21652a2bf73c3dd0c40a3398f02261e9bd75a24134264412b3371c03daa715e2ad74c20d0ab895ab7025b0bec1eea316146127a5a6d97aa4f09c82624d7f897ef93a7d114cc0757d4253\"; key-&gt;d = \"1f3c797be0fa3c48e3b716e7b60478b40327a77184596efd089a1068f973a26edef1c29ae73b338caa77abd298f0c38657aa5f245c74ebe4ce17bc1f0a1e72af235fa70c3901223277c3b06a0eb2fc4a4f00c25747e7f9ea16011a5126a45b53b57ddc720b63cff10eaf6e4b38984f83d4077efd281482318231f01b0a19f3fb58f835baa189bd387e4ba9d7da4b597d84fdcffc22e707be41adb6ca20f05787cf7e6d1ef27fb8e18ecb4d7ba9f544488e0d109cad4e7befa47020b8e568cf509543fc972b79aa1a8fb49149b517384b5b458f7a8052c299e3605fe12c786cd80f3fd8a2dc7f0ae67ecf1c3b2212d2b21fe5b7588a2d977af636cc461ec78c99\"; key-&gt;e = 65537; key-&gt;k = \"77232546f0b2983adb0ab839b04b81278bcbdc2d34f06a248333cd33e3c139fb578ca19b389e0253fa6f3b3b41e2fd0f6f1fa7e94499fa212afa7f0b2a89f8681dd00e3207c09586c7c6f923016455b652e93ae4bf3b905d7e955fb3102286d9947247f1e75921aaa35840ad3359091e701c167f28be312116c43a13946d0c8d5da8fa21938be40c1f60821d45ef8530d6e24adfd5ab2a1a6ad34545d83c5fcca02a7f29541d6d4cf29778593958957c9b4ad9693289db7743a05bf88480473dc028e4f8e32ff6bdd206910b971ae00c649038aa59baebe8b7af542e9a9b65f69e7efcc17d6a88244cc9520d4b009371c268058e62d707561825ad5a98a81d11\"; } //加密函数 char * encrypt(const char * plain_text, const char * key_n, int key_e) { mpz_t M, C1, n; mpz_init_set_str(M, plain_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_ui(C1, 0); mpz_powm_ui(C1, M, key_e, n); //使用GMP中模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, C1); return result; } //解密函数 char * decrypt(const char * cipher_text, const char * key_n, const char * key_d) { mpz_t M, C1, n, d; mpz_init_set_str(C1, cipher_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_str(d, key_d, BASE); mpz_init(M); mpz_powm(M, C1, d, n); //使用GMP中的模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, M); return result; } string getTime() {//时间函数，返回一个时间戳 time_t timep; time(&amp;timep); char tmp[64]; strftime(tmp, sizeof(tmp), \"%Y-%m-%d %H:%M:%S\", localtime(&amp;timep)); return tmp; } bool IdConfirm (string ID, string name) { MD5 tmp; string hash = tmp.encode(name); if (ID.compare(hash)) { return false; } return true; } Server.cpp#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;winsock.h&gt; #include&lt;time.h&gt; #include\"windows.h\" #include \"server.h\" #pragma comment(lib,\"ws2_32.lib\")//加载ws2_32.dll #define BUF_SIZE 4096 //指定聊天信息缓冲区大小 using namespace std; int main() { WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); SOCKET server = socket(AF_INET, SOCK_STREAM, 0);//创建server套接字，采用ipv4地址，默认TCP协议 sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET;//套接字地址也采用IPv4地址 server_addr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\");//本机地址 server_addr.sin_port = htons(1234);//端口号 bind(server, (SOCKADDR*)&amp;server_addr, sizeof(server_addr));//将套接字和地址绑定 char server_name[2048] = { 0 };//申请一个2048字节的缓冲区，用于储存服务器的名称 char server_name_tmp[2048] = { 0 }; cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Please enter your nickname:\"; cin.getline(server_name_tmp, 2048); //gets() cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Waiting for connection...\\n\"; listen(server, 1);//进入监听状态，数字1表示队列中只能存在一个请求 /*服务器已经初始化完毕，等待客户机连接*/ char client_name[2048] = { 0 }; SOCKET client; SOCKADDR_IN client_addr; int client_addr_len = sizeof(client_addr); while (true) { client = accept(server, (SOCKADDR*)&amp;client_addr, &amp;client_addr_len); if (client == INVALID_SOCKET) { cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Connection failed.\\n\" &lt;&lt; WSAGetLastError(); } else { cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Connection succeeded!!!\\n\"; break; } } char buffer[BUF_SIZE] = { 0 }; char buffer_send[BUF_SIZE + 100] = { 0 }; char buffer_receive[BUF_SIZE + 100] = { 0 }; int receive_len = 0; int send_len = 0; /*通过建立的连接进行通信*/ //发送和接受客户端与服务端的名字 MD5 tmp_name; string tmp_s = tmp_name.encode(server_name_tmp); for (int i = 0; i &lt; tmp_s.length(); i++) { server_name[i] = tmp_s[i]; } send_len = send(client, server_name, sizeof(server_name), 0); receive_len = recv(client, client_name, sizeof(client_name), 0); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED); cout &lt;&lt; endl; if (IdConfirm(client_name, \"lkp2\")) { cout &lt;&lt; \"ID Confirm success, Let's chatting...\" &lt;&lt; endl &lt;&lt; endl; } else { cout &lt;&lt; \"ID Confirm failed, Conversation aborted...\"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return 0; } keyInit(); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); cout &lt;&lt; \"Please enter the message(just number) you want to send, or enter \\\"12582\\\" to abort this conversation, or enter \\\"12581\\\" to abort this chat\" &lt;&lt; endl; while (true) { while (true) {//接收消息 memset(buffer_receive, 0, sizeof(buffer_receive));//初始化缓冲区 receive_len = recv(client, buffer_receive, sizeof(buffer_receive), 0); //string tmp(buffer_receive); string tmp = decrypt(buffer_receive, key-&gt;n.data(), key-&gt;d.data()); if (strcmp(buffer_receive, \"12581\") == 0) {//如果聊天内容中含有12581，则退出聊天，关闭socket SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY); cout &lt;&lt; \"The program will exit in 3 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 2 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 1 seconds...\"; Sleep(1000); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//恢复原来的颜色 closesocket(server); closesocket(client); WSACleanup(); return 0; } else if (strcmp(buffer_receive, \"12582\") == 0)//如果聊天内容中含有12582，则本回合聊天结束，不然可以继续发送信息 break; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE);//设置蓝色 if (tmp.find(\"0\") != string::npos) { continue; } cout &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl &lt;&lt; \"Message:\" &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"Ciphertext:\" &lt;&lt; buffer_receive &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl; } while (true) {//发送消息 memset(buffer, 0, sizeof(buffer));//清空缓冲区 memset(buffer_send, 0, sizeof(buffer_send)); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);//设置绿色 string tmp_time = getTime(); cout &lt;&lt; tmp_time &lt;&lt; \" \" &lt;&lt; server_name_tmp &lt;&lt; \":\"; cin.getline(buffer, BUF_SIZE); if (strcmp(buffer, \"12582\") == 0) { send_len = send(client, buffer, sizeof(buffer), 0); break; } else if (strcmp(buffer, \"12581\") == 0) { send_len = send(client, buffer, sizeof(buffer), 0); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY); cout &lt;&lt; \"The program will exit in 3 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 2 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 1 seconds...\"; Sleep(1000); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//恢复原来的颜色 closesocket(server); closesocket(client); WSACleanup(); return 0; } cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl &lt;&lt; \"Message:\" &lt;&lt; buffer &lt;&lt; endl; char* tmp = encrypt(buffer, key-&gt;k.data(), key-&gt;e); cout &lt;&lt; \"Ciphertext:\" &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl; char tmp1[10240]; strncpy(tmp1, tmp, strlen(tmp) + 1); send_len = send(client, tmp1, sizeof(tmp1), 0); } } return 0; } Client.h#pragma once #include &lt;cstdio&gt; #include &lt;ctime&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;gmp.h&gt; #include \"MD5.h\" #define KEY_LENGTH 2048 //公钥的长度 #define BASE 16 //输入输出的数字进制 using namespace std; struct key_pair { string n; string d; int e; string k; }; key_pair* key = new key_pair; void keyInit() { key-&gt;n = \"77232546f0b2983adb0ab839b04b81278bcbdc2d34f06a248333cd33e3c139fb578ca19b389e0253fa6f3b3b41e2fd0f6f1fa7e94499fa212afa7f0b2a89f8681dd00e3207c09586c7c6f923016455b652e93ae4bf3b905d7e955fb3102286d9947247f1e75921aaa35840ad3359091e701c167f28be312116c43a13946d0c8d5da8fa21938be40c1f60821d45ef8530d6e24adfd5ab2a1a6ad34545d83c5fcca02a7f29541d6d4cf29778593958957c9b4ad9693289db7743a05bf88480473dc028e4f8e32ff6bdd206910b971ae00c649038aa59baebe8b7af542e9a9b65f69e7efcc17d6a88244cc9520d4b009371c268058e62d707561825ad5a98a81d11\"; key-&gt;d = \"369979d5082ca14d9fe34ac8cd7ddd0415b26906a2d367a1b22b8468ba816ca43edc6997ec9ba5af7cff8b22be305c0fbdbac1464bb55187efdd7b69cfa6099d15c4ab2ccc96bb3058d05c8f696ce54738ba40ce62c1d688b2a19c8940e4c1ee6774f479edafd099166134caebd46b3472e6bc7cac5c75c1976078c94e65a7b164a983dc15d98ed7d95041fa52adb643f87d7590bc1f476264caad4ea47adc7ec6aaedb5afe341a68afc6b8ee32a8eacf17b0d372afcf14258e87901395349a797443e50ee8bddf2fbf121799ba40a3e3b22e76341f07606dc7a810fb000dcbed3fc05a15223b04ff5f9610e9febae25a27a2871a2b75eacaba745e63bbc295d\"; key-&gt;e = 65537; key-&gt;k = \"42ed95a8c26d10e856d7ac17e9451037457d5f6e66b824471229ac1422d28f868d6699492c7c31b6d10ed32ee6ad3cbb00bbefe2e76de75b924342781f3f67fd09a3d67c639363c97af569fb52863901f1b6b5e7901c00c989dd7847fc7f55989bf4775969254c2dc0d8e9f7e7dbb5e158c97f5d7d18de47766ee1efb2a3d7e899d019240701e2dec5ca8473a34cea6b6dcb62cff25d40858df7b37e3c14bac390d26926cf30c977b7417130bced9fcce5b7ff6923ab21652a2bf73c3dd0c40a3398f02261e9bd75a24134264412b3371c03daa715e2ad74c20d0ab895ab7025b0bec1eea316146127a5a6d97aa4f09c82624d7f897ef93a7d114cc0757d4253\"; } //加密函数 char * encrypt(char * plain_text, const char * key_n, int key_e) { mpz_t M, C1, n; mpz_init_set_str(M, plain_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_ui(C1, 0); mpz_powm_ui(C1, M, key_e, n); //使用GMP中模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, C1); return result; } //解密函数 char * decrypt(char * cipher_text, const char * key_n, const char * key_d) { mpz_t M, C1, n, d; mpz_init_set_str(C1, cipher_text, BASE); mpz_init_set_str(n, key_n, BASE); mpz_init_set_str(d, key_d, BASE); mpz_init(M); mpz_powm(M, C1, d, n); //使用GMP中的模幂计算函数 char * result = new char[KEY_LENGTH + 10]; mpz_get_str(result, BASE, M); return result; } string getTime() { time_t timep; time(&amp;timep); char tmp[64]; strftime(tmp, sizeof(tmp), \"%Y-%m-%d %H:%M:%S\", localtime(&amp;timep)); return tmp; } bool IdConfirm (string ID, string name) { MD5 tmp; string hash = tmp.encode(name); if (ID.compare(hash)) { return false; } return true; } Client.cpp#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;winsock.h&gt; #include&lt;time.h&gt; #include\"windows.h\" #include \"client.h\" #pragma comment(lib,\"ws2_32.lib\")//加载ws2_32.dll #define BUF_SIZE 4096 //指定聊天信息缓冲区大小 using namespace std; int main() { WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); SOCKET client = socket(AF_INET, SOCK_STREAM, 0); sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); server_addr.sin_port = htons(1234); char client_name[2048] = { 0 }; char client_name_tmp[2048] = { 0 }; cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Please enter your nickname:\"; cin.getline(client_name_tmp, 2048); connect(client, (SOCKADDR*)&amp;server_addr, sizeof(server_addr)); cout &lt;&lt; getTime() &lt;&lt; \" \" &lt;&lt; \"Connection ready.\\n\"; char server_name[2048] = { 0 }; char buffer[BUF_SIZE] = { 0 }; char buffer_send[BUF_SIZE + 100] = { 0 }; char buffer_receive[BUF_SIZE + 100] = { 0 }; int receive_len = 0; int send_len = 0; MD5 tmp_name; string tmp_s = tmp_name.encode(client_name_tmp); for (int i = 0; i &lt; tmp_s.length(); i++) { client_name[i] = tmp_s[i]; } send_len = send(client, client_name, sizeof(client_name), 0); receive_len = recv(client, server_name, sizeof(server_name), 0); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED); cout &lt;&lt; endl; if (IdConfirm(server_name, \"lkp1\")) { cout &lt;&lt; \"ID Confirm success, Let's chatting...\" &lt;&lt; endl &lt;&lt; endl; } else { cout &lt;&lt; \"ID Confirm failed, Conversation aborted...\"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); return 0; } keyInit(); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); cout &lt;&lt; \"Please enter the message(just number) you want to send, or enter \\\"12582\\\" to abort this conversation, or enter \\\"12581\\\" to abort this chat\" &lt;&lt; endl; while (true) { while (true) { memset(buffer, 0, sizeof(buffer)); memset(buffer_send, 0, sizeof(buffer_send)); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);//设置绿色 string tmp_time = getTime(); cout &lt;&lt; tmp_time &lt;&lt; \" \" &lt;&lt; client_name_tmp &lt;&lt; \":\"; cin.getline(buffer, sizeof(buffer)); if (strcmp(buffer, \"12581\") == 0) { send_len = send(client, buffer, sizeof(buffer), 0); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY); cout &lt;&lt; \"The program will exit in 3 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 2 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 1 seconds...\"; Sleep(1000); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//恢复原来的颜色 closesocket(client); WSACleanup(); return 0; } else if (strcmp(buffer, \"12582\") == 0) { send_len = send(client, buffer, sizeof(buffer), 0); break; } cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl &lt;&lt; \"Message:\" &lt;&lt; buffer &lt;&lt; endl; char * tmp = encrypt(buffer, key-&gt;k.data(), key-&gt;e); cout &lt;&lt; \"Ciphertext:\" &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl; char tmp1[10240]; strncpy(tmp1, tmp, strlen(tmp) + 1); send_len = send(client, tmp1, sizeof(tmp1), 0); } while (true) { memset(buffer_receive, 0, sizeof(buffer_receive)); receive_len = recv(client, buffer_receive, sizeof(buffer_receive), 0); string tmp = decrypt(buffer_receive, key-&gt;n.data(), key-&gt;d.data()); if (strcmp(buffer_receive, \"12581\") == 0) { SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY); cout &lt;&lt; \"The program will exit in 3 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 2 seconds...\" &lt;&lt; endl; Sleep(1000); cout &lt;&lt; \"The program will exit in 1 seconds...\"; Sleep(1000); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);//恢复原来的颜色 closesocket(client); WSACleanup(); return 0; } else if (strcmp(buffer_receive, \"12582\") == 0) break; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE);//设置蓝色 if (tmp.find(\"0\") != string::npos) { continue; } cout &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl &lt;&lt; \"Message:\" &lt;&lt; tmp &lt;&lt; endl; cout &lt;&lt; \"Ciphertext:\" &lt;&lt; buffer_receive &lt;&lt; endl; cout &lt;&lt; \"----------------------Detail--------------------\" &lt;&lt; endl; } } return 0; }","tags":[]},{"title":"数字签名算法DSA","date":"2022-05-27T09:10:44.000Z","path":"2022/059d9eab6e.html","text":"本文为作者个人作业，仅供参考 实验要求通过对数字签字算法DSA的实际操作，理解DSS的基本工作原理。 实验内容 参照教材，熟悉数字签名算法DSA； 参照教材，熟悉杂凑函数算法SHA； 这里给出一个可运行的DSA数字签字演示程序，运行这个程序，对一段文字进行签字和验证，了解DSA算法的签字和验证过程。 杂凑函数SHA-1安全哈希算法(SHA)是基于MD4算法，其结构与MD4非常类似，用于数字签名的标准算法DSS中。 算法实现步骤 将消息摘要转换成位字符串 因为在SHA-算法中，它的输入必须为位，所以首先要将其转化为位字符串，以“abc”字符串来说明问题，因为’a’=97, ‘b’=98, ‘c’=99，所以将其转换为位串后为： 01100001 01100010 01100011 对转换后的位字符串进行补位操作 SHA-算法标准规定，必须对消息摘要进行补位操作，即将输入的数据进行填充，使得数据长度对512求余的结果为448，填充比特位的最高位补一个1，其余的位补0，如果在补位之前已经满足对512取模余数为448，也要进行补位，在其后补一位1即可。总之，补位是至少补一位，最多补512位，依然以“abc”为例，其补位过程如下： 初始的信息摘要：01100001 01100010 01100011 第一步补位：01100001 01100010 01100011 1….. …… 补位最后一位：01100001 01100010 01100011 10…….0(后面补了423个0) 而后将补位操作后的信息摘要转换为十六进制，如下所示： 61626380 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 附加长度值 在信息摘要后面附加64bit的信息，用来表示原始信息摘要的长度，在这步操作之后，信息报文便是512bit的倍数。通常来说用一个64位的数据表示原始消息的长度，如果消息长度不大于2^64，那么前32bit就为0，在进行附加长度值操作后，其“abc”数据报文即变成如下形式： 61626380 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000018 因为“abc”占3个字节，即24位 ，换算为十六进制即为0x18。 初始化缓存 一个160位MD缓冲区用以保存中间和最终散列函数的结果。它可以表示为5个32位的寄存器($H_0$,$H_1$,$H_2$,$H_3$,$H_4$)。初始化为： $H_0$ = 0x67452301 $H_1$ = 0xEFCDAB89 $H_2$ = 0x98BADCFE $H_3$ = 0x10325476 $H_4$ = 0xC3D2E1F0 前四个与上周的MD-5一样，但不同之处为存储为大端序 计算消息摘要 在计算报文之前还要做一些基本的工作，就是在计算过程中要用到的方法。 循环左移操作符Sn(x),x是一个字，也就是32bit大小的变量，n是一个整数且0&lt;=n&lt;=32。Sn(X) = (X&lt;&lt;n)OR(X&gt;&gt;32-n) 在程序中所要用到的常量，这一系列常量字k(0)、k(1)、…k(79)，将其以十六进制表示如下： $K_t$ = 0x5A827999 (0 &lt;= t &lt;= 19) $K_t$ = 0x6ED9EBA1 (20 &lt;= t &lt;= 39) $K_t$ = 0x8F1BBCDC (40 &lt;= t &lt;= 59) $K_t$ = 0xCA62C1D6 (60 &lt;= t &lt;= 79) 所要用到的一系列函数 Ft(b,c,d) ((b&amp;c)|((~b)&amp;d)) (0 &lt;= t &lt;= 19) Ft(b,c,d) (b^c^d) (20 &lt;= t &lt;= 39) Ft(b,c,d) ((b&amp;c)|(b&amp;d)|(c&amp;d)) (40 &lt;= t &lt;= 59) Ft(b,c,d) (b^c^d) (60 &lt;= t &lt;= 79) 计算 计算需要一个缓冲区，由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。80个字的缓冲区被标识为$W_0, W_1,…, W_{79}$ 另外还需要一个一个字的TEMP缓冲区。 为了产生消息摘要，在第4部分中定义的16个字的数据块$M_1, M_2,…, M_n$会依次进行处理，处理每个数据块$M_i$ 包含80个步骤。 现在开始处理$M_1, M_2, … , M_n$。为了处理 $M_i$,需要进行下面的步骤 将 Mi 分成 16 个字 $W_0, W_1, … , W_{15}, W_0$ 是最左边的字 对于 t = 16 到 79 令 $W_t = S_1(W_{t-3} XOR W_{t-8} XOR W_{t- 14} XOR W_{t-16})$. 令 A = $H_0$, B = $H_1$, C = $H_2$, D = $H_3$, E = $H_4$. 对于 t = 0 到 79，执行下面的循环 TEMP = S5(A) + ft(B,C,D) + E + Wt + $K_t$; E = D; D = C; C = S30(B); B = A; A = TEMP; 令 $H_0$ = $H_0$ + A, $H_1$ = $H_1$ + B, $H_2$ = $H_2$ + C, $H_3$ = $H_3$ + D, $H_4$ = $H_4$ + E. 在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识$H_0$ $H_1$ $H_2$ $H_3$ $H_4$. SHA-1在DSS中的应用在DSS（数字签名标准）中，使用数字签名算法DSA和哈希函数SHA-1结合完成数字签名。 数字签名算法DSADSA是在ElGamal和Schnorr两个签名方案的基础上设计的，其安全性基于求离散对数的困难性。 算法描述 全局变量 p：满足$2^{L-1}&lt;p&lt;2^L$的大素数，其中$512\\leq L\\leq 1024$且$L$是64的倍数。 q：$p-1$的素因子，满足$2^{159}&lt;p&lt;2{160}$，即$q$长为160比特。 g：$g\\equiv h^{(p-1)/q}modp$，其中$h$是满足$1&lt;h&lt;p-1$且使得$h^{(p-1)/q}modp&gt;1$的任一整数。 密钥x $x$是满足$0&lt;x&lt;q$的随机数或伪随机数。 公钥y $y\\equiv g^xmodp$ 用户的随机数选择k $k$是满足$0&lt;k&lt;q$的随机数或伪随机数。 签名过程 用户对消息$M$的签名为$(r,s)$，其中$r\\equiv (g^kmodp)modq$，$s\\equiv [k^{-1}(H(M)+xr)]modq$，$H(M)$是由SHA求出的哈希值。 验证过程 设接收方接收到的消息为$M’$，签名为$(r’,s’)$。计算 $\\omega \\equiv (s’)^{-1}modq$ $u_1\\equiv [H(M’)\\omega ]modq$ $u_2\\equiv r’\\omega modq$ $v\\equiv [(g^{u_1}y^{u_2})modp]modq$。 检查$v$是否等于$r’$，若相等，则证明签名有效，这是因为 若$(M’,r’,s’)=(M,r,s)$， 则$v\\equiv [(g^{H(M)\\omega }g^{xr\\omega })modp]modq\\equiv [g^{(H(M)+xr)^{-1}}modp]modq\\equiv (g^kmodp)modq\\equiv r$ 算法的其中的4个函数分别为： $s\\equiv f_1[H(M),k,x,r,q]\\equiv [k^{-1}(H(M)+xr)]modq$ $r=f_2(k,q,p,g)\\equiv (g^kmodp)modq$ $\\omega =f_3(s’,q)\\equiv (s’)^{-1}modq$ $v\\equiv f_4(y,q,g,H(M’),\\omega ,r’)\\equiv [(g^{(H(M’)\\omega )modq}y^{r’\\omega modq})modp]modq$ DSA实例实验将对消息“i love you，china”进行签名。 在DSATool.exe程序中，选择大素数P的位数为512，数据呈现格式为10进制，生成如下所示的大素数P、素因子Q、G以及用户秘密钥X和用户公开钥Y。 为待签消息选取如下所示的随机秘密数K，并产生签名(r,s)。K=2553DD1A0EEEABFC7781E5444DCD517932AB269E 对该签名进行验证，计算能成功通过。 当修改签名中的某一位时（如将第一位7改为8），则验证将无法通过。 通过上述检测可以验证DSA的有效性和雪崩效应。","tags":[]},{"title":"一些方便好用的常用命令","date":"2022-05-26T15:27:14.000Z","path":"2022/056ac63caa.html","text":"本文记录一些平时遇到的没必要记忆却又需要的指令 VSCode终端编码方式修改VScode的默认编码方式为UTF-8，中国地区下cmd的编码方式GBK，所以会导致在终端运行程序打印中文出乱码的情况，修改编码方式即可 在终端运行以下指令即可修改cmd编码方式： chcp 65001 //UTF-8编码 chcp 936 //GBK编码 国内快速访问Github 打开IPAddress.com网站,查询下列三个地址的ip github.comassets-cnd.github.comgibhut.global.ssl.fastly.net 修改本地hosts文件(window系统) 在C:\\Windows\\System32\\drivers\\etc 找到hosts文件，然后添加下列数据，注意把下面的ip改成你自己查询到ip地址。 140.82.114.3 github.com 185.199.108.153 assets-cdn.github.com 199.232.69.194 github.global.ssl.fastly.net 刷新本地dns缓存 Win+R打开cmd，输入命令 ipconfig/flushdns 此时就配置成功了，然后就可以去访问啦 当然科学上网也是可以的 windows查看文件命令dir //查看当前文件下文件夹详细信息 dir /b //查看当前文件夹下文件夹 dir /b /s //查看当前文件夹下文件夹及文件信息","tags":[{"name":"command","slug":"command","permalink":"https://kpl0111.github.io/blog/tags/command/"}]},{"title":"MarkDown常用语法","date":"2022-05-26T15:26:29.000Z","path":"2022/05d18ae5e4.html","text":"一些常用基本语法不过多介绍，详细可以参看MarkDown官方教程这里只介绍一些实用但是容易被忽视的一些语法 MarkDown引用使用标记符 &gt; 对内容进行引用： 引用一段内容 引用一段内容 引用的多层嵌套：只要根据层次加上不同数量的 &gt; 符号 示例： &gt; 请问 Markdwon 怎么用？ - 小白 &gt;&gt; 自己看教程！ - 愤青 &gt;&gt;&gt; 教程在哪？ - 小白 &gt;&gt;&gt;&gt; 我也不知道在哪！ - 愤青 &gt;&gt;&gt;&gt;&gt; 那你回答个屁。 - 小白 显示效果： 请问 Markdwon 怎么用？ - 小白 自己看教程！ - 愤青 教程在哪？ - 小白 我也不知道在哪！ - 愤青 那你回答个屁。 - 小白 引用其它要素：引用的区块内也可以使用其他的语法，包括标题、列表、代码区块等。 示例： &gt; 1.1 这是第一行列表项。 &gt;&gt; 2.1 这是第二行列表项。 &gt;&gt;&gt; - 这是第三行列表项。 &gt; ### 给出一些例子代码： 显示效果： 1.1 这是第一行列表项。 2.1 这是第二行列表项。 这是第三行列表项。 给出一些例子代码： 引用中内容换行：有时候引用的内容太长，需要分段落层次，可以使用 &lt; br &gt; 实现换行。 举例： &gt; $\\underline{幽默小故事，笑死人不偿命}$&lt;br&gt; 我：“老板，你这清炒油麦菜是荤菜还是素菜？ 老板：“当然是素菜了”&lt;br&gt; 我：“那这条虫是怎么回事” 老板：“呃……它也是来吃饭的。”&lt;br&gt; 我：“它吃饭凭什么我付钱？我又不认识它！” 老板哭着说：“它为了这顿饭，把命都丢了，你还能要求它AA制吗？” 显示效果： 下划线示例： $\\underline{给这条语句加一个下划线}$ $$\\underline{给这条语句加一个下划线}$$ 效果：","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://kpl0111.github.io/blog/tags/MarkDown/"}]},{"title":"LeetCode笔记-数组","date":"2022-05-25T11:55:34.000Z","path":"2022/05fcf9ff47.html","text":"本篇为个人笔记，内容或有错误。图片部分源于代码随想录，侵删。 数组需要两点注意的是： 数组下标都是从0开始的 数组内存空间的地址是连续的 正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址，而且数组不能增删，只能覆盖。在C++中二维数组在地址空间上是连续的。但是Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。所以看不到每个元素的地址情况。 二分使用二分的前提是： 有序数组 无重复元素 使用二分时一般需要注意边界条件的处理，一般包括以下两种情况： 左闭右闭 左闭右开 二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 双指针使用双指针可以实现滑动窗口等操作，避免了循环嵌套，大大降低了时间复杂度 螺旋矩阵要注意四个方向临界条件以及区间类型都要一致","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://kpl0111.github.io/blog/tags/LeetCode/"}]},{"title":"MD5加密算法C++实现","date":"2022-05-23T12:10:38.000Z","path":"2022/05d90a8c79.html","text":"实验目的本次实验通过C++编程实现MD5加密算法，通过了解MD5算法加深对Hash函数的认识 实验原理Hash 函数是将任意长的数字串转换成一个较短的定长输出数字串的函数，输出的结果称为 Hash 值。Hash 函数具有如下特点： 快速性：对于任意一个输入值 x，由 Hash 函数H(x) ，计算 Hash值 y，即H(x) = y是非常容易的 单向性：对于任意一个输出值 y，希望反向推出输入值 x，使得H(x) = y，是非常困难的。 无碰撞性：包括强无碰撞性和弱无碰撞性，一个好的 Hash 函数应该满足强无碰撞性，即找到两个不同的数字串 x 和 y，满足H(x) = H(y)，在计算上是不可能的。 MD5算法满足Hash特性，然而需要说明的是,2004年8月，在Crypto2004国际密码学会议上，山东大学王小云教授发现了一种找到MD5散列函数的碰撞的方法，即可以找到两个不同的输入x和y，得到相同的Hash结果。这一发现意味着采用MD5算法的数字签名、完整性检验等信息安全应用系统将不在安全了，这就促使信息安全系统的设计者尽快去寻找和探索新的Hash算法。 MD5算法模块拆解 获取输入，该模块用于获取一段明文字符，不定长 对获取的不定长字符串进行填充,使其字节长度满足n*512 + 448, 填充规则是第一位填充1，后续填充0，直至满足上述条件，最后再用一个64为二进制字符串表示明文长度，这样填充之后长度为(n + 1)*512 // 填充字符串 vector&lt;unsigned int&gt; padding(string src) { // 以512位,64个字节为一组 unsigned int num = ((src.length() + 8) / 64) + 1; vector&lt;unsigned int&gt; rec(num*16); strlength = num*16; for(unsigned int i = 0; i &lt; src.length(); i++){ // 一个unsigned int对应4个字节，保存4个字符信息 rec[i&gt;&gt;2] |= (int)(src[i]) &lt;&lt; ((i % 4) * 8); } // 补充1000...000 rec[src.length() &gt;&gt; 2] |= (0x80 &lt;&lt; ((src.length() % 4)*8)); // 填充原文长度 rec[rec.size()-2] = (src.length() &lt;&lt; 3); return rec; } 字符串分块函数，将上述填充之后的字符串分割为L个512字节长度的字符串 循环压缩函数：对每个512-bit分组进行64轮迭代运算 对分组（A, B, C, D）中的A进行迭代运算 公式为：A &lt;= B + ((A + f(B,C,D) + X[k] + T[i])) &lt;&lt; S[i] 其中： A,B,C,D代表MD5缓冲区当前的数值 f为轮函数，1-16轮迭代使用F函数，17-32轮迭代使用G函数，33-48轮迭 代使用H函数，49-64轮迭代使用I函数 // F函数 unsigned int F(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; c) | ((~b) &amp; d); } // G函数 unsigned int G(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; d) | (c &amp; (~d)); } // H函数 unsigned int H(unsigned int b, unsigned int c, unsigned int d) { return b ^ c ^ d; } // I函数 unsigned int I(unsigned int b, unsigned int c, unsigned int d) { return c ^ (b | (~d)); } // 移位操作函数 unsigned int shift(unsigned int a, unsigned int n) { return (a &lt;&lt; n) | (a &gt;&gt; (32 - n)); } X[k]代表当前处理消息分组的第k个32位字，X[k]由第n轮迭代对应的顺序表决定 T[i]代表T表的第i项的值，T[i] = int(2^32 * |sin(i)|) S[i]对应第i轮的左循环移位的s值 对分组（A,B,C,D）作循环轮换 公式为：（B,C,D,A）&lt;=（A,B,C,D） 按照1， 2步骤进行四轮循环压缩 // 循环压缩 void iterateFunc(unsigned int* X, int size = 16) { unsigned int a = tempA, b = tempB, c = tempC, d = tempD, rec = 0, g, k; for(int i = 0; i &lt; 64; i++) { if(i &lt; 16) { // F迭代 g = F(b, c, d); k = i; } else if(i &lt; 32) { // G迭代 g = G(b, c, d); k = (1 + 5*i) % 16; } else if(i &lt; 48) { // H迭代 g = H(b, c, d); k = (5 + 3*i) % 16; } else { // I迭代 g = I(b, c, d); k = (7*i) % 16; } rec = d; d = c; c = b; b = b + shift(a + g + X[k] + T[i], s[i]); a = rec; } tempA += a; tempB += b; tempC += c; tempD += d; } MD5编码主函数：用于调用前面的功能函数对明文字符串进行MD5编码 输入待加密的明文字符串 对明文字符串进行填充 对填充后的明文字符串进行分块（$Y_q$） 使用预设的初始值初始化MD5缓冲区间（IV） 对各个分块字符串利用公式HMD5($CV_(i-1), Y_i$)进行循环压缩，运算结果作为下一块的输入（$CV_i$） 当所有的分块迭代完成后，输出结果$CV_L$，L表示最后一个分块的序号 // MD5加密函数 string encode(string src) { vector&lt;unsigned int&gt; rec = padding(src); for(unsigned int i = 0; i &lt; strlength/16; i++) { unsigned int num[16]; for(int j = 0; j &lt; 16; j++) { num[j] = rec[i*16+j]; } iterateFunc(num, 16); } return format(tempA) + format(tempB) + format(tempC) + format(tempD); } 程序流程图 测试结果对测试数据进行测试，测试结果如下： 雪崩测试对每个测试数据均在字符串末尾加上一个空格得到密文改变位数如下 数据i 1 2 3 4 5 6 7 平均改变位数 改变位数 31 28 29 30 30 29 28 29 源代码//MD5.h #pragma once #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; using namespace std; #define A 0x67452301 #define B 0xefcdab89 #define C 0x98badcfe #define D 0x10325476 const char str16[] = \"0123456789abcdef\"; const unsigned int T[] = { 0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee, 0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501, 0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be, 0x6b901122,0xfd987193,0xa679438e,0x49b40821, 0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa, 0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8, 0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed, 0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a, 0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c, 0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70, 0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05, 0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665, 0xf4292244,0x432aff97,0xab9423a7,0xfc93a039, 0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1, 0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1, 0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391 }; const unsigned int s[] = { 7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22, 5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20, 4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23, 6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21}; // 第一部分是要进行 HASH 运算的原始明文，第二部分则是其对应的 HASH 值 static const struct data{ string msg; unsigned char hash[16]; }tests[] = { { \"\", { 0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04, 0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e } }, { \"a\", {0x0c, 0xc1, 0x75, 0xb9, 0xc0, 0xf1, 0xb6, 0xa8, 0x31, 0xc3, 0x99, 0xe2, 0x69, 0x77, 0x26, 0x61 } }, { \"abc\", { 0x90, 0x01, 0x50, 0x98, 0x3c, 0xd2, 0x4f, 0xb0, 0xd6, 0x96, 0x3f, 0x7d, 0x28, 0xe1, 0x7f, 0x72 } }, { \"message digest\", { 0xf9, 0x6b, 0x69, 0x7d, 0x7c, 0xb7, 0x93, 0x8d, 0x52, 0x5a, 0x2f, 0x31, 0xaa, 0xf1, 0x61, 0xd0 } }, { \"abcdefghijklmnopqrstuvwxyz\", { 0xc3, 0xfc, 0xd3, 0xd7, 0x61, 0x92, 0xe4, 0x00, 0x7d, 0xfb, 0x49, 0x6c, 0xca, 0x67, 0xe1, 0x3b } }, { \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", { 0xd1, 0x74, 0xab, 0x98, 0xd2, 0x77, 0xd9, 0xf5, 0xa5, 0x61, 0x1c, 0x2c, 0x9f, 0x41, 0x9d, 0x9f } }, { \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", { 0x57, 0xed, 0xf4, 0xa2, 0x2b, 0xe3, 0xc9, 0x55, 0xac, 0x49, 0xda, 0x2e, 0x21, 0x07, 0xb6, 0x7a } }, }; class MD5 { private: unsigned int tempA, tempB, tempC, tempD, strlength; public: MD5() { tempA = A; tempB = B; tempC = C; tempD = D; strlength = 0; } // 填充字符串 vector&lt;unsigned int&gt; padding(string src) { // 以512位,64个字节为一组 unsigned int num = ((src.length() + 8) / 64) + 1; vector&lt;unsigned int&gt; rec(num*16); strlength = num*16; for(unsigned int i = 0; i &lt; src.length(); i++){ // 一个unsigned int对应4个字节，保存4个字符信息 rec[i&gt;&gt;2] |= (int)(src[i]) &lt;&lt; ((i % 4) * 8); } // 补充1000...000 rec[src.length() &gt;&gt; 2] |= (0x80 &lt;&lt; ((src.length() % 4)*8)); // 填充原文长度 rec[rec.size()-2] = (src.length() &lt;&lt; 3); return rec; } // F函数 unsigned int F(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; c) | ((~b) &amp; d); } // G函数 unsigned int G(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; d) | (c &amp; (~d)); } // H函数 unsigned int H(unsigned int b, unsigned int c, unsigned int d) { return b ^ c ^ d; } // I函数 unsigned int I(unsigned int b, unsigned int c, unsigned int d) { return c ^ (b | (~d)); } // 移位操作函数 unsigned int shift(unsigned int a, unsigned int n) { return (a &lt;&lt; n) | (a &gt;&gt; (32 - n)); } // 循环压缩 void iterateFunc(unsigned int* X, int size = 16) { unsigned int a = tempA, b = tempB, c = tempC, d = tempD, rec = 0, g, k; for(int i = 0; i &lt; 64; i++) { if(i &lt; 16) { // F迭代 g = F(b, c, d); k = i; } else if(i &lt; 32) { // G迭代 g = G(b, c, d); k = (1 + 5*i) % 16; } else if(i &lt; 48) { // H迭代 g = H(b, c, d); k = (5 + 3*i) % 16; } else { // I迭代 g = I(b, c, d); k = (7*i) % 16; } rec = d; d = c; c = b; b = b + shift(a + g + X[k] + T[i], s[i]); a = rec; } tempA += a; tempB += b; tempC += c; tempD += d; } // 整理输出 string format(unsigned int num) { string res = \"\"; unsigned int base = 1 &lt;&lt; 8; for(int i = 0; i &lt; 4; i++) { string tmp = \"\"; unsigned int b = (num &gt;&gt; (i * 8)) % base &amp; 0xff; for(int j = 0; j &lt; 2; j++) { tmp = str16[b%16] + tmp; b /= 16; } res += tmp; } return res; } // 编码函数 string encode(string src) { vector&lt;unsigned int&gt; rec = padding(src); for(unsigned int i = 0; i &lt; strlength/16; i++) { unsigned int num[16]; for(int j = 0; j &lt; 16; j++) { num[j] = rec[i*16+j]; } iterateFunc(num, 16); } return format(tempA) + format(tempB) + format(tempC) + format(tempD); } }; \\\\MD5.cpp #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; #include &lt;string.h&gt; #include \"MD5.h\" using namespace std; int main() { MD5 test; string a = \"\"; cout &lt;&lt; \"Plain Text: \"; getline(cin,a); cout &lt;&lt; \"result: \" &lt;&lt; test.encode(a) &lt;&lt; endl; return 0; }","tags":[{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"},{"name":"密码学","slug":"密码学","permalink":"https://kpl0111.github.io/blog/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"MD5","slug":"MD5","permalink":"https://kpl0111.github.io/blog/tags/MD5/"}]},{"title":"关于Eclipse安卓开发中的文件调用","date":"2022-05-17T18:35:09.000Z","path":"2022/05442e8a7e.html","text":"问题描述最近在用Eclipse做Android的时候使用jxl库简单处理了xls文件，由于我对xls文件处理不太熟练，于是创建了一个Java项目进行简单测试，没问题之后直接在安卓项目使用，但是却发现即使我把xls文件放在assets文件夹下并在Build Path里面勾选了assets文件夹依旧会抛出找不到文件的错误：FileNotFoundException，采用了 file:///android_asset/xxx.html 和 /assets/xxx.xls 均没有效果，依旧会抛出错误。 问题原因一般情况下我们在本地项目引用文件，直接用绝对路径或者相对路径都可以，这两者都可以在资源文件的属性里面查看，如下图所示： Android项目打包生成APK之后，会将项目打包成Jar包或者war包，此时就不会存在 assets/resources 目录，JVM会在编译项目时，主动将 java文件编译成 class文件 和 resources 下的静态文件放在 target/classes目录下； 也就是说我们在打包之后上述目录结构已经发生变化，此时再用原来的路径去索引文件，必然是索引不到的，那么我们还想去索引这个文件怎么办呢？ 解决方案我们可以用Java提供的方法获取文件流 InputStream input = this.getClass().getResourceAsStream(\"/assets/xxx.xls\"); 从而去使用文件。 需要注意的是，路径的开头的 / 是不能少的，它代表的就是从src目录-根目录，而资源文件路径就是从src开始找，这样工程打包以后同样可以找到路径。 参考：Java项目读取resources资源文件路径那点事","tags":[{"name":"Android","slug":"Android","permalink":"https://kpl0111.github.io/blog/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://kpl0111.github.io/blog/tags/Java/"}]},{"title":"Vim参数推荐","date":"2022-02-18T15:06:31.000Z","path":"2022/0257c5ab7b.html","text":"“ All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by“ the call to :runtime you can find below. If you wish to change any of those“ settings, you should do it in this file (/etc/vim/vimrc), since debian.vim“ will be overwritten everytime an upgrade of the vim packages is performed.“ It is recommended to make changes after sourcing debian.vim since it alters“ the value of the ‘compatible’ option. runtime! debian.vim “ Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.“ This happens after /etc/vim/vimrc(.local) are loaded, so it will override“ any settings in these files.“ If you don’t want that to happen, uncomment the below line to prevent“ defaults.vim from being loaded.“ let g:skip_defaults_vim = 1 “ Uncomment the next line to make Vim more Vi-compatible“ NOTE: debian.vim sets ‘nocompatible’. Setting ‘compatible’ changes numerous“ options, so any other options should be set AFTER setting ‘compatible’.“set compatible “ Vim5 and later versions support syntax highlighting. Uncommenting the next“ line enables syntax highlighting by default.syntax on “ If using a dark background within the editing area and syntax highlighting“ turn on this option as wellset background=dark “ Uncomment the following to have Vim jump to the last position when“ reopening a file“au BufReadPost * if line(“‘\"“) &gt; 1 &amp;&amp; line(“‘\"“) &lt;= line(“$”) | exe “normal! g’\"“ | endif “ Uncomment the following to have Vim load indentation rules and plugins“ according to the detected filetype.if has(“autocmd”) filetype plugin indent onendif “ The following are commented out as they cause vim to behave a lot“ differently from regular Vi. They are highly recommended though.“set showcmd “ Show (partial) command in status line.set showmatch “ Show matching brackets.set ignorecase “ Do case insensitive matchingset smartcase “ Do smart case matchingset incsearch “ Incremental search“set autowrite “ Automatically save before commands like :next and :makeset hidden “ Hide buffers when they are abandoned“set mouse=a “ Enable mouse usage (all modes) “ Source a global configuration file if availableif filereadable(“/etc/vim/vimrc.local”) source /etc/vim/vimrc.localendif setlocal noswapfileset bufhidden = hide“colorscheme eveningset numberset cursorlineset rulerset shiftwidth = 4set softtabstop = 4set tabstop = 4set nobackupset autochdirset backupcopy = yesset hlsearchset noerrorbellsset novisualbellset t_vb=set matchtime=2set magicset smartindentset backspace=ident,eol,startset cmdheight=1set laststatus=2set statusline=\\ %&lt;%F[%1*%M%*%n%R%H]%=\\ %y\\ %0(%{&amp;fileformat}\\ %{&amp;encoding}\\ Ln\\ %l.\\Col\\ %c/%L%)set foldenableset foldmethod=syntaxset foldcolumn=0setlocal foldlevel=1nnoremap @=((foldclosed(line(‘,’)) &lt; 0) ? ‘zc’ : ‘zo’)","tags":[{"name":"Vim","slug":"Vim","permalink":"https://kpl0111.github.io/blog/tags/Vim/"}]},{"title":"物联网安全复习总结","date":"2022-01-04T04:29:58.000Z","path":"2022/018a8f3fb6.html","text":"复习时随手记录，并不完整 物联网安全根据国际电信联盟的定义, 物联网( internet of things, IOT) 主要解决: 物品到物品( thing to thing,T2T) 人到物品( human to thing, H2T) 人到人( human to human, H2H)之间的互联 第1章 物联网安全需求分析与其他传统网络相比, 物联网感知节点大都部署在无人监控的场景中, 具有能力脆弱、资源受限等特点,这些都导致很难直接将传统计算机网络的安全算法和协议应用于物联网 从物联网的功能上来说，应该具备四个特征： 一是全面感知能力，可以利用RFID、传感器、二维条形码等获取被控/被测物体的信息; 二是数据信息的可靠传递，可以通过各种电信网络与互联网的融合，将物体的信息实时准确地传递出去; 三是可以智能处理，利用现代控制技术提供的智能计算方法，对大量数据和信息进行分析和处理，对物体实施智能化的控制。 四是可以根据各个行业、各种业务的具体特点形成各种单独的业务应用，或者整个行业及系统的建成应用解决方案 物联网结构和层次： 感知识别层：重点考虑数据隐私的保护； 传感器，RFID，二维条形码… 网络构建层：重点考虑网络传输安全； 互联网 无线宽带网 无线低速网 移动通信网 管理服务层：重点考虑信息安全； 管理服务层位于感知识别和网络构建层之上，综合应用层之下，人们通常把物联网应用冠以“智能”的名称，如智能电网、智能交通、智能物流等，其中的智慧就来自这一层 数据库：海量性，多态性，关联性，语义性 海量信息存储：网络附加存储（NAS ，Network Attached Storage）和专用存储区域网络（SAN ,Storage Area Network） 数据中心 搜索引擎 数据挖掘技术 综合应用层：重点考虑应用系统安全； 智能物流 智能交通 绿色建筑 智能电网 环境监测 与互联网相比, 物联网主要实现人与物、物与物之间的通信, 通信的对象扩大到了物品。 感知层的安全需求可以总结为如下几点： 机密性：多数网络内部不需要认证和密钥管理，如统一部署的共享一个密钥的传感网。 密钥协商：部分内部节点进行数据传输前需要预先协商会话密钥。 节点认证：个别网络（特别当数据共享时）需要节点认证，确保非法节点不能接入。 信誉评估：一些重要网络需要对可能被敌手控制的节点行为进行评估，以降低敌手入侵后的危害（某种程度上相当于入侵检测）。 安全路由：几乎所有网络内部都需要不同的安全路由技术。 物联网网络构建层将会主要遇到下列安全挑战： 拒绝服务攻击（DOS）攻击、分布式拒绝服务攻击（DDOS）攻击； 假冒攻击、中间人攻击等； 跨异构网络的网络攻击。 网络构建层的安全机制可分为端到端机密性和节点到节点机密性。 对于端到端机密性，需要建立如下安全机制： 端到端认证机制、 端到端密钥协商机制、 密钥管理机制 机密性算法选取机制等。 管理服务层的安全挑战包括如下几个方面： 来自于超大量终端的海量数据的识别和处理； 智能变为低能； 自动变为失控（可控性是信息安全的重要指标之一）； 灾难控制和恢复； 非法人为干预（内部攻击）； 设备（特别是移动设备）的丢失 为了满足物联网智能管理服务层的基本安全需求，需要如下的安全机制。 可靠的认证机制和密钥管理方案； 高强度数据机密性和完整性服务； 可靠的密钥管理机制，包括PKI和对称密钥的有机结合机制； 可靠的高智能处理手段； 入侵检测和病毒检测； 恶意指令分析和预防，访问控制及灾难恢复机制； 保密日志跟踪和行为分析，恶意行为模型的建立； 密文查询、秘密数据挖掘、安全多方计算、安全云计算技术等； 移动设备文件（包括秘密文件）的可备份和恢复； 移动设备识别、定位和追踪机制 应用层的安全挑战和安全需求主要来自于： 如何根据不同访问权限对同一数据库内容进行筛选； 如何提供用户隐私信息保护，同时又能正确认证； 如何解决信息泄露追踪问题； 如何进行计算机取证； 如何销毁计算机数据； 如何保护电子产品和软件的知识产权。 基于物联网综合应用层的安全挑战和安全需求，需要如下的安全机制： 有效的数据库访问控制和内容筛选机制； 不同场景的隐私信息保护技术； 叛逆追踪和其他信息泄露追踪机制； 有效的计算机取证技术； 安全的计算机数据销毁技术； 安全的电子产品和软件的知识产权保护技术 第2章 物联网安全技术框架现代经常涉及的信息安全技术主要有数据加密、身份认证、访问控制和口令、数字证书、电子签证机关（CA）、数字签名等常用信息安全技术 安全技术简介 数据加密 身份验证 访问控制 自由访问控制：用户有权对自身所创建的访问对象进行访问 强制访问控制，按照系统规则对用户所创建对象进行控制，即便是创建者，也可能无权访问对象 口令（密码）：实际上，弱口令。缺省口令和没有口令的账号均应该从数据库中删除 网络数据流窃听口令，如果明文传输，则可能被窃取 认证消息截取/重放，用加密口令实现系统登录 字典攻击 穷举攻击，字典攻击的加强版，使用字符串的全集作为字典 窥探，窥探合法用户输入口令过程 社交工程 垃圾搜索 数字证书：一个数字文件，一般由四部分构成 持有人的姓名，地址等信息 公开密钥 证书序号，有效期限 发证单位的数字签名 数字签名 本身是一种解密过程，而且是非对称密钥，类似于与校验和 使用用途，区别身份，鉴权，保证完整性，不可抵赖（即承认发送来源） 数据加密 分类 私用密钥（对称密钥） 信息的发送方和接收方使用同一个密钥进行加密和解密 适合对大数据量进行加密，密钥管理困难 公共密钥（非对称密钥） 信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，但加密和解密速度却比对称密钥加密慢得多 能够完成发送方的身份认证和接收方无法伪造报文的功能 通过公钥推算出私钥的算法必须不可能实现 物联网中的加密机制传统的IP网络加密：需要在感知层运行加密/解密算法，需要存储开销，CPU开销，而且需要能量 节点认证机制：PKI（Public Key Infrastructure ）即“公钥基础设施”，是一种遵循既定标准的密钥管理平台,它能够为所有网络应用提供加密和数字签名等密码服务及所必需的密钥和证书管理体系。简单来说，PKI就是利用公钥理论和技术建立的提供安全服务的基础设施 访问控制，由给人授权访问转变为给机器授权访问 态势分析及其他：评估现在以及未来一段时间内的网络运行状态 实现统一的密钥管理系统可以采用两种方式: 一是以互联网为中心的集中式管理方式 二是以各自网络为中心的分布式管理方式 其安全需求体现在 密钥生成或更新算法的安全性 前向私密性 后向私密性或可扩展性 抗同谋攻击 源端认证和新鲜性 第3章 密码与身份认证技术密码学基本概念密码学是主要研究通信安全和保密的学科，他包括两个分支：密码编码学和密码分析学 密码编码学主要研究对信息进行变换，以保护信息在传递过程中不被敌方窃取、解读和利用的方法 密码分析学则于密码编码学相反，它主要研究如何分析和破译密码 使用密码学可以达到以下目的： 保密性：防止用户的标识或数据被读取。 数据完整性：防止数据被更改。 身份验证：确保数据发自特定的一方 加密算法应在公开时不影响明文和密钥的安全 从密码学发展历程来看，可分为： 古典密码（以字符为基本加密单元的密码） 代替密码 单表替换密码 凯撒密码：某字母用右边第k个字母表示，Z后面是A 密钥短语密码 同音替换密码 多字母 组替换 密码 多表替换密码 置换密码 现代密码（以信息块为基本加密单元的密码） 分组密码 流密码 密钥加密系统 对称密码系统的安全性依赖于以下两个因素。 第一，加密算法必须是足够强的，仅仅基于密文本身去解密信息在实践上是不可能的； 第二，加密方法的安全性依赖于密钥的秘密性，而不是算法的秘密性，因此我们没有必要确保算法的秘密性，而需要保证密钥的秘密性 对称密码体制的特点是：对称加密算法使用起来简单快捷，密钥较短，且破译困难。 密钥难于安全传送。 密钥量太大，难于进行管理。 无法满足互不相识的人进行私人谈话时保密要求。 难于解决数字签名验证的问题。 相对于对称密钥密码体系，非对称密钥加密系统最大的特点在于加密和解密使用不同的密钥 非对称密钥技术的优点是：易于实现，使用灵活，密钥较少，可以满足互不相识的人之间进行私人谈话时的保密性要求，可以完成数字签名和数字鉴别。 弱点在于：要取得较好的加密效果和强度，必须使用较长的密钥。 现代加密算法对称加密算法在对称加密算法中，只有一个密钥用来加密和解密信息，即加密和解密采用相同的密钥。常用的算法包括： DES（Data Encryption Standard）： 数据加密标准，速度较快，适用于加密大量数据的场合。 3DES（Triple DES）： 是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。 AES（Advanced Encryption Standard）： AES高级加密标准，是下一代的加密算法标准，速度快，安全级别高 非对称加密算法 RSA：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的； RSA是第一个既能用于数据加密也能用于数字签名的算法 DSA（Digital Signature Algorithm）： 数字签名算法，是一种标准的 DSS（数字签名标准）； 除了加密外，公开密钥密码学最显著的成就是实现了数字签名。 加密算法的选择 我们应该根据自己的使用特点来确定： 由于非对称加密算法的运行速度比对称加密算法的速度慢很多，当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。 对称加密算法不能实现签名，因此签名只能非对称算法。 由于对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。 在实际的操作过程中，我们通常采用的方式是： 采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。 认证与身份证明身份证明系统的组成 示证者P(Prover)，出示证件的人，又称作申请者(Claimant)，提出某种要求； 验证者V(Verifier)，检验示证者提出的证件的正确性和合法性，决定是否满足其要求； 攻击者，可以窃听和伪装示证者骗取验证者的信任。 可信赖者，参与调解纠纷。必要时的第四方 物联网认证与访问控制目前常用的身份识别技术可以分为两大类 一类是基于密码技术的各种电子ID身份鉴别技术； 另一类是基于生物特征识别的识别技术 基于零知识证明的识别技术 零知识洞穴 第4章 RFID系统安全与隐私RFID系统一般由3大部分构成： 标签 标签放置在要识别的物体上，携带目标识别数据，是RFID系统真正的数据载体，由耦合元件以及微电子芯片(包含调制器、编码发生器、时钟及存储器)组成 读写器 用于读或读/写标签数据的装置，由射频模块(发送器和接收器)、控制单元、与标签连接的藕合单元组成 后台数据库 后台服务器包含数据库处理系统，存储和管理标签相关信息，如标签标识、阅读器定位、读取时间等 工作原理 RFID系统的基本工作原理是：阅读器与标签之间通过无线信号建立双方通信的通道，阅读器通过天线发出电磁信号，电磁信号携带了阅读器向标签的查询指令。 当标签处于阅读器工作范围时，标签将从电磁信号中获得指令数据和能量，并根据指令将标签标识和数据以电磁信号的形式发送给阅读器，或根据阅读器的指令改写存储在RFID标签中的数据 阅读器可接收RFID标签发送的数据或向标签发送数据，并能通过标准接口与后台服务器通信网络进行对接，实现数据的通信传输。 根据标签能量获取方式，RFID系统工作方式可分为：近距离的电感耦合方式和远距离的电磁耦合方式 RFID的安全和攻击模式 安全 信息及隐私泄露 RFID的隐私威胁 隐私信息泄露 跟踪 效率和隐私保护的矛盾 攻击模式 窃听 中间人攻击 欺骗、重放、克隆 欺骗(spoofing)：基于已掌握的标签数据通过阅读器 重放(replaying)：将标签的回复记录并回放 克隆(cloning)：形成原来标签的一个副本 拒绝服务攻击(Denial-of-service attack, DoS)拒绝服务攻击是通过不完整的交互请求消耗系统资源，使系统不能正常工作 物理破解(corrupt)物理破解采用如下一些步骤对RFID射频系统进行破坏 篡改信息(modification)进行非授权的修改或擦除标签数据，从而达到篡改信息的目的。 RFID病毒(virus, malware)包括EPC标签在内的RFID标签可以被用来携带病毒，并能攻击电脑系统。 其他隐患：RFID的安全和隐私问题涉及到的其他隐患还包括：电子破坏、屏蔽干扰和拆除等。 RFID系统根据分层模型可划分为3层：应用层、通信层和物理层，ISO／IEC 18000标准定义了读写器与标签之间的双向通信协议，其基本的通信模型如下图。 安全RFID系统的基本特征 机密性 完整性 可用性 真实性 隐私性 第5章 WSN无线传感器网络安全无线传感器网络与安全相关的特点 资源受限，通信环境恶劣。 部署区域的安全无法保证，节点易失效。 网络无基础框架。 部署前地理位置具有不确定性。","tags":[{"name":"物联网安全","slug":"物联网安全","permalink":"https://kpl0111.github.io/blog/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"},{"name":"复习","slug":"复习","permalink":"https://kpl0111.github.io/blog/tags/%E5%A4%8D%E4%B9%A0/"}]},{"title":"编译系统原理复习提纲","date":"2022-01-01T07:31:41.000Z","path":"2022/0178868943.html","text":"编译系统原理[toc] 内容过多，未完全整理 题型设计 单项选择（12*2） 编译阶段所做事情考察 编译器和解释器的区分 ϵ是空符号串 正则表达式本质上表述的是符号串集合 NFA，DFA和CFG 设计题（6*4） 正则表达式表示的含义 设计正则表达式 设计上下文无关文法 解答题 Thompson构造法 子集构造法 终结符，非终结符，开始符号 消除左递归 构造预测分析表 流图 三地址码 优化 真题C++编译器检查数组下标越界是在_____阶段?ϵ为空符号串 概述广义的编译器：浏览器 分析-综合模型两个基本部分 分析：将源程序分解为基本组成部分，生成中间表示形式 中间表示形式：树 节点-操作 孩子-参数 综合：从中间表示形式构建目标程序 源程序分析的三个阶段 线性分析/词法分析/扫描 由左至右扫描源程序字符序列➔token，单词（记号）——具有组合意义的字符序列 忽略空格、回车等，将字符组合为单词 层次分析/语法分析 单词序列➔有意义的集合，语法单位 将词法分析产生的单词组合为语法短语 语法分析树：内部节点-运算符，叶节点-运算对象 语义分析 检查程序各部分是否正确符合语义 语法结构的递归定义 表达式 标识符是表达式 数是表达式 若expression1和expression2是表达式，则expression1 + expression2 、expression1 * expression2、( expression1 )也是表达式 1、2——基本规则，3——递归定义 文法（grammar） 语句（statement）定义 若identifier1是一个标识符，expression2是一个表达式，则identifier1 := expression2是一个语句 若expression1是一个表达式，statement2是一个语句，则while ( expression1 ) do statement2和if ( expression1 ) then statement2也是语句 文法：处理token相互关系和结构的一组规则 程序优化技术现状 CPU上的过程内优化基本成熟 过程间优化能力仍然受限 面向GPU等新型体系结构的编译优化还有空间 一个简单的编译器字符流 → 词法分析器 → 单词流 → 语法制导翻译器 → 中间表示形式 语法制导翻译器：语法分析 + 中间代码生成 语法定义上下文无关文法：描述语言的语法结构 组成： 一组终结符号，单词，基本符号 一组非终结符号（语法变量），语法范畴，语法概念 一组产生式，定义语法范畴 产生式：A→α A—一个非终结符，左部 α—终结符或/与非终结符串，右部 一个特定的非终结符——开始符号，start symbol 几个概念 Σ：有穷字母表，元素——符号 符号串：Σ中符号构成的有穷序列 空字：不含任何符号的序列，ε Σ*：符号串全体，包括空字 φ：空集{}，区分ε，{}，{ε} Σ*的子集U、V的积（连接）{ αβ|α ∈ U 且 β ∈ V} UV≠VU，(UV)W=U(VW) V自身的n次积（连接）记为$V^{n}$ $V^{0}={ε}$ V的闭包（closure） $V* = V^{0} ⋃ V^{1} ⋃ V^{2} ⋃ V^{3} ⋃ …$ 每个符号串，都是V中符号串有限次连接 正则闭包，$V^{+}=VV*$ 四元式定义上下文无关文法 $(V_{T}, V_{N}, S, P)$ $V_{T}$：非空有限集，终结符号集合 $V_{N}$：非空有限集，非终结符号集合 S：开始符号 P：产生式集合（有限集） 每个产生式形式A→α，其中 $A ∈ V_{N},α ∈(V_{T} ⋃ V_{N})*$ 关于A的产生式S至少在某个产生式左部出现一次 符号约定 expr → expr + digit expr → expr – digit expr → digit digit → 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 数字、运算符、黑体字符串——终结符 斜体字符串——非终结符 左部相同可合并，‘|’——“或”的意思expr → expr + digit | expr - digit | digit候选式 推导 单词串(string)：0个或多个单词构成的序列 推导(derive) 由开始符号作为推导起点 用产生式右部替换左部非终结符 反复替换，最终得到单词串 语言(language) 语法所定义的语言——可由开始符号推导出的所有单词串的集合 二义性：多个语法分析树生成相同的单词串——多个意义 语法制导翻译 翻译：为生成代码，需保存语言结构的类型、代码位置、代码数量等 属性(attribute)：类型、串、内存位置等 语法制导翻译syntax-directed translation 语法制导定义syntax-directed definition 属性与语法结构相关联➔指明翻译方法 翻译模式，translation scheme 表达式E的后缀形式Postfix(E)如何生成： E为变量或常量：Postfix(E) = E $E = E_{1} op E_{2}$，op—二元运算符，$E_{1}、E_{2}$—子表达式： $Postfix(E) = Postfix(E_{1} op E_{2})= Postfix(E_{1}) Postfix(E_{2}) op$ $E = (E_{1})$： $Postfix(E) = Postfix(E_{1})$ (9 - 5) + 2 ➔9 5 - 2 + 9 - (5 + 2) ➔9 5 2 + - 语法制导定义 基于语言的上下文无关文法 语法符号——一组属性 产生式——一组语义规则(semantic rule)——属性值计算规则 CFG+语义规则➔语法制导定义 语法制导翻译的基本过程（翻译——输入→输出映射过程） 输入单词串x➔语法分析树 节点n标记为X，X.a——X的属性 计算节点n的X.a的值——利用X产生式的语义规则➔ “注释语法分析树”（annotated parse tree） 语法制导定义的实现 树的遍历：计算完所有孩子节点的属性，父节点才能计算自身属性 后序遍历，深度优先 翻译模式 translation scheme 同样基于上下文无关文法 语义动作（semantic action，程序片断）嵌入产生式的右部 语法分析树添加额外节点 指明了语义动作执行顺序 语法分析 确定一个单词串是否可由一个文法生成 构造语法分析树 时间复杂度$O(n^3)➔O(n)$ 自顶向下分析方法，top-down语法树构造——由根向叶适合手工编写语法分析器 自底向上分析方法，bottom-up语法树构造——由叶向根适用更多文法，自动生成工具 自顶向下分析方法 从根节点（标记为开始符号）开始构造语法树，不断重复以下步骤 对标记为NT A的节点n,选择一个关于A的产生式,利用产生式右部构造n的孩子节点 选择下一个没有扩展（构造孩子节点）的节点，对它执行1 平凡算法 初始状态，只有一个根节点，标记为开始符号，输入指针指向第一个单词 对于NT节点 a) 选择产生式（尝试、回溯）构造孩子节点 b) 对孩子节点从左至右继续分析 对于T节点 a) 与当前输入单词进行比较 b) 若匹配，输入指针前移，处理下一个节点 c) 不匹配，可能需要回溯或报告错误","tags":[{"name":"Lex","slug":"Lex","permalink":"https://kpl0111.github.io/blog/tags/Lex/"},{"name":"Yacc","slug":"Yacc","permalink":"https://kpl0111.github.io/blog/tags/Yacc/"},{"name":"编译系统原理","slug":"编译系统原理","permalink":"https://kpl0111.github.io/blog/tags/%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"编译器","slug":"编译器","permalink":"https://kpl0111.github.io/blog/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"计算机网络复习摘要","date":"2021-12-30T20:53:41.000Z","path":"2021/1210d148d4.html","text":"概述IPV4：32位地址IPv6：128位地址 Internet三个重要理念：➢ 互联网的开放理念➢ 互联网的自组织理念➢ 互联网的分享理念 统计多路复用：主机A和B的报文分组没有固定的到达模式，带宽按需共享，这种方式称为统计多路复用(statistical multiplexing) 网络流量具有很强的突发性，即不平稳，每个独立的流的峰值可能出现在不同时间 结论：流越多，网络平均流量越平滑 报文长度P ：单位“位(bit)”链路长度L ：单位“米”传输速率R ：单位“位/秒”传播时延PROP：电磁波在介质上传播的时间，单位“秒” PROP = L/C，其中C为电磁波传播速度 传输时间TRANSP ：发送长度为P的报文所用的时间 TRANSP = P/R，其中R为传输速率 端端时延Latency：发送端开始传送第一位到接收端接收到最后一位所用的时间，在单一链路上计算方法为： Latency = PROP + TRANSP 当报文分组到达时，如果出口链路忙，报文分组需要在路由器缓存中排队等待，会引入排队时延 往返时延RTT (Round-Trip Time)：从发送方发送数据开始，到发送方收到来自接收方的确认，经历的总时间 时延带宽积 时延带宽积= 传播时延×带宽，即按比特计数的链路长度 若发送端连续发送数据，则在发送的第一个bit即将达到终点时，发送端就已经发送了时延带宽积个bit ，而这些bit都在链路上向前移动 如何将端系统连接到边缘路由器？ 有线接入 数字用户线路(xDSL),电话线 混合光纤同轴电缆(HFC)，电视 光纤宽带(FTTH)，光纤 以太网(Ethernet) 无线接入 无线局域网(WiFi) 移动通信网(4G/5G) 注意两个指标：接入网速率、共享或专用 网络协议的组成要素： 语法：数据与控制信息的结构或格式(协议数据单元PDU) 语义：需要发出何种控制信息，完成何种动作以及做出何种响应 时序：事件实现顺序的详细说明 接口层通常包括数据链路层和物理层 应用层协议及网络编程应用协议与进程通信模型应用：可进行通信的、分布式进程➢ 运行于主机的用户空间➢ 通过交换消息(Messages)实现应用之间的交互➢ 例如：Email、Web等 应用层协议：应用层实体之间的通信规范➢ 定义应用交换的消息和收到消息后采取的行动➢ 使用下层协议(TCP、UDP)提供的通信服务 内容： 消息的类型 如请求request、响应response 消息的语法 如消息包含哪些字段、字段之间如何分割等 消息的语义 字段中信息代表的具体含义 消息的处理 进程何时发送消息、收到消息后的动作等 类型： 公共协议 RFC中定义的协议 可相互兼容 例如：HTTP、SMTP等 专有协议 公司或组织专有 例如：Skype、QQ等 服务指标 数据丢失率 音视频等应用可以容忍一定的数据丢失 文件传输、远程登录等应用要求100%的数据可靠 时延 网络电话、交互游戏等应用对时延有一定的要求 带宽 多媒体等应用需要一定的带宽保证 有些应用则是弹性的 主机的地址标识:主机拥有一个唯一的32位的IPv4地址(或128位的IPv6地址)进程标识符：包括IP地址和端口号 端口号举例: Web服务器进程: 80 Email(SMTP)服务器进程: 25 进程间通信进程：主机中运行的程序 在同一台主机中，两个进程之间按照进程间通信方式进行交互通信(操作系统中定义)不同主机上的进程通信，需要通过交换信息来完成 客户/服务器(C/S)模型 客户向服务器发出服务请求，并接收服务器的响应；服务器等待客户的请求并为客户提供服务 例如：Web浏览器/Web服务器；Email客户端/Email服务器 过程 服务器进程 被动等待 长久在线 固定IP地址 利用集群/云提供扩展性 客户进程 启动与服务器的通信 可能为间歇性连接 可能使用动态IP地址 不与其他客户进行直接通信 对等计算(P2P)模型 最小化(或根本不用)专用服务器 例如：Skype, BitTorrent等 过程 无长久在线的服务器 任意的终端系统之间都可能进行直接通信 端系统之间可能间歇性地进行连接 端系统可能使用动态的IP地址 高可扩展性但维护困难 传输层服务对应用层的支持TCP服务: 面向连接：客户与服务器之间需要建立连接 可靠传输：可保证传递数据无差错 流量控制：发送数据不会超过接收端的容纳容量 拥塞控制: 提供拥塞解决方案 不能提供：时延和带宽保证 UDP服务: 不可靠：不可靠的数据投递 不能提供：连接建立、可靠性、流量控制、拥塞控制、时延和带宽保证 一些常见Socket函数： accept():流方式 connect()：流方式 recv()：流方式 sendto()：数据报方式 recvfrom()：数据报方式 常见CPU的字节序 Big-Endian : PowerPC、IBM、Sun Little-Endian : x86、DEC ARM既可工作在Big-Endian，也可工作在Little-endian 网络使用的字节序：网络通信协议都使用Big-Endian编码序 电子邮件系统 用户代理 (接口) 编辑和发送邮件 接收、读取和管理邮件 管理地址簿 无统一标准 邮件服务器 邮箱：保存用户收到的消息 消息输出队列：消息的发送队列 SMTP协议：邮件服务器之间传递邮件使用的协议 smtp客户: 发送邮件端 smtp服务器: 接收邮件端 邮件地址：一对字符串，用于指定邮件接收者 local-part@domain-name domain-name: 域名 local-part: 域名中的邮箱名 SMTP: 向服务器传递邮件 邮件访问协议: 从邮件服务器的邮箱中获取邮件 POP: 邮局协议[RFC 1939] IMAP: Internet邮件访问协议[RFC 2060] HTTP: 超文本传输协议 邮件消息格式 信封 封装消息 内含传输邮件消息所需的一些信息 目的地址、优先级、安全级别等 消息 消息头 包含用户代理所需的一些控制信息 消息体 文件传输服务与协议 基于TCP/IP的文件传输系统 客户/服务器模型 client: 初始化传输(无论上传还是下载) server: 远端 客户使用TCP协议连接远端服务器 FTP进程模型– 双连接 控制连接 带外控制 TCP的21端口 客户和服务器之间维护的一个FTP会话 用于客户和服务器之间交换命令和响应 在整个会话期间保持活跃 数据传输连接 TCP的20端口 用于传输数据 客户可以在一个会话上向服务器传输多个请求 每个文件请求都会建立一个数据连接 数据传输结束后，释放数据连接 域名系统DNS(Domain Name System)互联网中使用IP地址寻址主机 DNS基本思想： 名字和地址映射关系分布式存放，形成具有层次结构的分布式数据库系统(分布式管理) 通过查询分布式数据库，获得名字到地址的映射，或相反 关键： 如何组织分布式数据库 如何在分布式数据库中查找 DNS服务器组织 顶级域名服务器(Top-Level Domain, TLD) 根服务器 负责顶级域名的解析 授权域名服务器 对于名字与地址映射，保留其初始数据来源的服务器 主要区分名字与地址映射是原始的还是被缓存的(非授权) 本地域名服务器(或称默认域名服务器) 一般每个ISP都部署有域名服务器，其用户可将该服务器设置成本地域名服务器(或默认域名服务器) 当进行域名解析时，查询请求首先发送到本地域名服务器(即查询的起点) 域名解析：名字到地址映射(通过名字查地址) 分布式：层级的服务器组织，协同实现解析 有效性：大多数解析可以在本地完成，一部分会产生互联网流量 可靠性：通过冗余设置，避免单点失效 解析方式 反复解析 递归解析 主机缓存 基本方法 在启动时从本地域名服务器下载名字-地址映射数据库 定期获取新的映射 缓存最近用过的名字和地址映射 优点 无需访问域名服务器，名字解析速度快 本地服务器的故障不影响名字解析 减低服务器的负载 缺点？ DNS包括query和reply两种报文 域名格式压缩？ 客户-服务器模式 域名服务器： 保存名字到地址映射关系(数据库) 接收客户端请求，并给出响应 域名解析器(客户端)： 请求域名解析的客户进程 向域名服务器发起解析请求，并等待服务器的响应 Web服务与HTTP协议 服务器 Web页面(HTML文档)：包含到多种对象的链接 对象：可以是 HTML文档、图像文件、视频文件、声音文件、脚本文件等 对象用URL(统一资源定位符)编址：协议类型://主机名//路径和文件名 客户端 发出请求、接收响应、解释HTML文档并显示 有些对象需要浏览器安装插件 HTTP(HyperText Transfer Protocol) 传输层通常使用TCP协议，缺省使用TCP的80端口 HTTP为无状态协议，服务器端不保留之前请求的状态信息 无状态协议：效率低、但简单 有状态协议：维护状态相对复杂，需要维护历史信息，在客户端或服务器出现故障时，需要保持状态的一致性等 HTTP标准 HTTP/1.0: RFC 1945(1996年) 每请求一个文件都要建立连接和断开 eg:请求一个index.html，里面包含3张jpg图片，先发送html文件，后重新建立三次连接发送图片 HTTP/1.1: RFC 2616(1999年) HTTP 1.1的问题 队头阻塞问题 基于文本协议的问答有序模式，先请求的必须先响应 传输效率问题 文本格式、冗长重复的头部等 HTTP 1.1队头阻塞的解决策略 浏览器建立多个TCP连接 一般最多可以建立6个TCP连接 通过不同TCP连接传送的请求没有响应顺序的要求 耗费较多的计算和存储资源 HTTP/2: RFC 7540(2015年)、RFC 8740(2020年) 二进制分帧传输 不改变HTTP原有的语义 将HTTP请求和响应分割成帧，采用二进制编码 帧为最小传输单位 最常用的HTTP 请求/ 响应的帧形式 TCP连接复用：提高连接利用率，解决HTTP的队头阻塞问题 消息(Message)：HTTP一次请求或响应，包含一个或多个帧 流(Stream)：简单看成一次请求和应答，包含多个帧 每个TCP连接中可以承载多个流，不同流的帧可以交替穿插传输 流的创建与标识 Stream ID：标识一个流。客户端创建的流，ID为奇数；服务器创建的流，ID为偶数；0x00和0x01用于特定场景；Stream ID 不能重复使用，如果一条连接上ID分配完，会新建一条连接。接收端通过Stream ID进行消息的组装。 流创建：发送和接收到HEADERS帧(包含新Stream ID)时创建 流优先级：可以依据重要性为流设置不同的优先级(1~256)，在HEADERS帧中承载 服务器推送：提高响应速度 服务器在请求之前先推送响应信息到客户端，推送的响应信息可以在客户端被缓存 HTTP头压缩(HPACK) 请求头由大量的键值组成，多个请求的键值重复程度很高 静态表：定义通用HTTP头域，常用键值无需重复传送，直接引用内部字典的整数索引 动态表：两边交互发现新的头域，添加到动态表 自定义键值：采用Huffman编码 http测试 HTTP 2.0协议解决的问题 通过引入流机制，解决了HTTP队头阻塞问题，提高了传输效率 通过二进制编码、头压缩机制提高了网络带宽利用率 通过服务器推送，加快了页面响应速度 HTTP 2.0协议没有解决的问题 TCP+TLS的多次交互，造成启动延迟问题 对移动主机和多宿主机的连接迁移问题 TCP队头阻塞问题 HTTP报文类型 HTTP两种报文：请求(request)、响应(response) HTTP请求报文：采用ASCII，数据部分采用MIME格式 HTTP响应报文：数据部分采用MIME格式 几个比较典型的状态码 200 OK 请求成功，被请求的对象包含在该响应的数据部分 301 Moved Permanently 请求的对象被移走，新的位置在响应中通过Location: 给出 400 Bad Request 服务器不能解释请求报文 404 Not Found 服务器中找不到请求的文档 505 HTTP Version Not Supported 服务器不支持相应的HTTP版本 用户-服务器交互：认证 认证：控制对服务器内容的访问 认证方法：通常使用“名字-口令” 无状态：客户端需要在每个请求中携带认证信息 每个请求头中包含authorization: 如果请求头中无authorization:，则服务器拒绝访问，并在响应头中包含WWW authenticate： 用户-服务器状态：Cookies 服务器使用cookies保持状态 HTTP响应头中使用set-cookie： 选择的cookie号具有唯一性 后继的HTTP请求中使用cookie： Cookie文件保存在用户的主机中，由用户主机中的浏览器管理 Web服务器建立后端数据库，记录用户信息 例如： Set-Cookie: SID=31d4d96e407aad42; Path=/; Domain=example.com Cookie: SID=31d4d96e407aad42 Web缓存机制：客户端缓存 目标：如果被请求的对象在客户端缓存有最近版本，则不需要发送该对象 客户端：在发送的HTTP请求中指定缓存的时间，请求头包含 If-modified-since: &lt; date &gt; 服务器：如果缓存的对象是最新的，在响应时无需包含该对象，响应头包含 HTTP/1.1 304 Not Modified Web缓存机制：代理服务器缓存 目标：由代理服务器进行缓存，尽量减少原始服务器参与 用户设置浏览器：通过代理服务器进行Web访问 浏览器将所有的HTTP请求发送到代理服务器 如果缓存中有被请求的对象，则直接返回对象 否则，代理服务器向原始服务器请求对象，再将对象返回给客户端 优点：降低时延，减少网络流量 HTTP发展现状 内容分发网络CDN(Content Distribution Network)基本思想源于MIT对Web服务瞬间拥塞问题的解决(1998) 一种Web缓存系统，靠近网络边缘(用户)提供内容服务 目前提供更丰富的服务，包括静态内容、流媒体、用户上传视频等 主要优点 降低响应时延，避免网络拥塞 避免原始服务器过载及防止DDoS攻击 分布式架构，具有良好的可扩展性 对用户透明，无需用户感知 DNS辅助 负载均衡DNS负责决策CDN服务器选择 负载均衡DNS需要收集CDN服务器的位置和负载情况 如果找不到被请求的对象，需要从原始服务器获取 动态自适应流媒体协议DASHDynamic Adaptive Streaming over HTTP)(重点)基本思想： 完整视频被拆分为固定时长(2s-10s)、不同码率的视频片段(segment) 视频片段与媒体表示描述(Media Presentation Description, MPD) 文件一同存放于DASH服务器 客户端根据自身设备性能、当前网络条件、客户端缓冲大小等自适应选择一种视频码率进行下载 例如：HTTP服务器中保存有高中低三种质量的视频片段，DASH客户端评估网络状况，通常在保证视频流畅的前提下，获取最高质量的视频片段 自适应码率(Adaptive bitrate，ABR)规则 传输层协议传输层需要解决的基本问题 网络层：将IP数据包从源主机传送到目的主机，提供无连接不可靠服务 数据包传输存在的问题：延迟、乱序、出错、丢失等 传输层解决的问题之一：可靠性，向应用层提供可靠服务 应用层运行多个应用进程 共享单一的网络层协议(IP)和网络接口 传输层解决的问题之二：复用(Multiplexing)和分用(Demultiplexing) TCP/IP体系结构中传输层协议与服务传输层协议的基本功能 复用和分用 可靠性保证 传输层实体执行的动作 发送端：将应用层的消息封装成传输层的数据单元，传递到网络层 接收端：将从网络层接收的传输层数据单元，处理后交给应用层 传输控制协议TCP(Transport Control Protocol) 为进程间通信提供面向连接的、可靠的传输服务 实现复用分用、差错检测、确认重传、流量控制等传输层功能 用户数据报协议UDP(User Datagram Protocol) 为进程间通信提供非连接的、不可靠的传输服务 实现复用分用、差错检测等传输层功能 用户数据报协议(UDP)UDP协议特点 发送方和接收方不需要握手过程 每个UDP数据单元(数据报)独立传输 提供复用分用功能和可选的差错检测功能 支持组播通信(点到多点通信) 不提供可靠性保证：无确认重传、可能有出错、丢失、乱序等现象 UDP数据报格式 长度：包含头部、以字节计数 校验和：为可选项，用于差错检测 进程标识：目的IP地址+目的端口号 UDP数据报的差错检测 可选项，利用数据报中携带冗余位(校验和域段)来检测数据报传输过程中出现的差错 发送端：利用自己产生的伪首部和发送的UDP数据报计算校验和 接收端：利用自己产生的伪首部和接收的UDP数据报计算校验和 伪首部：包含源IP地址、目的IP地址、协议类型等域段 UDP校验和计算几点说明 IPv4中UDP校验和是可选项，IPv6中变成强制项 0无，非0有(如果计算结果为0，则以全1代替) UDP校验和覆盖的范围超出了UDP数据报本身，使用伪首部的目的是检验UDP数据报是否到达真正的目的地 正确的目的地包括了特定的主机和该主机上特定的端口 伪首部不随用户数据报一起传输，接收方需自己形成伪首部进行校验 伪首部的使用破坏了层次划分的基本前提，即每一层的功能独立 目的主机的IP地址UDP通常知道，源IP的使用需要通过路由选择决定 u_short cksum(u_short *buf, int count){ register u_long sum = 0; while (count--){ sum += *buf++; if (sum &amp; 0XFFFF0000){ sum &amp;= 0XFFFF; sum++; } } Return ~(sum &amp; 0XFFFF); } IP首部、ICMP、UDP、TCP都需要计算校验和，方法类似 使用UDP服务的应用： 流媒体应用(实时音频和视频)通常使用UDP服务 能够容忍一定的丢失 对时延敏感 其他使用UDP服务的应用，如： DNS SNMP 需要在UDP之上实现可靠传输，即在应用层增加可靠机制 为什么提供UDP服务？ 不需要建立连接，建立连接需要增加延时，特别对于简单的交互应用 协议简单：在发送端和接收端不需要维护连接状态 数据报头部短，额外开销小 无拥塞控制 可靠数据传输rdt：reliable data transfer protocol(可靠数据传输协议) 停等机制：发送端发送一个分组，然后等待接收端响应 两种典型的流水线协议： 回退N：Go-Back-N (GBN) 允许发送端发出N个未得到确认的分组 需要增加序列号范围 分组首部中增加k位的序列号，序列号空间为[0, $2^{k-1}$] 采用累积确认，只确认连续正确接收分组的最大序列号 可能接收到重复的ACK 发送端设置定时器，定时器超时时，重传所有未确认的分组 选择重传：Selective Repeat (SR) 接收端独立确认每个正确接收的分组，必要时缓存分组，对高层按序交付 每个分组独立定时，发送端只重传未收到ACK的分组 过程 发送端 接收上层数据：如果发送窗口中有可用的序号，则发送分组 超时(n)：重传分组n，重启定时器 接收ACK(n)：n在[send_base, send_base+N-1]区间，将分组n标记为已接收，如果是窗口中最小的未确认的分组，则窗口向前滑动，基序号为下一个未确认分组的序号 接收端：接收分组n： n在[rcv_base, rcv_base+N-1]区间，发送ACK(n)，缓存失序分组，按序到达的分组交付给上层，窗口向前滑动 n在[rcv_base-N, rcv_base-1]区间，发送ACK(n) 传输控制协议(TCP)TCP协议特点提供可靠服务：按序、可靠交付 提供字节流服务，不识别消息边界可靠传输机制 提供差错检测(校验和)功能，正确接收返回确认 使用序列号检测丢失和乱序 超时重传机制，解决出错、丢失问题 支持流水线机制，自适应窗口 面向连接：发送数据之前发送方和接收方之间需要握手 三次握手建立连接 初始化所需的参数及分配缓冲区 提供复用分用功能 只提供点对点通信 具有流量控制和拥塞控制功能 头长度：四个字节为计数单位，包含选项部分 接收窗口通告：指示接收缓冲区可接收的字节数 标志位：URG, ACK, PUSH, RESET, SYN, FIN 选项格式：Kind(1字节)|Length(1字节)|Info(n字节) TCP连接与复用、分用机制 通信之前通过三次握手建立TCP连接 分配缓冲区、协商参数(初始序号、接收缓冲区大小、最大段尺寸等) 连接标识(四元组)：源IP地址、目的IP地址、源端口号、目的端口号 通过建立的TCP连接为应用进程提供可靠的字节流服务 事件 TCP接收端动作 期望序号的报文段按序到达，之前的报文段均已被确认 延迟发送ACK，等待下一个报文段到达；等500毫秒，仍未收到下一个报文段，则发送ACK 期望序号的报文段按序到达，之前有一个延迟确认的报文段 发送ACK，确认两个按序到达的报文段 报文段未按序到达，到达的报文段序号高于期望的序号，数据流不连续 发送重复ACK，确认序号中包含期望接收的序号 到达的报文段填补了之前数据流不连续部分 发送ACK，确认序号中包含期望接收的序号 TCP采用自适应方法计算重传超时时间(原因？) 基于往返时间(RTT)确定重传超时间(RTO) 问题：如何准确估算 上一次RTT可以测得，下一次RTT需要估算 网络拥塞和路由变化，每次往返时间可能不同，有时会有较大变化 流量控制的目的：避免发送端发送数据过快，接收端不能及时处理，造成接收缓冲区溢出 增加流控功能后，发送窗口还需要受接收能力的约束 可变的滑动窗口：接收端利用“接收窗口通告”域段告知发送端接收端缓冲区剩余的空间，发送端依据该通告调整发送窗口的大小 接收窗口大小对性能的影响 较小的缓冲区会影响网络的吞吐率 过大的缓冲区会浪费主机的存储资源 连接的半打开状态：连接的一端存在、而另一端不存在 当一个进程终止连接未能通知到另一方时，例如：掉电、异常关闭等 TCP定时器: 连接建立定时器(75秒) 重传定时器(RTO) 延迟ACK定时器(500毫秒) 持续定时器(避免0窗口死锁) 保活定时器(避免半打开) 静默定时器(避免端口号重用等) 理解网络拥塞拥塞控制方法：两种广泛使用的拥塞控制方法 端到端拥塞控制 网络中无明确的反馈 端系统通过观察丢失、延迟推断是否发生拥塞 TCP采用的拥塞控制策略 网络辅助的拥塞控制 路由器提供到端系统的反馈 例如：可以使用1位指示拥塞(如X.25, ATM) TCP拥塞控制机制带宽探测：接收到ACK提高传输速率，发生丢失事件降低传输速率 ACK返回：说明网络并未拥塞，可以继续提高发送速率 丢失事件：假设所有丢失是由于拥塞造成的，降低发送速率 TCP拥塞控制控制窗口：采用基于窗口的方法，通过拥塞窗口的增大或减小控制发送速率 实际发送窗口取决于接收通告窗口和拥塞控制窗口中较小值 TCP拥塞控制 慢启动阶段 初始拥塞窗口：cwnd=1(MSS) 每个RTT，cwnd翻倍(指数增长) 每接收到一个ACK，cwnd增1(MSS) 当连接初始建立或报文段超时未得到确认时，TCP拥塞控制进入慢启动阶段 特点：初始值小，增长速度快 拥塞避免阶段 阈值ssthresh：拥塞窗口达到该阈值时，慢启动阶段结束，进入拥塞避免阶段 每个RTT，cwnd增1(线性增长) 注意：TCP使用字节计数，当收到ACK时，拥塞窗口计算如下： $cwnd = cwnd + MSS \\times \\frac{MSS}{cwnd}$ 丢失检测 通过超时检测丢失： 阈值ssthresh = cwnd/2 cwnd=1，进入慢启动阶段 通过三次重复ACK检测丢失(TCP RENO算法)： 阈值ssthresh = cwnd/2 cwnd= ssthresh+3，进入线性增长(拥塞避免阶段) 注：重复ACK指明网络仍可以交付一些报文段(拥塞不严重) TCP Tahoe算法对于两种丢失情况均将cwnd设成1，并进入慢启动阶段 网络层协议网络层功能网络层功能部署 网络层在每台主机和路由器中实现 发送端：将传输层数据单元封装在数据包中 接收端：解析接收的数据包中，取出传输层数据单元，交付给传输层 路由器：检查数据包首部，转发数据包 网络层关键功能 路由(控制面): 决定数据包从源主机到目的主机的路径核心：路由算法与路由协议 转发(数据面): 将数据包从路由器的输入接口送到输出接口的过程 IP协议- IP服务IP层服务 面向无连接的数据报服务 不需要提前建立连接 数据包基于目的主机地址进行转发 数据包独立转发，相同源-目的的数据包可能经过不同的路径 尽力而为(Best-effort)的不可靠服务 数据包可能会产生较长的时延 数据包可能会丢失、失序、重复 IPv4IPv4地址 IP地址：32位二进制逻辑地址(四部分，0~255)，实现互联网络统一编址，标识主机和路由器的接口 接口：将主机和路由器连接到物理网络 路由器一般有多个接口 主机可以有一个或多个接口 IP与物理接口绑定 IP地址表示：点分割的十进制，如：223.1.1.1 IP地址层次： 网络号部分(net-id) 主机号部分(host-id) 什么是一个IP网络： 位于同一个物理网络 设备接口的IP地址的网络号部分相同，主机号部分不同 IPv4地址：如何获取 公有IP地址要求全球唯一，由区域互联网注册机构(RIR，Regional Internet Registry)或ISP分配 静态设定： 申请固定IP地址，手工设定 动态获取： 使用DHCP协议或其他动态配置协议 当主机加入IP网络，允许主机从DHCP服务器动态获取IP地址 可以有效利用IP地址，方便移动主机的地址获取 路由器转发IP数据包过程：总结 路由器确定IP数据包中目的地址的网络号 如果目的主机与路由器属于相同的IP网络，则直接转发到目的主机 如果目的主机与路由器不属于相同的IP网络，则查找路由表，确定下一跳路由器地址 如果存在相应的路由信息，则转发 如果没有相应的路由信息，则丢弃 减小TTL值，修改首部的校验和 将数据包转发到相应的接口 无类地址划分CIDR: Classless Inter-Domain Routing IP地址分为前缀和后缀两部分 一个前缀不一定标识一个物理网络 前缀可以是任意长度，前缀和后缀长度用32位掩码标识 也可以表示成：a.b.c.d /x，x为前缀长度 私有IP地址和NAT 私有IP地址的使用 可以在私有网络(本地网络)中自由使用，但不能出现在公网上 如果数据包要进入公网，需要进行私有地址到公有地址的转换 承担地址转换的设备称为NAT(Network Address Translation) 本地网络使用私有IP地址，NAT 面向公网侧使用公网IP地址 只需要一个或少量的公网IP地址 公网IP地址变化，不影响本地网络地址配置 安全性增强 NAT 的基本实现方法离开本地网络的数据包：用(NAT 的IP地址+新端口号)代替(源IP地址+端口号)，远端的主机返回的数据包将使用(NAT 的IP地址+新端口号)作为目的IP地址和目的端口 NAT 在转换表中记录(NAT 的IP地址+新端口号)到(源IP地址+端口号)的映射 进入本地网络的数据包：用转换表中的(源IP地址+端口号)替换数据包中的目的IP地址和端口号(NAT 的IP地址+新端口号) IPv6IPv6互联网的优势 解决地址耗尽问题：更大的地址空间(32位→128位) 340,282,366,920,938,463,463,374,607,431,768,211,456个IP地址 地球上每平方米范围：6.67×1023个IP地址 自动配置的支持(即插即用) 无状态地址自动配置 有状态地址自动配置：对DHCP协议改进和扩展，网络管理更加方便和快捷 改善网络性能 IP包头的合理改善，提高了路由器对数据包的处理速率 路由聚合，使路由表更小，提高转发效率 方便各项业务开展 无需使用NAT 设备 IPv6数据包由一个IPv6基本头、多个扩展头和上层数据单元组成 IPv6基本头：40字节固定长度，包含了发送和转发该数据包必须处理的一些字段 IPv6数据包可以包含0个或多个扩展头，扩展头位于基本头之后 基本头和扩展头中“下一包头”字段指出下一个扩展头的类型。最后一个扩展头中的“下一包头”字段指出高层协议的类型 128位地址：由冒号分开的8组十六进制字段组成 完全形式：1080:0000:0000:0000:0008:0800:200C:417A 圧缩形式：1080:0:0:0:8:800:200C:417A / 1080::8:800:200C:417A 地址段中有时会出现连续的几组0，这时这些0可以用“::”代替，但一个地址中只能出现一次“::“，例如：FF01:0:0:0:0:0:0:101=FF01::101，0:0:0:0:0:0:0:1=::1 内嵌IPv4地址的IPv6地址：0:0:0:0:0:0:61.1.133.1 或::61.1.133.1 URL的IPv6地址表示：https://[2001:410:0:1:250:fcee:e450:33ab]:8443/abc.html ICMP协议ICMP: 互联网控制消息协议 路由算法目标：确定从源主机到目的主机的最优路径 最优路径：一般为代价最小的路径 代价：有不同的定义方法，例如：距离、时延、费用、拥塞等 路由算法的分布式实现 路由器之间交互路由信息或链路状态信息 每台路由器独立计算最优路径 相对于数据包转发，所有路由协议的开销都属于额外管理开销 网络结构的图抽象 路由器：图中的点 物理链路：图中的边 代价：图中边的权值 用G = (N, E) 表示图 N = { u, v, w, x, y, z }，路由器集合 E = { (u, v), (u, x), (v, x), (v, w), (x, w),(x,y), (w,y), (w,z), (y,z) } ，链路的集合 链路代价：相邻节点之间的代价值，表示为$c(x_i,x_j)$ 如果xi和xj不相邻，链路代价记为无穷 例如, c(w, z) = 5 路径代价：路径上所有链路代价和 例如，路径$(x_1, x_2,x_3,…, x_p)的代价= c(x_1,x_2) + c(x_2,x_3) + … + c(x_{p-1},x_p)$ Dijkstra算法详解 Bellman-Ford公式假设：$D_x$(y) = 从x到y最小代价路径的代价值则：$D_x$(y) = min { c(x,m) + Dm(y) } m为x的邻居 距离向量路由算法 算法符号定义 $D_x$(y) = 从x到y最小代价路径的代价值节点x可以获知到每个邻居的链路代价c(x, m) 节点x维护自己的距离向量$D_x = [D_x$(y): y єN ] 节点x维护其邻居的距离向量，对于每个邻居m，x维护$D_m = [D_m$(y): y єN ] 基本思想 当节点的距离向量值发生变化时，向邻居节点发送自己的距离向量 如果节点x接收到邻居节点发送的距离向量，使用Bellman-Ford公式重新计算到所有其他节点的路径代价 $D_x(y) ← min {c(x,m) + D_m(y)}$ 每个节点y ∊N 经过反复迭代，$D_x(y)$会逐渐收敛到实际的最小路径代价值 互联网路由协议扩展性问题 络路由表庞大，存储、查找困难 路由信息交互量大，额外开销高 管理的自治问题 互联网由大量自治域构成 每个自治域独立管理，每个自治域可能运行不同的路由协议 层次化路由 自治域内路由 相同的自治域中的所有路由器运行相同的自治域内路由协议 不同的自治域的路由器可以运行不同的自治域内路由协议 网关路由器(或边界路由器)：与其他自治域的路由器相连接的路由器 自治域间路由 不同自治域网关路由器(或边界路由器)之间运行的路由协议 网关路由器：既执行自治域内的路由协议，也执行路由器之间的路由协议 路由表由自治域内和自治域间路由算法产生 运行协议 自治域内路由：也称为内部网关协议IGP 路由信息协议RIP: Routing Information Protocol 使用距离向量法 两种基本的报文类型 请求报文 响应报文 定期发送通告：相邻路由器每隔30秒发送一次响应报文 IP目的地址：255.255.255.255(本地广播地址) 跳步数定义：直接相连=1 每个通告可以最多携带25个目的网络 触发更新：如果发现链路失效或变化，立即发送响应报文 如果超过180秒没有接收到邻居通告，则认为链路失效 通过邻居的路径失效 向邻居发送通告 如果邻居的路由表项发生变化，则继续通告 链路失效信息会传播到整个网络 使用毒性逆转可以防止暂时环路的产生 设置16跳为无穷值，提高收敛速度 RIP协议在应用层实现 路由器中运行守候进程(routed) 使用UDP的520端口 发送和接收RIP报文，管理路由表 开放最短路径优先协议OSPF: Open Shortest Path First 几个概念 邻居(Neighbor)：两台路由器属于相同的IP网络，并通过交换Hello报文协商成功，则可以成为邻居 邻接关系(Adjacency)：形成邻居关系后，如果两台路由器成功交换DBD(数据库描述)报文以及LSA，则建立邻接关系 链路状态通告(Link State Advertisement，LSA)：每台路由器会在所有形成邻接关系的邻居之间发送LSA，LSA描述了路由器的链路、接口、邻居等信息 链路状态数据库(LSDB)：路由器将收到的LSA记录在LSDB中，并发送LSA拷贝给该路由器的其他所有邻居。当LSA传播到整个区域后，区域内所有的路由器都会形成同样的LSDB OSPF直接运行在IP协议之上，OSPF报文由IP数据包直接承载，协议类型为89 三张表 邻居列表：列出全部已经建立邻接关系的邻居路由器 链路状态数据库：列出网络中其他路由器的信息，由此显示全网的网络拓扑 路由表：列出通过最短路径优先算法计算出到达每个相连网络的最佳路径 OSPF工作过程 邻居发现 通过Hello报文发现并形成邻居关系，建立邻居表 路由通告 邻接路由器之间通过LSU洪泛LSA，通告链路状态信息，最终区域内所有路由器的LSDB完全相同，即实现同步 通过DBD、LSR、LSACK辅助LSA的同步 路由计算 LSDB同步后，每台路由器独立计算最优路由，将最优路由信息写入路由表 中间系统到中间系统路由协议IS-IS：Intermediate System-to-Intermediate System (ISO) 内部网关路由协议IGRP: Interior Gateway Routing Protocol (Cisco) 自治域间路由 边界网关协议BGP-4: Border Gateway Protocol 目前互联网中唯一实际运行的自治域间的路由协议 BGP功能 eBGP: 从相邻的AS获得网络可达信息 iBGP: 将网络可达信息传播给AS内的路由器 基于网络可达信息和策略决定到其他网络的“最优”路由 BGP报文 BGP通过TCP的179端口交换报文 BGP报文包括: Open报文：用于建立BGP对等体（peer）之间的会话连接，协商BGP参数（该过程需要认证） Update报文：用于在对等体之间交换路由信息 Keepalive报文：用于保持BGP会话连接 Notification报文：用于差错报告和关闭BGP连接 软件定义网络(SDN)软件定义网络核心思想 解耦： 将控制平面和数据平面进行分离，解决传统网络中控制平面和数据平面在物理上紧耦合导致的问题解决的问题 控制平面和数据平面之间不需要相互依赖，只需要遵循一定的开放接口即可进行通信 控制平面：负责决策控制，由软件实现，灵活 数据平面：专注数据转发，可有由通用硬件实现 抽象： 转发抽象：将数据平面抽象为通用的转发模型，如Openflow的交换机模型，各种转发表项，如MAC地址表、路由表、NAT 转换表等，抽象为统一的流表 分布状态抽象：控制层将设备的分布状态，抽象成全局的网络视图，从而实现逻辑的集中控制，具体可以通过网络操作系统来实现 网络操作系统（NOS）：下发控制命令，收集设备和链路状态，为上层应用提供全局网络视图 配置抽象：网络行为的表达通过编程语言实现，将抽象配置映射为物理配置，利用控制器提供的API，通过控制器配置全局设备 接口层原理与协议 接口层提供同一物理网络中各节点之间的连接和通信 同一个物理网络必须执行相同的接口层协议 不同的物理网络接口层协议可以不同 接口层基础物理网络连接方式：节点到节点连接、共享式连接、交换式连接 接口层功能 物理层：提供位流服务 传输介质和拓扑结构定义 编码与解码(数据→信号) 信号的发送与接收 时钟同步 数据链路层：提供可靠或不可靠的传输服务 数据单元及寻址方式定义 链路层差错检测 链路层的复用和分用 可靠数据传输 共享式连接：提供介质访问控制方法 交换式连接：数据单元转发 接口层技术分类 有多种接口层技术，传统上大致可以分成三类 局域网技术(LAN, Local Area Network ) 如：以太网(Ethernet)、无线局域网(WiFi) 城域网技术(MAN, Metropolitan Area Network) 如：FDDI、交换式Ethernet 广域网技术Wide Area Network (WAN) 如：ATM 其他接口技术 个人区域网 如：蓝牙技术(Bluetooth) 无线传感网络 如：Zigbee技术 局域网体系结构与组网方法介质访问控制层(Medium Access Control ) 物理节点寻址 差错控制 介质访问控制（共享式连接） 逻辑链路控制层（Logical Link Control） 链路层的复用和分用 可靠数据传输 共享式局域网 网络中任一节点发送的信息会被网络中所有节点收到（广播传输） 例如，共享式以太网，无线局域网，FDDI等 需要协调节点对共享介质的访问 介质访问控制方法 交换式局域网 链路采用点到点连接 例如，交换式以太网 交换机成为网络连接的核心 完成链路层数据单元的转发 通常采用统计多路复用 MAC地址—物理地址 32位IP地址: 网络层地址（逻辑地址）：标识主机或路由器的一个接口 主要用于IP数据包的路由转发 48位MAC地址（物理地址）: 物理地址：在相同的物理网络中，标识一个节点 对于大多数局域网，采用48位MAC地址 位于网卡的ROM或EPROM中 扁平地址，无层次，需要唯一 局域网编址与ARP协议ARP协议ARP: Address Resolution Protocol 局域网的每个IP节点（主机或路由器）都有ARP表 ARP表缓存IP地址和MAC地址的映射关系 链路层差错控制在数据链路层中，广泛使用循环冗余校验（Cyclic Redundancy Check ）CRC校验码计算方法 设原始数据D为k位二进制位模式 如果要产生n位CRC校验码，事先选定一个n+1位二进制位模式G（称为生成多项式），G的最高位为1 将原始数据D乘以$2^n$ （相当于在D后面添加n 个0），产生k+n位二进制位模式，用G对该位模式做模2除，得到余数R（n位，不足n位前面用0补齐）即为CRC校验码 共享式与交换式以太网共享式以太网：连接方式与功能 连接方式 方式1：通过同轴电缆连接（10Mbps以太网） 方式2：通过双绞线、光纤与集线器连接 服务：面向非连接的不可靠服务 功能 物理层 信号编码、时钟同步等，如差分曼彻斯特编码 介质访问控制层 介质访问控制：CSMA/CD 差错检测 逻辑链路控制层 复用与分用 虚拟局域网基于端口的VLAN: 交换机的端口被分组，单个物理交换机能够作为多个虚拟交换机运行 基于端口VLAN原理： 隔离通信流量: 来自于或到达端口1-8的流量只能到达1-8 也可以基于MAC地址定义VLAN 动态配置: 端口能够在VLAN之间动态配置 VLAN之间转发:类似独立的交换机，通过路由进行转发 无线局域网802.11无线局域网组网模式 基础架构模式： 站点（STA） 访问点（AP） 基本服务器（BSS） 扩展服务器（ESS） 注：每个BSS中的站点和AP共享同一无线信道；站点通过AP转发数据 自组织模式： 站点（STA） 独立基本服务器（IBSS） 站点之间直接通信 共享同一无线信道 注：每个站点在某个时刻只能工作在一种模式","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://kpl0111.github.io/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"LightSensor","date":"2021-04-23T19:31:03.000Z","path":"2021/0420210424.html","text":"光线传感器实验目的本次实验的目的是让大家了解Android中光线传感器的基本知识，掌握Android中光线传感器的使用方法。 实验要求 了解Android中光线传感器基本知识 掌握Android中光线传感器使用方法 基础知识光线传感器基础 光线传感器的好处是可以根据手机所处环境的光线来调节手机屏幕的亮度和键盘灯。例如在光线充足的地方屏幕会很亮，键盘灯就会关闭。相反如果在暗处，键盘灯就会亮，屏幕较暗（与屏幕亮度的设置也有关系），这样既保护了眼睛又节省了电量。光线传感器在进入睡眠模式时候会发出蓝色周期性闪动的光，非常美观。在本节的内容中，将详细讲解Android系统光线传感器的基本知识。光线传感器介绍在Android设备中，光线传感器通常位于前摄像头旁边的一个小点，如果在光线充足的情况下（室外或者是灯光充足的室内），大约在2～3秒之后键盘灯会自动熄灭，即使再操作机器键盘灯也不会亮，除非到了光线比较暗的地方才会自动地亮起来。如果在光线充足的情况下用手将光线感应器遮上，在2～3秒后键盘灯会自动亮起来，在此过程中光线感应器起到了一个节电的功能。要想在Android设备中监听光线传感器，需要掌握如下所示的监听方法。 registerListenr(SensorListenerlistenr,int sensors,int rate)：已过时。 registerListenr(SensorListenerlistenr,int sensors)：已过时。 registerListenr(SensorEventListenerlistenr,Sensor sensors,int rate)。 registerListenr(SensorEventListenerlistenr,Sensor sensors,int rate,Handlerhandler)：因为SensorListener已经过时，所以相应的注册方法也过时了。 在上述方法中，各个参数的具体说明如下所示。 Listener：相应监听器的引用。 Sensor：相应的感应器引用。 Rate：感应器的反应速度，这个必须是系统提供的4个常量之一。 SENSOR_DELAY_NORMAL：匹配屏幕方向的变化。 SENSOR_DELAY_UI：匹配用户接口。 SENSOR_DELAY_GAME：匹配游戏。 SENSOR_DELAY_FASTEST.：匹配所能达到的最快。 实验内容按照实验的内容进行操作，掌握Android中光线传感器的使用方法等内容。完成实验内容后，设计一个光线传感器的app，至少包含如下功能： 显示当前光线传感器的光照强度； 显示当前光线传感器的名称，耗电量，以及最大测量范围。 获取上述参数方法如下： myS = mySm.getDefaultSensor(Sensor.TYPE_LIGHT); 名称：myS.getName() ; 耗电量（mA）：myS.getPower(); 最大测量范围：myS.getMaximumRange() 实验过程 利用Android studio创建一个工程，并利用实体机或者安卓虚拟机进行测试（这里我先利用逍遥模拟器进行测试，成功之后，连接真机进行测试） 修改activity_main.yml文件，新建一个静态文本控件用来输出我们要输出的亮度传感器的有关信息，这里新建工程初始化时会自动生成一个文本控件，文本内容默认为“Hello World！”，所以只需在其基础上进行修改即可 &lt;TextView android:id=\"@+id/textView1\"//为控件添加编号textView1 android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\"//初始化文本内容 app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; 修改Mainactivity.java文件对传感器进行控制并进行文本输出 //这里仅展示所需主要代码。具体代码见工程文件 public class MainActivity extends Activity implements SensorEventListener { private SensorManager sensor;//定义一个传感器管理器 private TextView text;//定义一个文本控件 @Override protected void onCreate(Bundle savedInstanceState) {//项目初始化函数 super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sensor = (SensorManager)getSystemService(SENSOR_SERVICE);//调用getSystemService函数来获取传感器控制权 text = (TextView)findViewById(R.id.textView1);//通过控件ID将实体文本控件与代码连接起来 } @Override public void onSensorChanged(SensorEvent event) { // 在传感器控制函数里面实现我们的功能 float[] values = event.values; //定义变量来获取事件的值 int sensorType = event.sensor.TYPE_LIGHT; //定义值为事件发生时的传感器变量值 if(sensorType==Sensor.TYPE_LIGHT){//如果对应系统中的亮度传感器，则证明是亮度发生变化 String detail=\"\\n传感器名称：\"+(event.sensor.getType()==Sensor.TYPE_LIGHT?(event.sensor.getName()+\"\\n中文名称：光照传感器\"):\"\")+\"\\n耗电量：\"+event.sensor.getPower()+\"\\n最大测量范围：\"+event.sensor.getMaximumRange();//定义字符串来实现输出，调用getName，getPower，getMaximumRange函数来获取传感器参数 text.setText(detail+\"\\n当前光照强度：\"+String.valueOf(values[0])+\"Lux\\n\");//将静态文本控件内容更新为传感器信息 text.setTextSize(30);//设置字体大小 text.setTextColor(Color.parseColor(\"#ff5e9cff\"));//#7E0C6E设置字体颜色 } } } 软件效果展示","tags":[{"name":"Android","slug":"Android","permalink":"https://kpl0111.github.io/blog/tags/Android/"},{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"}]},{"title":"Ucore_lab1","date":"2021-04-13T08:26:17.000Z","path":"2021/0420210413.html","text":"说明在解压后的ucroe源码包中使用make命令即可以生成所需的目标文件,例如在本次实验中 user@system:~../lab1$ make 之后就会在bin文件夹生成一系列的目标文件： user.img : 被qemu访问的虚拟硬盘文件 kernel : ELF格式的toy ucore kernel执行文，嵌入到了ucore.img中 bootblock : 虚拟的硬盘主引导扇区(512字节)，包含了bootloader执行代码，同样嵌入了 sign : 外部执行程序，用来生成虚拟的硬盘主引导扇区还有其他文件，不一一列举。 如果要对修改后的ucore代码和ucore 源码进行比较，可以使用diff命令。 user@system:~../lab1$ diff 目标文件 源文件 练习11. 操作系统镜像文件ucore.img如何生成？ 执行指令 user@system:~../lab1$ make \"V=\" 可以获得Makefile中执行的具体指令，详细信息如下（仅列举有关ucore.img文件生成相关指令）: + cc kern/init/init.c gcc -c kern/init/init.c -o obj/kern/init/init.o + cc kern/libs/readline.c gcc -c kern/libs/readline.c -o obj/kern/libs/readline.o + cc kern/libs/stdio.c gcc -c kern/libs/stdio.c -o obj/kern/libs/stdio.o + cc kern/debug/kdebug.c gcc -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o + cc kern/debug/kmonitor.c gcc -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o + cc kern/debug/panic.c gcc -c kern/debug/panic.c -o obj/kern/debug/panic.o + cc kern/driver/clock.c gcc -c kern/driver/clock.c -o obj/kern/driver/clock.o + cc kern/driver/console.c gcc -c kern/driver/console.c -o obj/kern/driver/console.o + cc kern/driver/intr.c gcc -c kern/driver/intr.c -o obj/kern/driver/intr.o + cc kern/driver/picirq.c gcc -c kern/driver/picirq.c -o obj/kern/driver/picirq.o + cc kern/trap/trap.c gcc -c kern/trap/trap.c -o obj/kern/trap/trap.o + cc kern/trap/trapentry.S gcc -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o + cc kern/trap/vectors.S gcc -c kern/trap/vectors.S -o obj/kern/trap/vectors.o + cc kern/mm/pmm.c gcc -c kern/mm/pmm.c -o obj/kern/mm/pmm.o + cc libs/printfmt.c gcc -c libs/printfmt.c -o obj/libs/printfmt.o + cc libs/string.c gcc -c libs/string.c -o obj/libs/string.o + ld bin/kernel ld -o bin/kernel obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o obj/libs/printfmt.o obj/libs/string.o + cc boot/bootasm.S //编译bootasm.S gcc -c boot/bootasm.S -o obj/boot/bootasm.o + cc boot/bootmain.c //编译bootmain.c gcc -c boot/bootmain.c -o obj/boot/bootmain.o + cc tools/sign.c //编译sign.c gcc -c tools/sign.c -o obj/sign/tools/sign.o gcc -O2 obj/sign/tools/sign.o -o bin/sign + ld bin/bootblock //根据sign规范生成bootblock ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o 在makefile文件中搜索ucore.img可以找到 #create ucore.img UCOREIMG :=$(call totarget,ucore.img) $(UCOREIMG):$(kernel)$(bootblock) $ $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc $(call create_target,ucore.img) 可以看出ucore.img镜像文件是由kernel和bootblock文件生成的。 $(V)dd if=/dev/zero of=$@ count=100000 这句语句可以看到UCOREIMG分配了一定空间。 (V)dd if=$(bootblock) of=$@ conv=notrunc 这句语句将bootblock复制到上面分配的空间当中。 $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc 该语句将kernel复制到分配的空间当中。 1.kernel生成 kernel = $(call totarget,kernel) $(kernel): tools/kernel.ld 通过链接来生成kernel目标文件 $(kernel): $(KOBJS) kernel的生成还依赖KOBJS @echo + ld $@ $(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) @$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel) @$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; $(call symfile,kernel) $(call symfile,kernel) kernel = $(call totarget,kernel) 2.bootblock生成 bootfiles = $(call listf_cc,boot) 用boot替换listf_cc里面的变量，将listf_cc的返回值赋给bootfiles,也就是滤出.c,.s文件 $(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc)) 编译bookfiles bootblock = $(call totarget,bootblock) 生成bootblock $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign) 生成目标文件bootblock需要依赖于sign和bootfiles @echo + ld $@ 将以下文件与bootblock连接起来 $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock) @$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock) @$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock) @$(call totarget,sign) $(call outfile,bootblock) $(bootblock) $(call create_target,bootblock) 3.生成sign工具 $(call add_files_host,tools/sign.c,sign,sign) $(call create_target_host,sign,sign) 由sign工具、bootfile生成bootblock 由KOBJS生成kernel 由kernel和bootblock生成最终的ucore.img 2.一个被系统认为是符合规范的硬盘主引导扇区的特征是什么? 通过查阅资料我们可以知道bootblock区域包含用于引导的最小指令集，而在上一个问题中我们发现bootblock的生成需要依赖于sign.c文件和bootfiles文件，其中bootfiles提供开机启动所需要的文件，而sign.c则代表生成bootblock的规范。 因此，我们去在文件夹中查看sign.c文件。 文件代码如下： char buf[512]; //定义buf数组 memset(buf, 0, sizeof(buf)); // 把buf数组的最后两位置为 0x55, 0xAA buf[510] = 0x55; buf[511] = 0xAA; FILE *ofp = fopen(argv[2], \"wb+\"); size = fwrite(buf, 1, 512, ofp); if (size != 512) { //大小为512字节 fprintf(stderr, \"write '%s' error, size is %d.\\n\", argv[2], size); return -1; } 通过查看这里的代码，我们可以发现sign规范中给buf提供了512个字节的空间，而且bootblock的格式是最后两个字节分别是0x55和0xAA，而这也是操作系统课上提到的两个神奇的数。 练习21.使用qemu调试make文件 在进入lab1文件夹之后，使用命令 make debug 进入调试模式。 （1）在查看了tools文件夹中的gdbinit文件之后，可以看到存在代码 target remote localhost：1234 这代表着在启动之后会连接qemu和gdb。 （2）在make debug之后输入stepi，可以按照机器指令单步执行。 （3）一开始进入的是init.c程序。提示是init the console。 （4）再执行几次step执行源代码之后，就进入stdio.c文件。 （5）像这样反复执行step/next语句，就可以按照程序源代码一步一步执行了。 2.在初始化位置0x7c00设置实地址断点 在tools文件夹中的gdbinit文件中增加”b*0x7c00”语句，可以在实地址0x7c00位置设置一个断点。 3.单步跟踪反汇编得到的代码与bootasm.s和bootblock.asm进行比较 在位置0x7c00位置之后单步执行机器指令并且查看反汇编语句，和gedit打开的bootblock.asm文件进行对比。可以找到这个位置正好在bootblock.asm文件中。在位置0x7c00这里有着相同的语句。 注意在这里要在gdb中执行如下的指令 define hook-stop x/i $pc end 这样才可以进入反汇编的状态 同时我们查看bootasm.s文件之后，可以看到这样的代码 \\#Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00) movl $0x0, %ebp movl $start, %esp call bootmain 意味着从这里开始跳转到0x7c00. 4.自己找一个bootloader或者内核中的代码位置，设置断点并进行测试 像上个问题一样在gdbinit里面写入*b 0x7c1a，设置断点，然后类似的进行单步调试。 练习3分析bootloader进入保护模式的过程。BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。提示：需要阅读小节“保护模式和分段机制”和lab1/boot/bootasm.S源码，了解如何从实模式切换到保护模式，需要了解：1、为何开启A202、以及如何开启A203、 如何初始化GDT表4、如何使能和进入保护模式 分析首先bootloader从实模式进入保护模式要经过一下几个步骤： 1、开启A20门 2、建立GDT表并对其进行初始化操作 3、设置cr0寄存器的值为1 当寄存器值切换后方可表示模式切换成功初始状态A20地址线被屏蔽所以一直保持为0，我们要进一步访问内存需要A20地址线，需要将其打开。一、开启A20打开A20 Gate的具体步骤大致如下： 1、等待8042 Input buffer为空 2、发送Write 8042 Output Port （P2） 命令到8042 Input buffer 3、等待8042 Input buffer为空 4、将8042 Output Port（P2） 对应字节的第2位置1，然后写入8042 Input buffer # 开启A20：通过将键盘控制器上的A20线置于高电位，全部32条地址线可用， # 可以访问4G的内存空间。 seta20.1: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.1 movb $0xd1, %al # 0xd1 -&gt; port 0x64 outb %al, $0x64 # 0xd1 means: write data to 8042's P2 port seta20.2: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 0xdf -&gt; port 0x60 outb %al, $0x60 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1 二、建立并初始化GDT,寄存器置为1# Switch from real to protected mode, using a bootstrap GDT # and segment translation that makes virtual addresses # identical to physical addresses, so that the # effective memory map does not change during the switch. # 初始化GDT表：一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可 lgdt gdtdesc movl %cr0, %eax #进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式 orl $CR0_PE_ON, %eax movl %eax, %cr0 完成以后步骤后bootloader已经从实模式进入到了保护模式练习4分析BootLoader加载ELF格式的OS的过程 通过阅读bootmain.c,了解bootloader如何加载ELF文件。通过分析代码和通过qemu来运行调试 分析首先看bootmain函数 void bootmain(void){ //read the 1st page off disk readseg((uintptr_t)ELFHDR,SECTSIZE*8,0); //is this a valid ELF? if (ELFHDR-&gt;e_magic !=ELF_MAGIC){ goto bad; } struct proghdr *ph,*eph; // load each program segment(ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR+ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; for(;ph&lt;eph;ph++){ readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); } // call the entry point from the ELF header // note:does not return ((void(*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))(); bad: outw(0x8A00,0x8A00); outw(0x8A00,0x8E00); /* do nothing */ while(1); } 先是读磁盘，转入readseg函数 static void readseg(uintptr_t va,uint32_t count,uint32_t offset){ uintptr_t end_va = va + count; //round down to sector boundary va -= offset % SECTSIZE ; //translate from bytes to sectors; kernel starts at sector 1 uint32_t secno = (offset / SECTSIZE) + 1; //If this is too slow , we could read lots of sectors at a time. //We'd write more to memory than asked,but it doesn't matter -- //We load in increasing order. for(; va &lt; end_va; va += SECTSIZE, secno ++){ readsect((void*)va,secno); } } 从readseg函数发现又调用了readsect函数 static void readsect(void *dst,unit32_t secno){ //wait for disk to be ready waitdisk(); outb(0x1F2, 1);//要读写的扇区数，需要表明要读写几个扇区 outb(0x1F3, secno &amp; 0xFF);//LBA参数的0~7位 outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);//LBA参数的8~15位 outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);//LBA参数的16~23位 outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);//第0~3位：LBA参数的24-27位 第4位：为0主盘；为1从盘 outb(0x1F7,0x20);//状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口 读数据 //wait for disk to be ready waitdisk(); //read a sector insl(0x1F0,dst,SECTSIZE/4);//读取扇区 读一个扇区的流程大致如下： 等待磁盘准备好 发出读取扇区的命令 等待磁盘准备好 把磁盘扇区数据读到指定内存 其中的outb是一个机器指令，是在x86.h中的 static inline void outb(uint16_t port, unit8_t data){ asm volatile(\"outb %0, %1\" :: \"a\"(data), \"d\"(port)); } 用内联汇编实现，用了I0空间寻址方式，能将外部的数据读到内存中来，这也是x86里面的寻址方式 可以发现首先是等磁盘准备好，然后是写入地址和读取磁盘的命令，最后是按照地址读取磁盘扇区（可参考代码中的中文注释） 再接着看main函数，用了一个if语句判断是否为ELF文件，具体判断方式为将ELF header中的一个e_magic和一个特定值进行比较，若不是则转入bad,是则继续执行 struct proghdr *ph,*eph; // load each program segment(ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR+ELFHDR-&gt;e_phoff);//将ELF文件的头部文表取出存到ph eph = ph + ELFHDR-&gt;e_phnum; for(;ph&lt;eph;ph++){ #加载ELF文件到内存 readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); } // call the entry point from the ELF header // note:does not return ((void(*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();//ELF文件加载完毕后，将控制权交给ucore去执行 由此完成ELF文件的加载练习5完成kdebug.c中函数print_stackframe的实现，可以通过函数&gt;print_stackframe来跟踪函数调用堆栈中记录的返回地址。 1、函数堆栈的原理 理解函数堆栈最重要的两点是：栈的结构，以及EBP寄存器的作用。 一个函数调用动作可分解为零到多个 PUSH指令（用于参数入栈）和一个 CALL 指令。CALL 指令内部其实还暗含了一个将返回地址压栈的动作，这是由硬件完成的。几乎所有本地编译器都会在每个函数体之前插入类似如下的汇编指令： pushl %ebp movl %esp,%ebp 这两条汇编指令的含义是：首先将ebp 寄存器入栈，然后将栈顶指针 esp 赋值给 ebp。 movl %esp %ebp这条指令表面上看是用esp覆盖 ebp原来的值，其实不然。因为给 ebp赋值之前，原ebp 值已经被压栈（位于栈顶），而新的ebp又恰恰指向栈顶。此时ebp寄存器就已经处于一个非常重要的地位，该寄存器中存储着栈中的一个地址（原 ebp入栈后的栈顶），从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的ebp值。 我们可以直接根据ebp就能读取到各个栈帧的地址和值，一般而言，ss:[ebp+4]处为返回地址，ss:[ebp+8]处为第一个参数值（最后一个入栈的参数值，此处假设其占用 4 字节内存，对应32位系统），ss:[ebp-4]处为第一个局部变量，ss:[ebp]处为上一层 ebp 值。 如图 2、print_stackframe函数的实现 首先我们直接看到print_stackframe函数的注释： void print_stackframe(void) { /* LAB1 YOUR CODE : STEP 1 */ /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t); * (2) call read_eip() to get the value of eip. the type is (uint32_t); * (3) from 0 .. STACKFRAME_DEPTH * (3.1) printf value of ebp, eip * (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4] * (3.3) cprintf(\"\\n\"); * (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc. * (3.5) popup a calling stackframe * NOTICE: the calling funciton's return addr eip = ss:[ebp+4] * the calling funciton's ebp = ss:[ebp] */ } 这样我们直接根据注释以及之前的相关知识就能比较简单的编写成程序，如下所示： void print_stackframe(void) { uint32_t ebp=read_ebp();//(1) call read_ebp() to get the value of ebp. the type is (uint32_t) uint32_t eip=read_eip();//(2) call read_eip() to get the value of eip. the type is (uint32_t) int i; for(i=0;i&lt;STACKFRAME_DEPTH&amp;&amp;ebp!=0;i++){//(3) from 0 .. STACKFRAME_DEPTH cprintf(\"ebp:0x%08x eip:0x%08x \",ebp,eip);//(3.1)printf value of ebp, eip uint32_t *tmp=(uint32_t *)ebp+2; cprintf(\"arg :0x%08x 0x%08x 0x%08x 0x%08x\",*(tmp+0),*(tmp+1),*(tmp+2),*(tmp+3));//(3.2)(uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4] cprintf(\"\\n\");//(3.3) cprintf(\"\\n\"); print_debuginfo(eip-1);//(3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc. eip=((uint32_t *)ebp)[1]; ebp=((uint32_t *)ebp)[0];//(3.5) popup a calling stackframe } } 实验结果截图如下： 练习6：完善中断初始化和处理1、中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？2、请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。3、请编程完善trap.c中的中断处理函数trap,在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统毎遇到100次时钟中断后，调用print_tricks子程序，在屏幕上打印一行文字“100 ticks”。 1、中断描述符表中一个表项占8字节 如上图所示，其中的0-15位是offset的低16位，48-63位是offset的高16位，16-31位是段选择子，用于索引全局描述符表GDT来获取中断处理代码对应的段地址，再加上段内偏移量即可得到中断处理代码的入口。 2、完善初始化函数 （1）根据函数中的注释提示，第一步是声明__vertors[]; (2) 第二步是使用SETGATE填充中段描述符表IDT (3) 第三步是使用lidt指令让CPU加载中断描述符表IDT 具体的代码如下： void idt_init(void){ extern uintptr_t __vecors[]; int i; for(i=0; i &lt; 256; i++){ SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL); } SETGATE(idt[T_SWITCH_TOK],0,GD_KTEXT,__vectors[T_SWITCH_TOK],DPL_USER); lidt(&amp;idit_pd); } 其中宏SETGATE的定义为 #define SETGATE(gate, istrap, sel, off, dpl) GD_KTEXT和DPL_KERNEL的定义在memlayout.h中 gate表示处理函数的入口地址，此处即idt[]数组中的内容istrap表示1为异常门，0为中断门sel表示段选择子off表示偏移量，此处即__vectors[]数组中的内容dpl表示设置等级，此处设置为DPL_KERNEL，恒为0 3、编写函数根据提示，需要用一个全局变量记录每次时钟中断，然后用print_ticks()打印“100 ticks”后重新从0开始计数，参照clock.c,写出如下函数： case IRQ_OFFSET+IRQ_TIMER: ticks=ticks+1; if(ticks==TICK_NUM){ print_ticks(); ticks=0; } break; 其中TICK_NUM已被定义为100 最后的运行结果为下图： Challenge 1&amp;2 新建用户态并进行内核态互换通过编写c++内联汇编函数，来实现用户态和内核态的切换。 已知初始化内核的函数如下： static void switch_test(void) { print_cur_status(); // print 当前 cs/ss/ds 等寄存器状态 cprintf(\"+++ switch to user mode +++\\n\"); switch_to_user(); // switch to user mode print_cur_status(); cprintf(\"+++ switch to kernel mode +++\\n\"); switch_to_kernel(); // switch to kernel mode print_cur_status(); } 而在init.c里面没有switch_to_user函数的内容以及switch_to_kernel函数的内容，因此这些部分需要编程。 1.调到用户态 通过编写switch_to_user的内容来使在内核初始化的时候可以切换到用户态。 asm volatile ( \"sub $0x8, %%esp \\n\" \"int %0 \\n\" \"movl %%ebp, %%esp\" : : \"i\"(T_SWITCH_TOU) ); 通过编写内联汇编语句来实现切换，用中断处理int 0来实现，需要输入的“i”也就是T_SWITCH_TOU。调整栈顶指针和栈底指针开辟程序空间之后，进行中断来实现切换。 在trap.c中要修改t_switch_tou的内容 case T_SWITCH_TOU: if (tf-&gt;tf_cs != USER_CS) { switchk2u = *tf; switchk2u.tf_cs = USER_CS; switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS; switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8; switchk2u.tf_eflags |= FL_IOPL_MASK; *((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u; } break; 这段代码可以使原来的状态不是用户态时候，将原来的状态修改成用户态。 switchk2u.tf_eflags |= FL_IOPL_MASK; *((uint32_t*)tf - 1) = (uint32_t)&amp;switchk2u; 将这里的标记确认成为用户态，并且中断返回到正确的栈。 2.用户态到内核态 用类似的内联汇编处理。 asm volatile ( \"int %0 \\n\" \"movl %%ebp, %%esp \\n\" : : \"i\"(T_SWITCH_TOK) ); 因为切换到的是内核态，不需要更多空间，所以相比内核到用户的内联汇编不再需要在栈指针减去一个值来开辟空间。 然后我们同样需要在trap.c中修改T_SWITCH_TOK的内容 case T_SWITCH_TOK: if (tf-&gt;tf_cs != KERNEL_CS) { tf-&gt;tf_cs = KERNEL_CS; tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS; tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK; switchu2k = (struct trapframe *)(tf-&gt;tf_esp (sizeof(struct trapframe) - 8)); memmove(switchu2k, tf, sizeof(struct trapframe) - 8); *((uint32_t *)tf - 1) = (uint32_t)switchu2k; } 跟之前切换的修改类似 3.实现切换case IRQ_OFFSET + IRQ_KBD: c = cons_getc(); cprintf(\"kbd [%03d] %c\\n\", c, c); if(c == '0' &amp;&amp; (tf-&gt;tf_cs &amp; 3) != 0) { cprintf(\"Input 0......switch to kernel\\n\"); tf-&gt;tf_cs = KERNEL_CS; tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS; tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK; } else if (c == '3' &amp;&amp; (tf-&gt;tf_cs &amp; 3) != 3) { cprintf(\"Input 3......switch to user\\n\"); tf-&gt;tf_cs = USER_CS; tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS; tf-&gt;tf_eflags |= FL_IOPL_MASK; } break; 修改完代码之后执行 make qemu 键盘输入0或3即可实现切换 最终评分","tags":[{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"},{"name":"OS","slug":"OS","permalink":"https://kpl0111.github.io/blog/tags/OS/"}]},{"title":"可视化第一次作业","date":"2021-04-09T17:52:16.000Z","path":"2021/042021410.html","text":"作业内容1．编程实现消息测试程序，满足以下要求： 按下键盘任意字符键（至少识别两个功能键），客户区中显示按键信息（字符或功能键内容）； 单击鼠标左键，消息对话框中显示鼠标信息（鼠标左键+坐标）； 假设鼠标右键失灵，用Ctrl+鼠标左键代替，消息对话框中显示鼠标信息（鼠标右键+坐标）； 自定义WM_MY_MESSAGE消息，带10和100两个参数，由“#”（不是“3”）键激活，客户区中显示相应信息（自定义消息+参数）。 2．编程实现SmallBall程序，满足以下要求： 黑色小球，从左上角开始，沿着45度方向移动，遇到边界反弹； 通过两个菜单项（加速与减速），调节小球的移动幅度（递增或递减）； 通过两个工具栏按钮，控制小球停止与再次启动。 展示Key 常规按键 功能键 单击鼠标左键 Ctrl+鼠标左键替代鼠标右键 自定义Message Ball 加速 减速 暂停 启动 有轨迹 状态栏 实现过程Key添加命令在MESSAGE_MAP处添加本项目所需所有打印命令，包括自定义命令。 BEGIN_MESSAGE_MAP(CKeyView, CView) //标准打印命令 ON_COMMAND(ID_FILE_PRINT, &amp;CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_DIRECT, &amp;CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_PREVIEW, &amp;CView::OnFilePrintPreview) ON_WM_LBUTTONUP() ON_WM_CHAR() ON_WM_KEYDOWN() ON_MESSAGE(WM_MYMESSAGE, OnMyMessage) END_MESSAGE_MAP() 头文件函数声明在KeyView.h头文件里面声明OnLButtonUp，OnChar，PreTranslateMessages，以及OnMyMessage函数 protected: afx_msg void OnLButtonUp(UINT nFlags, CPoint point); //添加鼠标左键点击函数，以及按键事件函数 afx_msg void OnChar(UINT nChar, UINT nRedCnt, UINT nFlags); virtual BOOL PreTranslateMessage(MSG* pMsg); afx_msg LRESULT OnMyMessage(WPARAM wParam, LPARAM lParam); void CKeyView::OnLButtonUp(UINT nFlags, CPoint point)本函数主要实现鼠标左键点击以及替代右键功能，利用if语句如果是Ctrl+鼠标左键的话，则输出右键点击，并利用point来获取当前坐标，使用TextOutW来输出，如果if条件不成立，则输出左键点击 void CKeyView::OnLButtonUp(UINT nFlags, CPoint point) { CDC* pDC = GetDC(); CString m_str; if (nFlags &amp; MK_CONTROL)//ctrl+左键代表右键 m_str.Format(L\"X:%d,Y:%d:Right Mouse Button Clicked!\", point.x, point.y); else m_str.Format(L\"X:%d,Y:%d:Left Mouse Button Clicked!\", point.x, point.y); pDC-&gt;TextOutW(point.x, point.y, m_str); } void CKeyView::OnChar(UINT nChar, UINT nRedCnt, UINT nFlags)本函数主要实现常规按键和自定义消息#键（在自定义消息里面讲）的输出，首先获取当前按键的字符，如果不是#，则弹出弹框声明 void CKeyView::OnChar(UINT nChar, UINT nRedCnt, UINT nFlags) { if (nChar == '#') //按键如果是#则调用自定义消息，其他则调用系统消息 SendMessage(WM_MYMESSAGE, 10, 100); else { CString str; str.Format(L\"%c Key Entered!\", nChar); MessageBox(str); } CView::OnChar(nChar, nRedCnt, nFlags); } BOOL CKeyView::PreTranslateMessage(MSG* pMsg)本函数实现功能按键，主要思路就是通过pMsg的wParam来对应不同功能键，从而进行输出，考虑到shift和ctrl的常用性，并没有对其进行添加，其他功能键也类似 BOOL CKeyView::PreTranslateMessage(MSG* pMsg) { if (pMsg-&gt;message == WM_KEYDOWN)//添加功能键，方法类似可添加更多，常用ctrl和shift注释掉了以免影响其他键的操作 { if (pMsg-&gt;wParam == VK_F1) MessageBox(L\"F1 Key Entered!\"); if (pMsg-&gt;wParam == VK_F2) MessageBox(L\"F2 Key Entered!\"); if (pMsg-&gt;wParam == VK_F3) MessageBox(L\"F3 Key Entered!\"); if (pMsg-&gt;wParam == VK_F4) MessageBox(L\"F4 Key Entered!\"); if (pMsg-&gt;wParam == VK_F5) MessageBox(L\"F5 Key Entered!\"); if (pMsg-&gt;wParam == VK_F6) MessageBox(L\"F6 Key Entered!\"); if (pMsg-&gt;wParam == VK_F7) MessageBox(L\"F7 Key Entered!\"); if (pMsg-&gt;wParam == VK_F8) MessageBox(L\"F8 Key Entered!\"); if (pMsg-&gt;wParam == VK_F9) MessageBox(L\"F9 Key Entered!\"); if (pMsg-&gt;wParam == VK_F10) MessageBox(L\"F10 Key Entered!\"); if (pMsg-&gt;wParam == VK_F11) MessageBox(L\"F11 Key Entered!\"); if (pMsg-&gt;wParam == VK_F12) MessageBox(L\"F12 Key Entered!\"); if (pMsg-&gt;wParam == VK_UP) MessageBox(L\"↑ Key Entered!\"); if (pMsg-&gt;wParam == VK_DOWN) MessageBox(L\"↓ Key Entered!\"); if (pMsg-&gt;wParam == VK_LEFT) MessageBox(L\"← Key Entered!\"); if (pMsg-&gt;wParam == VK_RIGHT) MessageBox(L\"→ Key Entered!\"); //if (pMsg-&gt;wParam == VK_CONTROL) MessageBox(L\"Ctrl Key Entered!\"); if (pMsg-&gt;wParam == VK_CAPITAL) MessageBox(L\"CapsLk Key Entered!\"); //if (pMsg-&gt;wParam == VK_SHIFT) MessageBox(L\"Shift Key Entered!\"); } return CView::PreTranslateMessage(pMsg); } 自定义消息 首先声明自己的消息名字和编号#define WM_MYMESSAGE WM_USER+10 声明一个关于自定义消息的响应函数OnMyMessage 在Onchar里面实现，如果按下#键，则SendMessage，含有两个参数10和100if (nChar == '#') //按键如果是#则调用自定义消息，其他则调用系统消息 SendMessage(WM_MYMESSAGE, 10, 100); 定义主面板名称cs.style &amp;= ~FWS_ADDTOTITLE; //修改主窗口标题 m_strTitle = _T(\"Key\"); Ball小球采用异或方法来实现小球的消除，也可以实现小球的轨迹消除，通过Timer来实现小球的不断移动和刷新，从而造成一种小球运动的现象， 声明Ball类变量public: afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);//声明timer afx_msg void OnDestroy(); afx_msg void OnTimer(UINT_PTR nIDEvent); private: int x; //x，y表示当前坐标，step_num表示步幅倍数，step_x,step_y表示每次移动距离的单位 int y; int step_num; int step_x; int step_y; int size; //小球大小 bool begin_pause; //小球状态 bool trail; //小球轨迹状态 public: afx_msg void OnSpeedUp(); //声明加速函数 afx_msg void OnSpeedDown(); //声明减速函数 afx_msg void OnTrail(); //声明轨迹函数 afx_msg void OnBegin_Pause(); //声明状态函数 实现小球运动不断函数调用来实现小球的运动，采用step_num来控制小球的速度，当按下加速键是step_num加1，加速，减速同理，当速度为1是，如果继续减速，将强制停止此操作，并弹出消息提示，暂停功能的实现是通过阶数当前计时器，开始则重新开启一个同样编号的计时器，轨迹的消除通过控制变量trail来实现，如果不需要轨迹，则执行异或操作将轨迹消除，并进行清屏，反之则不执行 int CBallView::OnCreate(LPCREATESTRUCT lpCreateStruct) { if (CView::OnCreate(lpCreateStruct) == -1) return -1; // TODO: 在此添加您专用的创建代码 SetTimer(1, 100, NULL);//计时器编号，刷新时间（ms)可以通过刷新时间来实现加速和减速 return 0; } void CBallView::OnDestroy() { CView::OnDestroy(); KillTimer(1); } void CBallView::OnTimer(UINT_PTR nIDEvent) { if (nIDEvent == 1) { CRect rect; GetClientRect(&amp;rect); CDC* pDC = GetDC(); pDC-&gt;SetROP2(R2_XORPEN); pDC-&gt;Ellipse(x, y, x + size, y + size); x += step_x*step_num; //通过改变步幅倍率来改变速度 y += step_y*step_num; theApp.x_ = x; theApp.y_ = y; if (x&lt;0 || x&gt;rect.right - size) //转向操作 { step_x = 0 - step_x; } if (y&lt;0 || y&gt;rect.bottom - size) { step_y = 0 - step_y; } if (!trail) //是否保留轨迹，不保留则通过异或消除 pDC-&gt;Ellipse(x,y,x+size,y+size); } CView::OnTimer(nIDEvent); } 菜单栏的实现在资源视图中找到主视图进行添加相应部分，并添加事件来响应 void CBallView::OnSpeedUp() //加速函数，并弹出弹框提示速度信息 { // TODO: 在此添加命令处理程序代码 step_num++; theApp.speed_ = step_num; CString str; str.Format(L\"Current speed:%d\", step_num); MessageBox(str); } void CBallView::OnSpeedDown() //减速函数，并弹出弹框提示速度信息，如果速度为1，仍要减速，则不允许减速，弹出提示消息 { // TODO: 在此添加命令处理程序代码 if (step_num &gt; 1) { step_num--; theApp.speed_ = step_num; CString str; str.Format(L\"Current speed:%d\", step_num); MessageBox(str); } else//速度为1 { CString str; str.Format(L\" Current speed:%d\\n\\dThe current speed is already the minimum.\\n No more deceleration is allowed.\", step_num); MessageBox(str); } } void CBallView::OnTrail()//是否保留轨迹，不保留则通过用白色刷新全屏来实现清屏 { // TODO: 在此添加命令处理程序代码 if (trail) { trail = false; CDC* pDC = GetDC(); CRect rc; GetClientRect(&amp;rc); pDC-&gt;FillSolidRect(&amp;rc, RGB(255, 255, 255)); pDC-&gt;SetROP2(R2_XORPEN); pDC-&gt;Ellipse(x, y, x + size, y + size); ReleaseDC(pDC); } else trail = true; } //void CBallView::OnBegin_Pause()//暂停实现方法一，步幅倍率为0，则一直在原地刷新，小球会一直闪动 //{ // // TODO: 在此添加命令处理程序代码 // if (begin_pause == 0) // { // begin_pause = step_num; // step_num = 0; // } // else // { // step_num = begin_pause; // begin_pause = 0; // } //} void CBallView::OnBegin_Pause()//暂停实现方法二，通过kill掉Timer来实现暂停，开始则重新申请一个Timer { // TODO: 在此添加命令处理程序代码 if (!begin_pause) { begin_pause = true; KillTimer(1); } else { SetTimer(1, 100, NULL); begin_pause = false; } } 状态栏的实现新建三个状态 速度，位置和时间，并将其添加到indicators数组里面，使用SetPaneInfo函数来设置三个状态的信息以及宽度，然后继续利用Timer来不断刷新，速度和位置采用全局变量来获得，时间则通过CTime::GetCurrentTime()函数实现。 m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT)); m_wndStatusBar.SetPaneInfo(4, IDS_INDICATOR_SPEED, SBPS_POPOUT, 50);//设置三个信息的位置和宽度 m_wndStatusBar.SetPaneInfo(5, IDS_INDICATOR_MESSAGE, SBPS_POPOUT, 110); m_wndStatusBar.SetPaneInfo(6, IDS_INDICATOR_TIME, SBPS_POPOUT, 50); RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, IDS_INDICATOR_TIME); //添加时间显示函数 SetTimer(2, 100, NULL); CTime t1; CString str_1; //对三栏信息进行初始化 str_1.Format(L\"Speed:%d\", theApp.speed_); m_wndStatusBar.SetPaneText(4, str_1); CString str_2; str_2.Format(L\"Location(%d,%d)\", theApp.x_, theApp.y_); m_wndStatusBar.SetPaneText(5, str_2); t1 = CTime::GetCurrentTime(); m_wndStatusBar.SetPaneText(6, t1.Format(\"%H:%M:%S\")); void CMainFrame::OnTimer(UINT_PTR nIDEvent)//通过timer来实现刷新 { CTime t1; CString str_1; str_1.Format(L\"Speed:%d\", theApp.speed_); m_wndStatusBar.SetPaneText(4, str_1); CString str_2; str_2.Format(L\"Location(%d,%d)\", theApp.x_, theApp.y_); m_wndStatusBar.SetPaneText(5, str_2); t1 = CTime::GetCurrentTime();//获取当前时间来刷新状态栏 m_wndStatusBar.SetPaneText(6, t1.Format(\"%H:%M:%S\")); CFrameWnd::OnTimer(nIDEvent); } 定义主面板名称cs.style &amp;= ~FWS_ADDTOTITLE; //修改主窗口标题 m_strTitle = _T(\"Ball\"); 实验收获通过本次实验掌握了MFC的基本操作，理解了其实现功能的机制（消息的发送和执行），了解了一些基本函数的使用的，在对其界面优化过程中，通过实践对其理解加深，主要存在困难就是对函数的使用，以及初步接触MFc对其实现机制不太了解，实验过后相信会有所提升。","tags":[{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"},{"name":"MFC","slug":"MFC","permalink":"https://kpl0111.github.io/blog/tags/MFC/"}]},{"title":"Hexo+Github搭建自己的博客","date":"2021-03-27T14:04:17.000Z","path":"2021/03711.html","text":"​今天算是把自己的简易博客给搭建了起来，虽然说很丑，很多地方优化还没做好，功能也不太全，但是，做事情嘛，总是要一步步来的，哪有一蹴而就的事情，自己慢慢摸索，踩了许多坑之后，也把这其中的原理摸索了个七七八八，虽然说要我写个主题是天大的难题，但是理解博客的架构，以及github的用法也是很容易的，甚至就连命令也因为出错太多，四处填坑而记得些常用的，所以说做事情别人教给自己的和自己摸索的是完全不一样的，当然这个摸索也是在其他大佬教程和错误修正基础之上摸索的，并不是“白手起家”，废话不多说，进入正题，记录一些我自己的搭建过程，也是那些像我一样的小白提供一个同样水平的教程，绝对包教包会，首先我们先来了解一下他们的工作原理，通俗理解，如有不对，欢迎指正。 关于Github​首先关于Github，本质上讲就是一个比较通用的代码托管平台。你可以将自己做的项目之类balabala的都放在里面，取用方便，最重要的是他完全免费，是一个很好的托管平台，做一些比较大的项目也可以多人协作（扯远了），回来说我们的博客，你可以在Github上面建立一个或者多个仓库，名字可以任意取，这些仓库本质没有区别，Github还为每个仓库提供一个页面还有主题（当然主体比较单一，还比较漂亮chou），当然你也可以选择自己搭配喜欢的主题。唯一不同之处就是Github给每个用户提供一个域名（username.github.io），当你的仓库以这个格式命名的时候，他就会默认这个仓库的界面就是你的网站主界面，其他的仓库就是他的子目录，就这么点区别，举个栗子，我的用户名是Test，那么我的网站主界面就是https://Test.github.io， 他所代表的仓库名字就是Test.github.io，如果我还有一个仓库名字是Blog，那么这个仓库的主界面就要用https://Test.github.io/Blog 打开，这样说就很简单易懂了吧，其他区别完全没有，名字你可随便改，当你给哪个仓库命名为username.github.io时，默认打开就是这个仓库主界面（当然站点配置也要改，不然会出错的）。 关于Git​Git本身就是一个工具，这里我们用它来实现我们的各种命令，大致可以等同于命令行，可以用Git来安装各种插件，实现命令，这里不多介绍，后面过程中你就会明白。 关于Hexo​我们所使用的主题以及大部分插件都由Hexo提供，你可以把它理解为一家衣服店铺，我们来挑选我们喜欢的衣服（theme），同时它也提供裁裤腿，钉扣子（插件）服务，这样就可以理解了吧。 流程​简单介绍一下流程，非常简单。首先我们建立一个仓库以便我们能够放一些我们主题的配置文件在里面，当然仓库名字就要命名为username.github.io格式了，这样我们的主页面才会使我们配置的那样，然后我们需要在本地也创建一个仓库，在里面把我们平时用的代码等等都放在里面，然后把本地仓库和远程仓库连接，再把本地文件代码上传就可以得到我们想要的简洁漂亮的网站了，是不是很简单呢。 具体步骤仓库搭建仓库搭建可以参考一下这位大佬的博客：超详细Hexo+Github博客搭建小白教程 讲得非常详细，我就不再介绍了，做点其他有用的东西。 网站配置在你的本地文件夹里面会有一个_config.yml文件，这个就是你的网站的配置文件了，可以在里面配置你的网站名字，图标等等，基本上你想到的都可以在里面设置，具体每一项对应那个部分，hexo官网很详细，也不再多补充，可以参考Hexo文档，里面没有的话百度一下，你就知道，总的来说，不难要善用搜索引擎。 主题更换主题选择的话可以从Themes|Hexo上选你喜欢的，具体步骤里面每个主题作者都会介绍，大致过程是一样的，不管你是clone也好，下载zip主题文件也好，要保证你的主题文件夹在themes文件夹下面，然后回到你的网站的文件夹里面找到_config.yml配置文件，在里面找到theme，将其更改为你的主题，比如说我的是Ayer，就是这样 然后基本上就可以了，之后需要做的就是一些优化工作，讲几点大家会遇到的关键的： 会有两个_config.yml文件，一个位于你网站的页面，是你网站的配置文件，另一个是在你的主题文件夹里面，两个名字一样，但是千万不要弄混，不要修改错文件，这两个都是配置文件，所以名字相同，但是配置的对象不一样，这点明白，应该就很简单了。 更换主题的步骤基本上就是theme后面换上你的主题名字，然后在安装你的主题所需要的插件，比如说你的网站想要有一个播放器小图标，但是你不给安装插件，就算主题配置里面作者配置的再全，也不可能有用，所以说要按照主题安装说明安装插件（在网站主页面右键Git Bush Here),然后修改主题配置文件就可以 格式极其重要，修改配置问件事要注意中间要有一个空格才能有效注意注释前也要有空格 最后放两张我的文件夹，以便大家区分两个配置文件，看不懂的话可以看文件夹上方的路径，路径也看不懂那就没办法了 主文件夹 主题页 最后一点：不要怕出错，实践出真知，搞这个东西没错一段时间是没有游戏体验的，你懂的，这也是一个学习的过程，所以不要急，慢慢来，涨涨姿势，等到把雏形弄出来再慢慢搞UI也不迟。 最后欢迎大家补充，有地方不懂得可以留言，也可以发邮件，看到会回复的，祝大家能尽快拥有自己的网站","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kpl0111.github.io/blog/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://kpl0111.github.io/blog/tags/Blog/"},{"name":"Github","slug":"Github","permalink":"https://kpl0111.github.io/blog/tags/Github/"}]}]