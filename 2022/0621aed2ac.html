<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>
        Nefelibata
    </title>
    
<link rel="stylesheet" href="/blog/css/style.css">

    <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/kpl0111/blog/images/favicon.ico" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kpl0111/blog/css/style/github.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/gh/kpl0111/blog/js/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kpl0111/blog/js/highlight.min.js"></script>
    <!-- Include jQuery -->
    <!-- <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script> -->
    <!-- Include ClipboardJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/blog/atom.xml" title="Nefelibata" type="application/atom+xml">
</head>

<body>
    <div class="container">
        <div class="header">
    <!-- <div class="logo">
        <a href="/blog/">Nefelibata</a>
    </div> -->
    <!-- <div class="logo">
        <img src="/images/lkp.png" alt="Logo">
    </div> -->
    <div class="nav">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/blog/../" class="menu-item-link">
                        Nefelibata
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/blog/" class="menu-item-link">
                        Blog
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/blog/../gallery" class="menu-item-link">
                        Gallery
                    </a>
                </li>
            
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/kpl0111" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/blog/../about" class="menu-item-link">
                        About
                    </a>
                </li>
                
        </ul>
    </div>
</div>
        <div class="article">
    <!-- <div class="article-title">
        <h2>
            LeetCode笔记-二叉树
        </h2>
    </div> -->
    
        
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    <div class="article-meta">
        <div class="article-date">
            <i class="fas fa-edit"></i>
            2022/06/17 周五 19:07&nbsp;&nbsp;&nbsp;
            <span class="just-a-temp"><span>
            <i class="fas fa-redo"></i>
            2023/12/02 周六 21:44&nbsp;&nbsp;&nbsp;
            <span class="just-a-temp"><span>
            <i class="fas fa-file-word"></i>
            1271 words
        </div>
    </div>
    <div class="article-content">
        <blockquote>
<p>本篇为个人笔记，内容或有错误。<br>图片部分源于<a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a>，侵删。</p>
</blockquote>
<!-- toc -->

<h2 id="树的基本知识"><a href="#树的基本知识" class="headerlink" title="树的基本知识"></a>树的基本知识</h2><ol>
<li>节点：包含一个数据元素及若干指向子树分支的信息</li>
<li>节点的度：一个节点拥有子树的数目称为节点的度</li>
<li>叶子节点：也称为终端节点，没有子树的节点或者度为零的节点</li>
<li>分支节点：也称为非终端节点，度不为零的节点称为非终端节点</li>
<li>树的度：树中所有节点的度的最大值</li>
<li>节点的层次：从根节点开始，假设根节点为第1层，根节点的子节点为第2层，依此类推，如果某一个节点位于第L层，则其子节点位于第L+1层</li>
<li>树的深度：也称为树的高度，树中所有节点的层次最大值称为树的深度</li>
<li>有序树：如果树中各棵子树的次序是有先后次序，则称该树为有序树</li>
<li>无序树：如果树中各棵子树的次序没有先后次序，则称该树为无序树</li>
<li>森林：由m（m≥0）棵互不相交的树构成一片森林。如果把一棵非空的树的根节点删除，则该树就变成了一片森林，森林中的树由原来根节点的各棵子树构成</li>
</ol>
<h2 id="树的基本性质"><a href="#树的基本性质" class="headerlink" title="树的基本性质"></a>树的基本性质</h2><ol>
<li>二叉树的第i层上至多有$2^(i-1)（i≥1）$个节点</li>
<li>深度为h的二叉树中至多含有$2^h - 1$个节点</li>
<li>若在任意一棵二叉树中，有$n_0$个叶子节点，有$n_2$个度为2的节点，则必有$n_0 = n_2 + 1$</li>
<li>具有n个节点的满二叉树深为$log_2 (n + 1)$</li>
<li>若对一棵有n个节点的完全二叉树进行顺序编号（1≤i≤n），那么，对于编号为i（i≥1）的节点：<ul>
<li>当i=1时，该节点为根，它无双亲节点</li>
<li>当i&gt;1时，该节点的双亲节点的编号为$\frac{i}{2}$</li>
<li>若2i≤n，则有编号为2i的左节点，否则没有左节点</li>
<li>若2i+1≤n，则有编号为2i+1的右节点，否则没有右节点</li>
</ul>
</li>
</ol>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h3><p>二叉树有两种主要的形式：满二叉树和完全二叉树。</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p><strong>满二叉树：</strong> 如果一棵二叉树只有<strong>度</strong> (简单理解为孩子节点个数)为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200806185805576.png" width="600"> </p>
<p>这棵二叉树为满二叉树，也可以说<strong>深度</strong> (就是有几层)为k，有$2^k - 1$个节点的二叉树，比如本图，4层，那么4层的满二叉树就有$2^4 - 1 = 15$个节点</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><blockquote>
<p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 $1~&nbsp;2^(h-1)$ &nbsp;个节点。</p>
</blockquote>
<p><strong>优先级队列其实是一个堆，而堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树是有数值的树，<strong>二叉搜索树是一个有序树</strong>，它有一下几条性质：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p>eg：<br><img src="https://img-blog.csdnimg.cn/20200806190304693.png" width="600"> </p>
<h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><blockquote>
<p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and&nbsp;Landis）树，且具有以下性质：</p>
<blockquote>
<p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。(递归定义)</p>
</blockquote>
</blockquote>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200806190511967.png" width="600"> </p>
<p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p>
<p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是$log n$，而unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。</p>
<h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><blockquote>
<p>二叉树可以链式存储，也可以顺序存储</p>
</blockquote>
<p>链式存储用指针， 顺序存储用数组。</p>
<p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p>
<p>链式存储如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2020092019554618.png" width="600"> </p>
<p>顺序存储呢其实就是用数组来存储二叉树，顺序存储的方式如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200920200429452.png" width="600"> </p>
<p>用数组来存储二叉树如何遍历的呢？</p>
<p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<p>但是用链式表示的二叉树，更有利于理解，所以一般都是用链式存储二叉树。</p>
<p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p>
<h3 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h3><p>二叉树主要有两种遍历方式：</p>
<ol>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li>
<li>广度优先遍历(层级遍历)：一层一层的去遍历。</li>
</ol>
<p><strong>这两种遍历是图论中最基本的两种遍历方式</strong><br>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p>
<ul>
<li>深度优先遍历<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li>广度优先遍历<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要记住 前中后序指的就是中间节点的位置就可以了。</p>
<p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200806191109896.png" width="600"> </p>
<p><strong>栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。</p>
<p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p>
<h3 id="二叉树的代码实现"><a href="#二叉树的代码实现" class="headerlink" title="二叉树的代码实现"></a>二叉树的代码实现</h3><p>C++代码如下：</p>
<pre><code class="cpp">struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
</code></pre>
<p>相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。</p>
<h3 id="递归和迭代"><a href="#递归和迭代" class="headerlink" title="递归和迭代"></a>递归和迭代</h3><blockquote>
<p>在讲二叉树的遍历方式前，首先要搞明白递归和遍历的区别</p>
</blockquote>
<p><strong>递归（recursion）：</strong> 递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在函数定义中使用函数自身的方法。（A调用A）</p>
<p><strong>迭代（iteration）：</strong> 重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B）</p>
<p>递归是一个树结构，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。</p>
<p>迭代是一个环结构，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。</p>
<p>理论上递归和迭代时间复杂度方面是一样的，但实际应用中（函数调用和函数调用堆栈的开销）递归比迭代效率要低。<br><img src="https://s2.loli.net/2022/06/20/1waD7EyU86soVMn.png" alt="20220620201425"></p>
<h3 id="二叉树的递归遍历-递归非常重要！！！"><a href="#二叉树的递归遍历-递归非常重要！！！" class="headerlink" title="二叉树的递归遍历(递归非常重要！！！)"></a>二叉树的递归遍历(递归非常重要！！！)</h3><blockquote>
<p>一看就会，一写就废！</p>
</blockquote>
<p>首先要知道递归算法的三个要素：</p>
<ol>
<li><p><strong>确定递归函数的参数和返回值：</strong><br>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p>
</li>
<li><p><strong>确定终止条件：</strong><br>写完了递归算法,  运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p>
</li>
<li><p><strong>确定单层递归的逻辑：</strong><br>确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p>
</li>
</ol>
<p><strong>以下以前序遍历为例：</strong></p>
<ol>
<li><p><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入vector在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</p>
<pre><code class="cpp">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec)
</code></pre>
</li>
<li><p><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</p>
<pre><code class="cpp">if (cur == NULL) return;
</code></pre>
</li>
<li><p><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</p>
<pre><code class="cpp">vec.push_back(cur-&gt;val);    // 中
traversal(cur-&gt;left, vec);  // 左
traversal(cur-&gt;right, vec); // 右
</code></pre>
</li>
</ol>
<p>单层递归的逻辑就是按照中左右的顺序来处理的，代码如下：</p>
<pre><code class="CPP">class Solution {
public:
    void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) {
        if (cur == NULL) return;
        vec.push_back(cur-&gt;val);    // 中
        traversal(cur-&gt;left, vec);  // 左
        traversal(cur-&gt;right, vec); // 右
    }
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        traversal(root, result);
        return result;
    }
};
</code></pre>
<p>中序和后序代码如下：</p>
<p>中序遍历：</p>
<pre><code class="CPP">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) {
    if (cur == NULL) return;
    traversal(cur-&gt;left, vec);  // 左
    vec.push_back(cur-&gt;val);    // 中
    traversal(cur-&gt;right, vec); // 右
}
</code></pre>
<p>后序遍历：</p>
<pre><code class="CPP">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) {
    if (cur == NULL) return;
    traversal(cur-&gt;left, vec);  // 左
    traversal(cur-&gt;right, vec); // 右
    vec.push_back(cur-&gt;val);    // 中
}
</code></pre>
<h3 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h3><blockquote>
<p>听说还可以用非递归的方式</p>
</blockquote>
<p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<h4 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="前序遍历（迭代法）"></a>前序遍历（迭代法）</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）"></p>
<p>不难写出如下代码: （<strong>注意代码中空节点不入栈</strong>）</p>
<pre><code class="CPP">class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; st;
        vector&lt;int&gt; result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node-&gt;val);
            if (node-&gt;right) st.push(node-&gt;right);           // 右（空节点不入栈）
            if (node-&gt;left) st.push(node-&gt;left);             // 左（空节点不入栈）
        }
        return result;
    }
};
</code></pre>
<h4 id="中序遍历（迭代法）"><a href="#中序遍历（迭代法）" class="headerlink" title="中序遍历（迭代法）"></a>中序遍历（迭代法）</h4><blockquote>
<p>注意：中序遍历不能像递归那样微调前序遍历的代码</p>
</blockquote>
<p>在迭代的过程中，有两个操作：</p>
<ol>
<li><strong>处理：将元素放进result数组中</strong></li>
<li><strong>访问：遍历节点</strong></li>
</ol>
<p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p>
<p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p>
<p>那么<strong>在使用迭代法写中序遍历，我们就可以添加一个栈用来存放左孩子节点，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif" alt="二叉树中序遍历（迭代法）"></p>
<p><strong>中序遍历，可以写出如下代码：</strong></p>
<pre><code class="CPP">class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur-&gt;left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur-&gt;val);     // 中
                cur = cur-&gt;right;               // 右
            }
        }
        return result;
    }
};
</code></pre>
<h4 id="后序遍历（迭代法）"><a href="#后序遍历（迭代法）" class="headerlink" title="后序遍历（迭代法）"></a>后序遍历（迭代法）</h4><blockquote>
<p>数组部分更改前后顺序，要考虑向更改局部，然后整体反转这种思路能不能行的通</p>
</blockquote>
<p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200808200338924.png" alt="前序到后序"></p>
<p><strong>所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</strong></p>
<pre><code class="CPP">class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        stack&lt;TreeNode*&gt; st;
        vector&lt;int&gt; result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node-&gt;val);
            if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
</code></pre>
<h3 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h3><h4 id="中序遍历代码如下：（详细注释）"><a href="#中序遍历代码如下：（详细注释）" class="headerlink" title="中序遍历代码如下：（详细注释）"></a>中序遍历代码如下：（详细注释）</h4><pre><code class="CPP">class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node-&gt;right) st.push(node-&gt;right);  // 添加右节点（空节点不入栈）

                st.push(node);                          // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node-&gt;left) st.push(node-&gt;left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node-&gt;val); // 加入到结果集
            }
        }
        return result;
    }
};
</code></pre>
<p>同理，前序和后续只需要微调一下加入栈的顺序就可以了，我们利用根节点先把所有节点按照我们需要的遍历方法存储到栈里面，然后把需要特定顺序遍历的节点用NULL节点标记，即可实现迭代的统一写法。</p>
<h4 id="迭代法前序遍历"><a href="#迭代法前序遍历" class="headerlink" title="迭代法前序遍历"></a>迭代法前序遍历</h4><pre><code class="CPP">class Solution {
public:
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node-&gt;right) st.push(node-&gt;right);  // 右
                if (node-&gt;left) st.push(node-&gt;left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node-&gt;val);
            }
        }
        return result;
    }
};
</code></pre>
<h4 id="迭代法后序遍历"><a href="#迭代法后序遍历" class="headerlink" title="迭代法后序遍历"></a>迭代法后序遍历</h4><pre><code class="CPP">class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);

                if (node-&gt;right) st.push(node-&gt;right);  // 右
                if (node-&gt;left) st.push(node-&gt;left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node-&gt;val);
            }
        }
        return result;
    }
};
</code></pre>
<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。</p>
<p>需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑。</p>
<pre><code class="C++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        queue&lt;TreeNode*&gt; que;
        if (root != NULL) que.push(root);
        vector&lt;vector&lt;int&gt;&gt; result;
        while (!que.empty()) {
            int size = que.size();
            vector&lt;int&gt; tmp;
            for (int i = 0; i &lt; size; i++) {
                TreeNode* node = que.front();
                que.pop();
                tmp.push_back(node-&gt;val);
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            }
            result.push_back(tmp);
        }
        return result;
    }
};
</code></pre>

    </div>

    <div class="totop">ToTop</div>
    <script type="text/javascript" src="../libs/codeBlock/codeBlockFuction.js"></script>
    <!-- 代码语言 -->
    <script type="text/javascript" src="../libs/codeBlock/codeLang.js"></script>
    <!-- 代码块复制 -->
    <script type="text/javascript" src="../libs/codeBlock/codeCopy.js"></script>
    <script type="text/javascript" src="../libs/codeBlock/clipboard.min.js"></script>
    <!-- 代码块收缩 -->
    <script type="text/javascript" src="../libs/codeBlock/codeShrink.js"></script> 
    <!-- 代码块折行 -->
    <style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>
</div>
        <div class="footer">
    <a href="#">
        2020 <i class="fab fa-studiovinari"></i> Nefelibata <i class="fas fa-angle-double-up"></i>
    </a>
</div>


<script src="/blog/js/totop.js"></script>


<script src="/blog/js/search.js"></script>

    </div>
</body>

</html>