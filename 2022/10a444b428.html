<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>
        Nefelibata
    </title>
    
<link rel="stylesheet" href="/blog/css/style.css">

    <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/kpl0111/blog/images/favicon.ico" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kpl0111/blog/css/style/github.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/gh/kpl0111/blog/js/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kpl0111/blog/js/highlight.min.js"></script>
    <!-- Include jQuery -->
    <!-- <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script> -->
    <!-- Include ClipboardJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/blog/atom.xml" title="Nefelibata" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
    <div class="container">
        <div class="header">
    <!-- <div class="logo">
        <a href="/blog/">Nefelibata</a>
    </div> -->
    <!-- <div class="logo">
        <img src="/images/lkp.png" alt="Logo">
    </div> -->
    <div class="nav">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/blog/../" class="menu-item-link">
                        Nefelibata
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/blog/" class="menu-item-link">
                        Blog
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/blog/../gallery" class="menu-item-link">
                        Gallery
                    </a>
                </li>
            
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/kpl0111" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/blog/../about" class="menu-item-link">
                        About
                    </a>
                </li>
                
        </ul>
    </div>
</div>
        <div class="article">
    <!-- <div class="article-title">
        <h2>
            排序
        </h2>
    </div> -->
    
        
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    <div class="article-meta">
        <div class="article-date">
            <i class="fas fa-edit"></i>
            2022/10/15 周六 11:08&nbsp;&nbsp;&nbsp;
            <span class="just-a-temp"><span>
            <i class="fas fa-redo"></i>
            2023/11/26 周日 14:04
        </div>
    </div>
    <div class="article-content">
        <p><img src="https://picture-0111.oss-cn-beijing.aliyuncs.com/img/20221015114004.png" alt="20221015114004"></p>
<h2 id="冒泡排序（Bubble-Sort）（稳定排序）（超出时间限制）"><a href="#冒泡排序（Bubble-Sort）（稳定排序）（超出时间限制）" class="headerlink" title="冒泡排序（Bubble Sort）（稳定排序）（超出时间限制）"></a>冒泡排序（Bubble Sort）（稳定排序）（超出时间限制）</h2><p>比较相邻元素，如果第一个比第二个大，则交换。</p>
<p>时间复杂度$n^2$，空间复杂度1</p>
<p>代码：</p>
<pre><code class="cpp">class Solution {
public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        // bubbleSort
        int n = nums.size();
        for (int i = 0; i &lt; n - 1; ++i) {
            bool flag = false;
            for (int j = 0; j &lt; n - 1 - i; ++j) {
                if (nums[j] &gt; nums[j + 1]) {
                    swap(nums[j], nums[j + 1]);
                    flag = true;
                }                 
            }
            if (flag == false) break; //无交换，代表当前序列已经最优 
        }
        return nums;
    }
};
</code></pre>
<h2 id="选择排序（Select-Sort）（非稳定排序）（超出时间限制）"><a href="#选择排序（Select-Sort）（非稳定排序）（超出时间限制）" class="headerlink" title="选择排序（Select Sort）（非稳定排序）（超出时间限制）"></a>选择排序（Select Sort）（非稳定排序）（超出时间限制）</h2><p>依次给每个位置选择当前位置及以后最小的元素（交换当前元素与之后最小元素的位置）。</p>
<p>不稳定举例：<br>排序前：5, 5*, 1, 7<br>排序后：1, 5*, 5, 7</p>
<p>时间复杂度$n^2$，空间复杂度1</p>
<p>代码：</p>
<pre><code class="cpp">class Solution {
public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        // selectSort 选择排序
        int minIndex;
        int n = nums.size();
        for (int i = 0; i &lt; n - 1; ++i) {
            minIndex = i;
            for (int j = i + 1; j &lt; n; ++j) {
                if (nums[j] &lt; nums[minIndex]) {
                    minIndex = j;
                }
            }
            swap(nums[i], nums[minIndex]);
        }
        return nums;
    }
};
</code></pre>
<h2 id="插入排序（Insect-Sort）（稳定排序）（超出时间限制）"><a href="#插入排序（Insect-Sort）（稳定排序）（超出时间限制）" class="headerlink" title="插入排序（Insect Sort）（稳定排序）（超出时间限制）"></a>插入排序（Insect Sort）（稳定排序）（超出时间限制）</h2><p>在前 1~i - 1元素有序的情况下，（依次）将第 i 个元素插入前面已经有序的小序列，使其有序。使用哨兵减少比较</p>
<p>时间复杂度$n^2$，空间复杂度1</p>
<p>代码：</p>
<pre><code class="cpp">class Solution {
public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        int i, j;
        for (i = 2; i &lt;= nums.size(); i++) {
            if (nums[i] &lt; nums[i - 1]) {
                nums[0] = nums[i]; //nums[0]为哨兵
                for (j = i - 1; nums[0] &lt; nums[j]; j--) {
                    nums[j + 1] =nums[j];
                }
                nums[j + 1] = nums[0];
            }
        }
        return nums;
    }
};
</code></pre>
<p>插入排序在此基础上也可以将搜索和移动分开，使用二分查找先找到要插入位置，然后再移动</p>
<pre><code class="cpp">class Solution {
public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        int i, j, low, high, mid;
        for (i = 2; i &lt;= nums.size(); i++) {
            nums[0] = nums[i];
            low = 1; high = i - 1;
            while (low &lt;= high) {
                mid = (low + high) / 2;
                if (nums[mid] &gt; nums[0]) high = mid - 1;
                else low = mid + 1;
            }
            for (j = i - 1; j &gt; high + 1; j--)
                nums[j + 1] = nums[j];
            nums[high + 1] = nums[0];
        }
        return nums;
    }
};
</code></pre>
<h2 id="希尔排序（Shell-Sort）（非稳定排序）"><a href="#希尔排序（Shell-Sort）（非稳定排序）" class="headerlink" title="希尔排序（Shell Sort）（非稳定排序）"></a>希尔排序（Shell Sort）（非稳定排序）</h2><p>改进的插入排序（优化：原数组的一个元素距离正确位置很远的情况）<br>先让间隔 h 的元素有序，在使得间隔为 h / 2，一直缩小，一直到 h = 1（此时数组有序）。</p>
<p>时间复杂度介于nlogn和$n^2$之间，空间复杂度1</p>
<p>代码：</p>
<pre><code class="cpp">class Solution {
    void shellSort(vector&lt;int&gt;&amp;nums, int gap, int i) {
        int j, tmp = nums[i];
        for (j = i - gap; j &gt;= 0 &amp;&amp; tmp &lt; nums[j]; j -= gap) {
            // 依次后移
            nums[j + gap] = nums[j];
        }
        nums[j + gap] = tmp;
    }
public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        // 分组，最开始时，间隔 gap 为数组的一半
        for (int gap = n / 2; gap &gt;= 1 ; gap /= 2) {
            // 对各个分组进行插入分组
            for (int i = gap; i &lt; n; ++i) {
                shellSort(nums, gap, i);
            }
        }
        return nums;
    }
};
</code></pre>
<h2 id="归并排序（Merge-Sort）（稳定排序）"><a href="#归并排序（Merge-Sort）（稳定排序）" class="headerlink" title="归并排序（Merge Sort）（稳定排序）"></a>归并排序（Merge Sort）（稳定排序）</h2><p>将无序数组拆分，排序后再合并成大的有序数组。</p>
<p>时间复杂度nlogn，空间复杂度n</p>
<p>代码：</p>
<pre><code class="cpp">class Solution {
    vector&lt;int&gt; tmp;
    void merge (vector&lt;int&gt;&amp; nums, int low, int mid, int high) {
        for (int k = low; k &lt;= high; k++) {
            tmp[k] = nums[k];
        }

        int i, j;
        for (i = low, j = mid + 1, k = i; i &lt;= mid &amp;&amp; j &lt;=high; k++) {
            if (tmp[i] &lt;= tmp[j]) {
                nums[k] = tmp[i++];
            } else {
                nums[k] = tmp[j++];
            }
        }
        while (i &lt;= mid) nums[k++] = tmp[i++];
        while (j &lt;= high) nums[k++] = tmp[j++];
    }
public:
    vector&lt;int&gt; mergeSort(vector&lt;int&gt;&amp; nums, int low, int high) {
        if (low &lt; high) {
            int mid = (low + high) / 2;
            mergeSort(nums, low, mid + 1);
            mergeSort(nums, mid + 1, high);
            merge(nums, low, mid, high);
        }
    }
};
</code></pre>
<h2 id="快速排序（Quick-Sort）（非稳定排序）"><a href="#快速排序（Quick-Sort）（非稳定排序）" class="headerlink" title="快速排序（Quick Sort）（非稳定排序）"></a>快速排序（Quick Sort）（非稳定排序）</h2><p>随机选取一个数（x = rand() % len + startIndex）作为基准；<br>把比基准小的数交换到前面，比基准大的数交换到后面；<br>对左右区间递归重复。</p>
<p>时间复杂度nlogn，空间复杂度logn</p>
<p>代码：</p>
<pre><code class="cpp">class Solution {
    void quickSort(vector&lt;int&gt;&amp;nums, int startIndex, int endIndex) {
        if (startIndex &gt;= endIndex) return;
        
        int x = rand() % (endIndex - startIndex + 1) + startIndex; // 基于随机的原则
        swap(nums[startIndex], nums[x]);
        int firstNum = nums[startIndex];
        
        int l = startIndex, r = endIndex;
        while (l &lt; r) {
            // 从后往前走，将比第一个小的移到前面
            while (l &lt; r &amp;&amp; nums[r] &gt;= firstNum) --r;
            if (l &lt; r) {
                nums[l] = nums[r];
            }
            // 从前往后走，将比第一个大的移到后面
            while (l &lt; r &amp;&amp; nums[l] &lt;= firstNum) ++l;
            if (l &lt; r) {
                nums[r] = nums[l];
            }
        }
        nums[l] = firstNum;
        // 自顶向下
        quickSort(nums, startIndex, l - 1);
        quickSort(nums, l + 1, endIndex);
    }

public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        quickSort(nums, 0, n - 1);
        return nums;
    }
};
</code></pre>
<h2 id="堆排序（Heap-Sort）（非稳定排序）"><a href="#堆排序（Heap-Sort）（非稳定排序）" class="headerlink" title="堆排序（Heap Sort）（非稳定排序）"></a>堆排序（Heap Sort）（非稳定排序）</h2><p>先在原先数组的基础上构造大根堆（时间复杂度nlogn）；<br>再依次弹出最大元素（每次弹出的时间复杂度为logk，k为当前大根堆中元素数目）。</p>
<p>时间复杂度nlogn，空间复杂度1</p>
<p>代码：</p>
<pre><code class="cpp">class Solution {
    void buildMaxHeap(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        for (int i = (n - 1) / 2; i &gt;= 0; --i) {
            maxHeapify(nums, i, n);
        }
    }

    void maxHeapify(vector&lt;int&gt;&amp; nums, int i, int n) {
        while (i * 2 + 1 &lt; n) {
            // 代表当前 i 节点的左右儿子；
            // 超出数组大小则代表当前 i 节点为叶子节点，不需要移位
            int lSon = 2 * i + 1;
            int rSon = 2 * i + 2;
            int large = i;
            if (lSon &lt; n &amp;&amp; nums[lSon] &gt; nums[i]) large = lSon;
            if (rSon &lt; n &amp;&amp; nums[rSon] &gt; nums[large]) large = rSon;

            if (large != i) {
                swap(nums[i], nums[large]);
                // 迭代判断对应子节点及其儿子节点的大小关系
                i = large;
            } else {
                break;
            }
        }
    }

public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        // heapSort 堆排序
        int n = nums.size();
        // 将数组整理成大根堆
        buildMaxHeap(nums);
        for (int i = n - 1; i &gt;= 1; --i) {
            // 依次弹出最大元素，放到数组最后，当前排序对应数组大小 - 1
            swap(nums[0], nums[i]);
            --n;
            maxHeapify(nums, 0, n);
        }
        return nums;
    }
};
</code></pre>
<h2 id="计数排序（Count-Sort）（稳定排序）"><a href="#计数排序（Count-Sort）（稳定排序）" class="headerlink" title="计数排序（Count Sort）（稳定排序）"></a>计数排序（Count Sort）（稳定排序）</h2><p>创建数组 counts，用于统计原数组 nums 中各元素值的出现次数；<br>再依次将元素值赋值到 nums 中对应位置。</p>
<p>计数排序，时间复杂度n + k，空间复杂度k（k = maxNum - minNum + 1）</p>
<p>代码：</p>
<pre><code class="cpp">class Solution {
public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        // CountSort 计数排序
        int n = nums.size();
        int minNum = INT_MAX, maxNum = INT_MIN;
        // 找到数组中的最小和最大元素
        for (int i = 0; i &lt; n; ++i) {
            if (nums[i] &lt; minNum) minNum = nums[i];
            if (nums[i] &gt; maxNum) maxNum = nums[i];
        }
        // 构造计数数组
        vector&lt;int&gt; counts(maxNum - minNum + 1, 0);
        for (int i = 0; i &lt; n; ++i) {
            ++counts[nums[i] - minNum];
        }
        // 计数排序
        int index = 0;
        for (int i = 0; i &lt; counts.size(); ++i) {
            while (counts[i] != 0) {
                nums[index++] = i + minNum;
                counts[i]--;
            }
        }
        return nums;
    }
};
</code></pre>
<h2 id="桶排序（Bucket-Sort）（稳定排序）"><a href="#桶排序（Bucket-Sort）（稳定排序）" class="headerlink" title="桶排序（Bucket Sort）（稳定排序）"></a>桶排序（Bucket Sort）（稳定排序）</h2><p>将原数组的元素分到有限数量的桶里（大编号桶里的所有元素均大于小编号桶里的任意元素）；<br>分别对每个桶进行排序；<br>依次合并。</p>
<p>时间复杂度n + k，空间复杂度n + k（k为桶的数量）</p>
<p>代码：</p>
<pre><code class="cpp">class Solution {
public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        // BucketSort 桶排序
        int n = nums.size();
        // 获取数组的最小值和最大值
        int maxNum = nums[0], minNum = nums[0];
        for (int i = 1; i &lt; n; ++i) {
            if (nums[i] &gt; maxNum) maxNum = nums[i];
            if (nums[i] &lt; minNum) minNum = nums[i];
        }
        // 初始化桶
        int bucketNum = 5, bucketSize = (maxNum - minNum) / bucketNum + 1;
        vector&lt;vector&lt;int&gt;&gt; buckets(bucketNum, vector&lt;int&gt;(0));
        // 小至大分桶
        for (int num : nums) {
            int bucketIndex = (num - minNum) / bucketSize;
            buckets[bucketIndex].emplace_back(num);
        }
        // 桶内排序
        for (int i = 0; i &lt; buckets.size(); ++i) {
            sort(buckets[i].begin(), buckets[i].end());
        }
        // 从桶中依次取数
        int index = 0;
        for (auto&amp; bucket : buckets) {
            for (int num : bucket) {
                nums[index++] = num;
            }
        }

        return nums;
    }
};
</code></pre>
<h2 id="基数排序（Radix-Sort）（稳定排序）"><a href="#基数排序（Radix-Sort）（稳定排序）" class="headerlink" title="基数排序（Radix Sort）（稳定排序）"></a>基数排序（Radix Sort）（稳定排序）</h2><p>对数组中所有数依次按由低到高的位数进行多次排序；<br>每次排序都基于上次排序的结果。<br>（相对位置顺序保持不变）</p>
<p>例：原始数组 1，23，21，11，32<br>第一次排序后 1，21，11，32，23<br>第二次排序后 1，11，21，23，32<br>时间复杂度n x k，空间复杂度k（k为最大元素的位数）</p>
<p>代码：</p>
<pre><code class="cpp">class Solution {
    vector&lt;int&gt; counts;
    void radixSort(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; tmp, int divisor) {
        int n = nums.size();
        counts = vector&lt;int&gt;(10, 0);
        // 统计个、十、百、千、万上对应 0 ~ 9 的出现次数
        for (int i = 0; i &lt; n; ++i) {
            int x = (nums[i] / divisor) % 10;
            ++counts[x];
        }
        // 前缀和
        for (int i = 1; i &lt;= 9; ++i) {
            counts[i] += counts[i - 1];
        }
        // 从后向前赋值
        for (int i = n - 1; i &gt;= 0; --i) {
            int x = (nums[i] / divisor) % 10;
            int index = counts[x] - 1;
            tmp[index] = nums[i];
            --counts[x];
        }
    }

public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        // RadixSort 基数排序
        int n = nums.size();
        // 预处理，让所有的数都大于等于0
        for (int i = 0; i &lt; n; ++i) {
            nums[i] += 50000; // 50000为最小可能的数组大小
        }
        // 找出最大的数字，并获得其最大位数
        int maxNum = nums[0];
        for (int i = 0; i &lt; n; ++i) {
            if (nums[i] &gt; maxNum) {
                maxNum = nums[i];
            }
        }
        int num = maxNum, maxLen = 0;
        while (num) {
            ++maxLen;
            num /= 10;
        }
        // 基数排序，低位优先
        int divisor = 1;
        vector&lt;int&gt; tmp(n, 0);
        for (int i = 0; i &lt; maxLen; ++i) {
            radixSort(nums, tmp, divisor);
            swap(tmp, nums);
            divisor *= 10;
        }
        // 减去预处理量
        for (int i = 0; i &lt; n; ++i) {
            nums[i] -= 50000;
        }
        return nums;
    }
};
</code></pre>

    </div>

    <div class="totop">ToTop</div>
    <script type="text/javascript" src="../libs/codeBlock/codeBlockFuction.js"></script>
    <!-- 代码语言 -->
    <script type="text/javascript" src="../libs/codeBlock/codeLang.js"></script>
    <!-- 代码块复制 -->
    <script type="text/javascript" src="../libs/codeBlock/codeCopy.js"></script>
    <script type="text/javascript" src="../libs/codeBlock/clipboard.min.js"></script>
    <!-- 代码块收缩 -->
    <script type="text/javascript" src="../libs/codeBlock/codeShrink.js"></script> 
    <!-- 代码块折行 -->
    <style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>
</div>
        <div class="footer">
    <a href="#">
        2020 <i class="fab fa-studiovinari"></i> Nefelibata <i class="fas fa-angle-double-up"></i>
    </a>
</div>


<script src="/blog/js/totop.js"></script>


<script src="/blog/js/search.js"></script>

    </div>
</body>

</html>