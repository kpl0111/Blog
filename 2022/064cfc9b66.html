<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/blog/img/favicon.png">
    <title>Nefelibata | Nefelibata</title>
    
<link rel="stylesheet" href="/blog/css/reset.css">

    
<link rel="stylesheet" href="/blog/css/style.css">

    
<link rel="stylesheet" href="/blog/css/markdown.css">

    
<link rel="stylesheet" href="/blog/css/fonts.css">
<link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/blog/atom.xml" title="Nefelibata" type="application/atom+xml">
</head>

    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/blog/">Nefelibata</a>
    <a class="go-home" href="/blog/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            LeetCode笔记-哈希表
        </div>
        <div class="post-meta">
            2022-06-12
        </div>
    

    <div class="post-md">
        <blockquote>
<p>本篇为个人笔记，内容或有错误。<br>
图片部分源于<a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a>，侵删。</p>
</blockquote>
<!-- toc -->
<ul>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>
<ul>
<li><a href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E">哈希碰撞</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84">常见的三种哈希结构</a></li>
<li><a href="#%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9">三种数据结构的选择</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="哈希表"> 哈希表</span></h2>
<blockquote>
<p>哈希表是根据关键码的值而直接进行访问的数据结构。<br>
一般哈希表都是用来快速判断一个元素是否出现在集合里。</p>
</blockquote>
<h3><span id="哈希碰撞"> 哈希碰撞</span></h3>
<p>两个元素同时映射到哈希表中同一位置，这一现象叫做哈希碰撞，如下例：<br>
<img src="https://s2.loli.net/2022/06/12/8AsRHUdwTS6kpgv.png" alt="20220612173210"></p>
<p>一般处理方法有两种，拉链法和线性探测法。</p>
<h4><span id="拉链法"> 拉链法</span></h4>
<p><img src="https://s2.loli.net/2022/06/12/6nHRVWyIAxL9XwT.png" alt="20220612173630"><br>
其实拉链法就是要选择合适的哈希表大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间</p>
<h4><span id="线性探测法"> 线性探测法</span></h4>
<p>使用线性探测法，一定要保证tablesize大于datasize，需要依靠哈希表中的空位来解决碰撞问题。</p>
<p><img src="https://s2.loli.net/2022/06/12/2Erl7dHO8IuGxyU.png" alt="20220612174935"></p>
<h3><span id="常见的三种哈希结构"> 常见的三种哈希结构</span></h3>
<p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p>
<ul>
<li>数组</li>
<li>set （集合）</li>
<li>map(映射)</li>
</ul>
<p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：<br>
<img src="https://s2.loli.net/2022/06/12/Wj8mAD2QnyKzukM.png" alt="20220612183010"></p>
<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。<br>
<img src="https://s2.loli.net/2022/06/12/IJDeZ8yNmncR3SU.png" alt="20220612183049"></p>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<p>那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p>
<h3><span id="三种数据结构的选择"> 三种数据结构的选择</span></h3>
<ol>
<li>数据量给定而且没有太大需求的可以直接选择数组。</li>
<li>数据量未知而且如果哈希值比较少、特别分散、跨度非常大，使用set，使用数组就造成空间的极大浪费</li>
<li>直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的，所以可以用数组的优先选择数组</li>
<li>map是采用了key-value的方式，一般可以用来保存一一对应的键值对</li>
</ol>

    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 Nefelibata</span>
    <span>Theme Designed By <a target="_blank" href="https://github.com/kpl0111">Nefelibata</a></span>
</div>


<link rel="stylesheet" href="/blog/css/a11y-dark.min.css">


<script src="/blog/js/highlight.min.js"></script>


<script src="/blog/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>