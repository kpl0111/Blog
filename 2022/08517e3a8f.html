<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>
        Nefelibata
    </title>
    
<link rel="stylesheet" href="/blog/css/style.css">

    <link rel="shortcut icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/kpl0111/blog/images/favicon.ico" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kpl0111/blog/css/style/github.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/gh/kpl0111/blog/js/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/kpl0111/blog/js/highlight.min.js"></script>
    <!-- Include jQuery -->
    <!-- <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script> -->
    <!-- Include ClipboardJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/blog/atom.xml" title="Nefelibata" type="application/atom+xml">
</head>

<body>
    <div class="container">
        <div class="header">
    <!-- <div class="logo">
        <a href="/blog/">Nefelibata</a>
    </div> -->
    <!-- <div class="logo">
        <img src="/images/lkp.png" alt="Logo">
    </div> -->
    <div class="nav">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/blog/../" class="menu-item-link">
                        Nefelibata
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/blog/" class="menu-item-link">
                        Blog
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/blog/../gallery" class="menu-item-link">
                        Gallery
                    </a>
                </li>
            
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/kpl0111" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                <li class="menu-item">
                    <a href="/blog/../about" class="menu-item-link">
                        About
                    </a>
                </li>
                
        </ul>
    </div>
</div>
        <div class="article">
    <!-- <div class="article-title">
        <h2>
            背包理论基础01背包2
        </h2>
    </div> -->
    
        
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    <div class="article-meta">
        <div class="article-date">
            <i class="fas fa-edit"></i>
            2022/08/10 周三 13:21&nbsp;&nbsp;&nbsp;
            <span class="just-a-temp"><span>
            <i class="fas fa-redo"></i>
            2023/12/16 周六 18:48&nbsp;&nbsp;&nbsp;
            <span class="just-a-temp"><span>
            <i class="fas fa-file-word"></i>
            837 words
        </div>
    </div>
    <div class="article-content">
        <p>摘要待补充</p>
<span id="more"></span>



<!-- toc -->

<blockquote>
<p>转载自<a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a>，侵删</p>
</blockquote>
<p>建议按照如下顺序观看：<br><a target="_blank" rel="noopener" href="https://kpl0111.github.io/blog/2022/08c8776b35.html">背包理论基础01背包1</a><br><a target="_blank" rel="noopener" href="https://kpl0111.github.io/blog/2022/08517e3a8f.html">背包理论基础01背包2（本文）</a><br><a target="_blank" rel="noopener" href="https://kpl0111.github.io/blog/2022/08806f2082.html">背包基础理论完全背包</a><br><a target="_blank" rel="noopener" href="https://kpl0111.github.io/blog/2022/0871e46bfb.html">背包基础理论多重背包</a></p>
<h1 id="动态规划：关于01背包问题，你该了解这些！（滚动数组）"><a href="#动态规划：关于01背包问题，你该了解这些！（滚动数组）" class="headerlink" title="动态规划：关于01背包问题，你该了解这些！（滚动数组）"></a>动态规划：关于01背包问题，你该了解这些！（滚动数组）</h1><p>昨天<a target="_blank" rel="noopener" href="https://kpl0111.github.io/blog/2022/08c8776b35.html">背包理论基础01背包1</a>中是用二维dp数组来讲解01背包。</p>
<p>今天我们就来说一说滚动数组，其实在前面的题目中我们已经用到过滚动数组了，就是把二维dp降为一维dp，一些录友当时还表示比较困惑。</p>
<p>那么我们通过01背包，来彻底讲一讲滚动数组！</p>
<p>接下来还是用如下这个例子来进行讲解</p>
<p>背包最大重量为4。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">重量</th>
<th align="center">价值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物品0</td>
<td align="center">1</td>
<td align="center">15</td>
</tr>
<tr>
<td align="center">物品1</td>
<td align="center">3</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">物品2</td>
<td align="center">4</td>
<td align="center">30</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<h2 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h2><p>对于背包问题其实状态都是可以压缩的。</p>
<p>在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>
<p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</strong></p>
<p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p>
<p>这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p>
<p>读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。</p>
<p><strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<p>一定要时刻记住这里i和j的含义，要不然很容易看懵了。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组的定义</li>
</ol>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<ol start="2">
<li>一维dp数组的递推公式</li>
</ol>
<p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p>所以递归公式为：</p>
<pre><code class="cpp">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
</code></pre>
<p>可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。</p>
<ol start="3">
<li>一维dp数组如何初始化</li>
</ol>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>
<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>
<p>看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>
<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>
<ol start="4">
<li>一维dp数组遍历顺序</li>
</ol>
<p>代码如下：</p>
<pre><code class="cpp">for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
</code></pre>
<p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p>
<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>
<p>为什么呢？</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15</p>
<p>如果正序遍历</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 30</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算dp[2]</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 15  （dp数组已经都初始化为0）</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>
<p><strong>那么问题又来了，为什么二维dp数组历的时候不用倒序呢？</strong></p>
<p>因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！</p>
<p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p>
<p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p>
<p>不可以！</p>
<p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。</p>
<p>（这里如果读不懂，就在回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）</p>
<p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103614769.png" alt="动态规划-背包问题9"></p>
<h2 id="一维dp01背包完整C-测试代码"><a href="#一维dp01背包完整C-测试代码" class="headerlink" title="一维dp01背包完整C++测试代码"></a>一维dp01背包完整C++测试代码</h2><pre><code class="CPP">void test_1_wei_bag_problem() {
    vector&lt;int&gt; weight = {1, 3, 4};
    vector&lt;int&gt; value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector&lt;int&gt; dp(bagWeight + 1, 0);
    for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;
}

int main() {
    test_1_wei_bag_problem();
}
</code></pre>
<p>可以看出，一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了。</p>
<p><strong>所以我倾向于使用一维dp数组的写法，比较直观简洁，而且空间复杂度还降了一个数量级！</strong></p>
<p><strong>在后面背包问题的讲解中，我都直接使用一维dp数组来进行推导</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的讲解可以开发一道面试题目（毕竟力扣上没原题）。</p>
<p>就是本文中的题目，要求先实现一个纯二维的01背包，如果写出来了，然后再问为什么两个for循环的嵌套顺序这么写？反过来写行不行？再讲一讲初始化的逻辑。</p>
<p>然后要求实现一个一维数组的01背包，最后再问，一维数组的01背包，两个for循环的顺序反过来写行不行？为什么？</p>
<p>注意以上问题都是在候选人把代码写出来的情况下才问的。</p>
<p>就是纯01背包的题目，都不用考01背包应用类的题目就可以看出候选人对算法的理解程度了。</p>
<p><strong>相信大家读完这篇文章，应该对以上问题都有了答案！</strong></p>
<p>此时01背包理论基础就讲完了，我用了两篇文章把01背包的dp数组定义、递推公式、初始化、遍历顺序从二维数组到一维数组统统深度剖析了一遍，没有放过任何难点。</p>
<p>大家可以发现其实信息量还是挺大的。</p>
<p>如果把<a target="_blank" rel="noopener" href="https://kpl0111.github.io/blog/2022/08c8776b35.html">背包理论基础01背包1</a>和本篇的内容都理解了，后面我们在做01背包的题目，就会发现非常简单了。</p>
<p>不用再凭感觉或者记忆去写背包，而是有自己的思考，了解其本质，代码的方方面面都在自己的掌控之中。</p>
<p>即使代码没有通过，也会有自己的逻辑去debug，这样就思维清晰了。</p>
<p><a target="_blank" rel="noopener" href="https://kpl0111.github.io/blog/2022/08c8776b35.html">背包理论基础01背包1</a><br><a target="_blank" rel="noopener" href="https://kpl0111.github.io/blog/2022/08517e3a8f.html">背包理论基础01背包2（本文）</a><br><a target="_blank" rel="noopener" href="https://kpl0111.github.io/blog/2022/08806f2082.html">背包基础理论完全背包</a><br><a target="_blank" rel="noopener" href="https://kpl0111.github.io/blog/2022/0871e46bfb.html">背包基础理论多重背包</a></p>

    </div>

    <div class="totop">ToTop</div>
    <script type="text/javascript" src="../libs/codeBlock/codeBlockFuction.js"></script>
    <!-- 代码语言 -->
    <script type="text/javascript" src="../libs/codeBlock/codeLang.js"></script>
    <!-- 代码块复制 -->
    <script type="text/javascript" src="../libs/codeBlock/codeCopy.js"></script>
    <script type="text/javascript" src="../libs/codeBlock/clipboard.min.js"></script>
    <!-- 代码块收缩 -->
    <script type="text/javascript" src="../libs/codeBlock/codeShrink.js"></script> 
    <!-- 代码块折行 -->
    <style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>
</div>
        <div class="footer">
    <a href="#">
        2020 <i class="fab fa-studiovinari"></i> Nefelibata <i class="fas fa-angle-double-up"></i>
    </a>
</div>


<script src="/blog/js/totop.js"></script>


<script src="/blog/js/search.js"></script>

    </div>
</body>

</html>