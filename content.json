[{"title":"LeetCode笔记","date":"2022-05-25T11:55:34.000Z","path":"2022/05fcf9ff47.html","text":"本篇为个人笔记，内容或有错误。 数组需要两点注意的是： 数组下标都是从0开始的 数组内存空间的地址是连续的 正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址，而且数组不能增删，只能覆盖。在C++中二维数组在地址空间上是连续的。但是Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。所以看不到每个元素的地址情况。 二分使用二分的前提是： 有序数组 无重复元素 使用二分时一般需要注意边界条件的处理，一般包括以下两种情况： 左闭右闭 左闭右开 二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 双指针使用双指针可以实现滑动窗口等操作，避免了循环嵌套，大大降低了时间复杂度 螺旋矩阵要注意四个方向临界条件以及区间类型都要一致 链表链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链接的入口节点称为链表的头结点也就是head。","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://kpl0111.github.io/blog/tags/LeetCode/"}]},{"title":"MD5加密算法C++实现","date":"2022-05-23T12:10:38.000Z","path":"2022/05d90a8c79.html","text":"实验目的本次实验通过C++编程实现MD5加密算法，通过了解MD5算法加深对Hash函数的认识 实验原理Hash 函数是将任意长的数字串转换成一个较短的定长输出数字串的函数，输出的结果称为 Hash 值。Hash 函数具有如下特点： 快速性：对于任意一个输入值 x，由 Hash 函数H(x) ，计算 Hash值 y，即H(x) = y是非常容易的 单向性：对于任意一个输出值 y，希望反向推出输入值 x，使得H(x) = y，是非常困难的。 无碰撞性：包括强无碰撞性和弱无碰撞性，一个好的 Hash 函数应该满足强无碰撞性，即找到两个不同的数字串 x 和 y，满足H(x) = H(y)，在计算上是不可能的。 MD5算法满足Hash特性，然而需要说明的是,2004年8月，在Crypto2004国际密码学会议上，山东大学王小云教授发现了一种找到MD5散列函数的碰撞的方法，即可以找到两个不同的输入x和y，得到相同的Hash结果。这一发现意味着采用MD5算法的数字签名、完整性检验等信息安全应用系统将不在安全了，这就促使信息安全系统的设计者尽快去寻找和探索新的Hash算法。 MD5算法模块拆解 获取输入，该模块用于获取一段明文字符，不定长 对获取的不定长字符串进行填充,使其字节长度满足n*512 + 448, 填充规则是第一位填充1，后续填充0，直至满足上述条件，最后再用一个64为二进制字符串表示明文长度，这样填充之后长度为(n + 1)*512 12345678910111213141516// 填充字符串vector&lt;unsigned int&gt; padding(string src) { // 以512位,64个字节为一组 unsigned int num = ((src.length() + 8) / 64) + 1; vector&lt;unsigned int&gt; rec(num*16); strlength = num*16; for(unsigned int i = 0; i &lt; src.length(); i++){ // 一个unsigned int对应4个字节，保存4个字符信息 rec[i&gt;&gt;2] |= (int)(src[i]) &lt;&lt; ((i % 4) * 8); } // 补充1000...000 rec[src.length() &gt;&gt; 2] |= (0x80 &lt;&lt; ((src.length() % 4)*8)); // 填充原文长度 rec[rec.size()-2] = (src.length() &lt;&lt; 3); return rec;} 字符串分块函数，将上述填充之后的字符串分割为L个512字节长度的字符串 循环压缩函数：对每个512-bit分组进行64轮迭代运算 对分组（A, B, C, D）中的A进行迭代运算 公式为：A &lt;= B + ((A + f(B,C,D) + X[k] + T[i])) &lt;&lt; S[i] 其中： A,B,C,D代表MD5缓冲区当前的数值 f为轮函数，1-16轮迭代使用F函数，17-32轮迭代使用G函数，33-48轮迭 代使用H函数，49-64轮迭代使用I函数 1234567891011121314151617181920// F函数unsigned int F(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; c) | ((~b) &amp; d);}// G函数unsigned int G(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; d) | (c &amp; (~d));}// H函数unsigned int H(unsigned int b, unsigned int c, unsigned int d) { return b ^ c ^ d;}// I函数unsigned int I(unsigned int b, unsigned int c, unsigned int d) { return c ^ (b | (~d));}// 移位操作函数unsigned int shift(unsigned int a, unsigned int n) { return (a &lt;&lt; n) | (a &gt;&gt; (32 - n));} X[k]代表当前处理消息分组的第k个32位字，X[k]由第n轮迭代对应的顺序表决定 T[i]代表T表的第i项的值，T[i] = int(2^32 * |sin(i)|) S[i]对应第i轮的左循环移位的s值 对分组（A,B,C,D）作循环轮换 公式为：（B,C,D,A）&lt;=（A,B,C,D） 按照1， 2步骤进行四轮循环压缩 12345678910111213141516171819202122232425262728293031323334353637383940 // 循环压缩void iterateFunc(unsigned int* X, int size = 16) { unsigned int a = tempA, b = tempB, c = tempC, d = tempD, rec = 0, g, k; for(int i = 0; i &lt; 64; i++) { if(i &lt; 16) { // F迭代 g = F(b, c, d); k = i; } else if(i &lt; 32) { // G迭代 g = G(b, c, d); k = (1 + 5*i) % 16; } else if(i &lt; 48) { // H迭代 g = H(b, c, d); k = (5 + 3*i) % 16; } else { // I迭代 g = I(b, c, d); k = (7*i) % 16; } rec = d; d = c; c = b; b = b + shift(a + g + X[k] + T[i], s[i]); a = rec; } tempA += a; tempB += b; tempC += c; tempD += d;} MD5编码主函数：用于调用前面的功能函数对明文字符串进行MD5编码 输入待加密的明文字符串 对明文字符串进行填充 对填充后的明文字符串进行分块（$Y_q$） 使用预设的初始值初始化MD5缓冲区间（IV） 对各个分块字符串利用公式HMD5($CV_(i-1), Y_i$)进行循环压缩，运算结果作为下一块的输入（$CV_i$） 当所有的分块迭代完成后，输出结果$CV_L$，L表示最后一个分块的序号 123456789101112// MD5加密函数 string encode(string src) { vector&lt;unsigned int&gt; rec = padding(src); for(unsigned int i = 0; i &lt; strlength/16; i++) { unsigned int num[16]; for(int j = 0; j &lt; 16; j++) { num[j] = rec[i*16+j]; } iterateFunc(num, 16); } return format(tempA) + format(tempB) + format(tempC) + format(tempD); } 程序流程图 测试结果对测试数据进行测试，测试结果如下： 雪崩测试对每个测试数据均在字符串末尾加上一个空格得到密文改变位数如下 数据i 1 2 3 4 5 6 7 平均改变位数 改变位数 31 28 29 30 30 29 28 29 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183//MD5.h#pragma once#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;using namespace std;#define A 0x67452301#define B 0xefcdab89#define C 0x98badcfe#define D 0x10325476const char str16[] = \"0123456789abcdef\";const unsigned int T[] = { 0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee, 0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501, 0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be, 0x6b901122,0xfd987193,0xa679438e,0x49b40821, 0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa, 0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8, 0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed, 0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a, 0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c, 0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70, 0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05, 0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665, 0xf4292244,0x432aff97,0xab9423a7,0xfc93a039, 0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1, 0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1, 0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391 };const unsigned int s[] = { 7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22, 5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20, 4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23, 6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21};// 第一部分是要进行 HASH 运算的原始明文，第二部分则是其对应的 HASH 值static const struct data{ string msg; unsigned char hash[16];}tests[] = { { \"\", { 0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04, 0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e } }, { \"a\", {0x0c, 0xc1, 0x75, 0xb9, 0xc0, 0xf1, 0xb6, 0xa8, 0x31, 0xc3, 0x99, 0xe2, 0x69, 0x77, 0x26, 0x61 } }, { \"abc\", { 0x90, 0x01, 0x50, 0x98, 0x3c, 0xd2, 0x4f, 0xb0, 0xd6, 0x96, 0x3f, 0x7d, 0x28, 0xe1, 0x7f, 0x72 } }, { \"message digest\", { 0xf9, 0x6b, 0x69, 0x7d, 0x7c, 0xb7, 0x93, 0x8d, 0x52, 0x5a, 0x2f, 0x31, 0xaa, 0xf1, 0x61, 0xd0 } }, { \"abcdefghijklmnopqrstuvwxyz\", { 0xc3, 0xfc, 0xd3, 0xd7, 0x61, 0x92, 0xe4, 0x00, 0x7d, 0xfb, 0x49, 0x6c, 0xca, 0x67, 0xe1, 0x3b } }, { \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", { 0xd1, 0x74, 0xab, 0x98, 0xd2, 0x77, 0xd9, 0xf5, 0xa5, 0x61, 0x1c, 0x2c, 0x9f, 0x41, 0x9d, 0x9f } }, { \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", { 0x57, 0xed, 0xf4, 0xa2, 0x2b, 0xe3, 0xc9, 0x55, 0xac, 0x49, 0xda, 0x2e, 0x21, 0x07, 0xb6, 0x7a } },};class MD5 {private: unsigned int tempA, tempB, tempC, tempD, strlength;public: MD5() { tempA = A; tempB = B; tempC = C; tempD = D; strlength = 0; } // 填充字符串 vector&lt;unsigned int&gt; padding(string src) { // 以512位,64个字节为一组 unsigned int num = ((src.length() + 8) / 64) + 1; vector&lt;unsigned int&gt; rec(num*16); strlength = num*16; for(unsigned int i = 0; i &lt; src.length(); i++){ // 一个unsigned int对应4个字节，保存4个字符信息 rec[i&gt;&gt;2] |= (int)(src[i]) &lt;&lt; ((i % 4) * 8); } // 补充1000...000 rec[src.length() &gt;&gt; 2] |= (0x80 &lt;&lt; ((src.length() % 4)*8)); // 填充原文长度 rec[rec.size()-2] = (src.length() &lt;&lt; 3); return rec; } // F函数 unsigned int F(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; c) | ((~b) &amp; d); } // G函数 unsigned int G(unsigned int b, unsigned int c, unsigned int d) { return (b &amp; d) | (c &amp; (~d)); } // H函数 unsigned int H(unsigned int b, unsigned int c, unsigned int d) { return b ^ c ^ d; } // I函数 unsigned int I(unsigned int b, unsigned int c, unsigned int d) { return c ^ (b | (~d)); } // 移位操作函数 unsigned int shift(unsigned int a, unsigned int n) { return (a &lt;&lt; n) | (a &gt;&gt; (32 - n)); } // 循环压缩 void iterateFunc(unsigned int* X, int size = 16) { unsigned int a = tempA, b = tempB, c = tempC, d = tempD, rec = 0, g, k; for(int i = 0; i &lt; 64; i++) { if(i &lt; 16) { // F迭代 g = F(b, c, d); k = i; } else if(i &lt; 32) { // G迭代 g = G(b, c, d); k = (1 + 5*i) % 16; } else if(i &lt; 48) { // H迭代 g = H(b, c, d); k = (5 + 3*i) % 16; } else { // I迭代 g = I(b, c, d); k = (7*i) % 16; } rec = d; d = c; c = b; b = b + shift(a + g + X[k] + T[i], s[i]); a = rec; } tempA += a; tempB += b; tempC += c; tempD += d; } // 整理输出 string format(unsigned int num) { string res = \"\"; unsigned int base = 1 &lt;&lt; 8; for(int i = 0; i &lt; 4; i++) { string tmp = \"\"; unsigned int b = (num &gt;&gt; (i * 8)) % base &amp; 0xff; for(int j = 0; j &lt; 2; j++) { tmp = str16[b%16] + tmp; b /= 16; } res += tmp; } return res; } // 编码函数 string encode(string src) { vector&lt;unsigned int&gt; rec = padding(src); for(unsigned int i = 0; i &lt; strlength/16; i++) { unsigned int num[16]; for(int j = 0; j &lt; 16; j++) { num[j] = rec[i*16+j]; } iterateFunc(num, 16); } return format(tempA) + format(tempB) + format(tempC) + format(tempD); }}; 123456789101112131415161718\\\\MD5.cpp#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include \"MD5.h\"using namespace std;int main() { MD5 test; string a = \"\"; cout &lt;&lt; \"Plain Text: \"; getline(cin,a); cout &lt;&lt; \"result: \" &lt;&lt; test.encode(a) &lt;&lt; endl; return 0;}","tags":[{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"},{"name":"密码学","slug":"密码学","permalink":"https://kpl0111.github.io/blog/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"MD5","slug":"MD5","permalink":"https://kpl0111.github.io/blog/tags/MD5/"}]},{"title":"关于Eclipse安卓开发中的文件调用","date":"2022-05-17T18:35:09.000Z","path":"2022/05442e8a7e.html","text":"问题描述最近在用Eclipse做Android的时候使用jxl库简单处理了xls文件，由于我对xls文件处理不太熟练，于是创建了一个Java项目进行简单测试，没问题之后直接在安卓项目使用，但是却发现即使我把xls文件放在assets文件夹下并在Build Path里面勾选了assets文件夹依旧会抛出找不到文件的错误：FileNotFoundException，采用了 1file:///android_asset/xxx.html 和 1/assets/xxx.xls 均没有效果，依旧会抛出错误。 问题原因一般情况下我们在本地项目引用文件，直接用绝对路径或者相对路径都可以，这两者都可以在资源文件的属性里面查看，如下图所示： Android项目打包生成APK之后，会将项目打包成Jar包或者war包，此时就不会存在 assets/resources 目录，JVM会在编译项目时，主动将 java文件编译成 class文件 和 resources 下的静态文件放在 target/classes目录下； 也就是说我们在打包之后上述目录结构已经发生变化，此时再用原来的路径去索引文件，必然是索引不到的，那么我们还想去索引这个文件怎么办呢？ 解决方案我们可以用Java提供的方法获取文件流 1InputStream input = this.getClass().getResourceAsStream(\"/assets/xxx.xls\"); 从而去使用文件。 需要注意的是，路径的开头的 / 是不能少的，它代表的就是从src目录-根目录，而资源文件路径就是从src开始找，这样工程打包以后同样可以找到路径。 参考：Java项目读取resources资源文件路径那点事","tags":[{"name":"Android","slug":"Android","permalink":"https://kpl0111.github.io/blog/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://kpl0111.github.io/blog/tags/Java/"}]},{"title":"Hello kpl!","date":"2022-05-16T02:38:03.577Z","path":"2022/054a17b156.html","text":"","tags":[]},{"title":"Vim参数推荐","date":"2022-02-18T15:06:31.000Z","path":"2022/0257c5ab7b.html","text":"“ All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by“ the call to :runtime you can find below. If you wish to change any of those“ settings, you should do it in this file (/etc/vim/vimrc), since debian.vim“ will be overwritten everytime an upgrade of the vim packages is performed.“ It is recommended to make changes after sourcing debian.vim since it alters“ the value of the ‘compatible’ option. runtime! debian.vim “ Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.“ This happens after /etc/vim/vimrc(.local) are loaded, so it will override“ any settings in these files.“ If you don’t want that to happen, uncomment the below line to prevent“ defaults.vim from being loaded.“ let g:skip_defaults_vim = 1 “ Uncomment the next line to make Vim more Vi-compatible“ NOTE: debian.vim sets ‘nocompatible’. Setting ‘compatible’ changes numerous“ options, so any other options should be set AFTER setting ‘compatible’.“set compatible “ Vim5 and later versions support syntax highlighting. Uncommenting the next“ line enables syntax highlighting by default.syntax on “ If using a dark background within the editing area and syntax highlighting“ turn on this option as wellset background=dark “ Uncomment the following to have Vim jump to the last position when“ reopening a file“au BufReadPost * if line(“‘\"“) &gt; 1 &amp;&amp; line(“‘\"“) &lt;= line(“$”) | exe “normal! g’\"“ | endif “ Uncomment the following to have Vim load indentation rules and plugins“ according to the detected filetype.if has(“autocmd”) filetype plugin indent onendif “ The following are commented out as they cause vim to behave a lot“ differently from regular Vi. They are highly recommended though.“set showcmd “ Show (partial) command in status line.set showmatch “ Show matching brackets.set ignorecase “ Do case insensitive matchingset smartcase “ Do smart case matchingset incsearch “ Incremental search“set autowrite “ Automatically save before commands like :next and :makeset hidden “ Hide buffers when they are abandoned“set mouse=a “ Enable mouse usage (all modes) “ Source a global configuration file if availableif filereadable(“/etc/vim/vimrc.local”) source /etc/vim/vimrc.localendif setlocal noswapfileset bufhidden = hide“colorscheme eveningset numberset cursorlineset rulerset shiftwidth = 4set softtabstop = 4set tabstop = 4set nobackupset autochdirset backupcopy = yesset hlsearchset noerrorbellsset novisualbellset t_vb=set matchtime=2set magicset smartindentset backspace=ident,eol,startset cmdheight=1set laststatus=2set statusline=\\ %&lt;%F[%1*%M%*%n%R%H]%=\\ %y\\ %0(%{&amp;fileformat}\\ %{&amp;encoding}\\ Ln\\ %l.\\Col\\ %c/%L%)set foldenableset foldmethod=syntaxset foldcolumn=0setlocal foldlevel=1nnoremap @=((foldclosed(line(‘,’)) &lt; 0) ? ‘zc’ : ‘zo’)","tags":[{"name":"Vim","slug":"Vim","permalink":"https://kpl0111.github.io/blog/tags/Vim/"}]},{"title":"物联网安全复习总结","date":"2022-01-04T04:29:58.000Z","path":"2022/018a8f3fb6.html","text":"复习时随手记录，并不完整 物联网安全根据国际电信联盟的定义, 物联网( internet of things, IOT) 主要解决: 物品到物品( thing to thing,T2T) 人到物品( human to thing, H2T) 人到人( human to human, H2H)之间的互联 第1章 物联网安全需求分析与其他传统网络相比, 物联网感知节点大都部署在无人监控的场景中, 具有能力脆弱、资源受限等特点,这些都导致很难直接将传统计算机网络的安全算法和协议应用于物联网 从物联网的功能上来说，应该具备四个特征： 一是全面感知能力，可以利用RFID、传感器、二维条形码等获取被控/被测物体的信息; 二是数据信息的可靠传递，可以通过各种电信网络与互联网的融合，将物体的信息实时准确地传递出去; 三是可以智能处理，利用现代控制技术提供的智能计算方法，对大量数据和信息进行分析和处理，对物体实施智能化的控制。 四是可以根据各个行业、各种业务的具体特点形成各种单独的业务应用，或者整个行业及系统的建成应用解决方案 物联网结构和层次： 感知识别层：重点考虑数据隐私的保护； 传感器，RFID，二维条形码… 网络构建层：重点考虑网络传输安全； 互联网 无线宽带网 无线低速网 移动通信网 管理服务层：重点考虑信息安全； 管理服务层位于感知识别和网络构建层之上，综合应用层之下，人们通常把物联网应用冠以“智能”的名称，如智能电网、智能交通、智能物流等，其中的智慧就来自这一层 数据库：海量性，多态性，关联性，语义性 海量信息存储：网络附加存储（NAS ，Network Attached Storage）和专用存储区域网络（SAN ,Storage Area Network） 数据中心 搜索引擎 数据挖掘技术 综合应用层：重点考虑应用系统安全； 智能物流 智能交通 绿色建筑 智能电网 环境监测 与互联网相比, 物联网主要实现人与物、物与物之间的通信, 通信的对象扩大到了物品。 感知层的安全需求可以总结为如下几点： 机密性：多数网络内部不需要认证和密钥管理，如统一部署的共享一个密钥的传感网。 密钥协商：部分内部节点进行数据传输前需要预先协商会话密钥。 节点认证：个别网络（特别当数据共享时）需要节点认证，确保非法节点不能接入。 信誉评估：一些重要网络需要对可能被敌手控制的节点行为进行评估，以降低敌手入侵后的危害（某种程度上相当于入侵检测）。 安全路由：几乎所有网络内部都需要不同的安全路由技术。 物联网网络构建层将会主要遇到下列安全挑战： 拒绝服务攻击（DOS）攻击、分布式拒绝服务攻击（DDOS）攻击； 假冒攻击、中间人攻击等； 跨异构网络的网络攻击。 网络构建层的安全机制可分为端到端机密性和节点到节点机密性。 对于端到端机密性，需要建立如下安全机制： 端到端认证机制、 端到端密钥协商机制、 密钥管理机制 机密性算法选取机制等。 管理服务层的安全挑战包括如下几个方面： 来自于超大量终端的海量数据的识别和处理； 智能变为低能； 自动变为失控（可控性是信息安全的重要指标之一）； 灾难控制和恢复； 非法人为干预（内部攻击）； 设备（特别是移动设备）的丢失 为了满足物联网智能管理服务层的基本安全需求，需要如下的安全机制。 可靠的认证机制和密钥管理方案； 高强度数据机密性和完整性服务； 可靠的密钥管理机制，包括PKI和对称密钥的有机结合机制； 可靠的高智能处理手段； 入侵检测和病毒检测； 恶意指令分析和预防，访问控制及灾难恢复机制； 保密日志跟踪和行为分析，恶意行为模型的建立； 密文查询、秘密数据挖掘、安全多方计算、安全云计算技术等； 移动设备文件（包括秘密文件）的可备份和恢复； 移动设备识别、定位和追踪机制 应用层的安全挑战和安全需求主要来自于： 如何根据不同访问权限对同一数据库内容进行筛选； 如何提供用户隐私信息保护，同时又能正确认证； 如何解决信息泄露追踪问题； 如何进行计算机取证； 如何销毁计算机数据； 如何保护电子产品和软件的知识产权。 基于物联网综合应用层的安全挑战和安全需求，需要如下的安全机制： 有效的数据库访问控制和内容筛选机制； 不同场景的隐私信息保护技术； 叛逆追踪和其他信息泄露追踪机制； 有效的计算机取证技术； 安全的计算机数据销毁技术； 安全的电子产品和软件的知识产权保护技术 第2章 物联网安全技术框架现代经常涉及的信息安全技术主要有数据加密、身份认证、访问控制和口令、数字证书、电子签证机关（CA）、数字签名等常用信息安全技术 安全技术简介 数据加密 身份验证 访问控制 自由访问控制：用户有权对自身所创建的访问对象进行访问 强制访问控制，按照系统规则对用户所创建对象进行控制，即便是创建者，也可能无权访问对象 口令（密码）：实际上，弱口令。缺省口令和没有口令的账号均应该从数据库中删除 网络数据流窃听口令，如果明文传输，则可能被窃取 认证消息截取/重放，用加密口令实现系统登录 字典攻击 穷举攻击，字典攻击的加强版，使用字符串的全集作为字典 窥探，窥探合法用户输入口令过程 社交工程 垃圾搜索 数字证书：一个数字文件，一般由四部分构成 持有人的姓名，地址等信息 公开密钥 证书序号，有效期限 发证单位的数字签名 数字签名 本身是一种解密过程，而且是非对称密钥，类似于与校验和 使用用途，区别身份，鉴权，保证完整性，不可抵赖（即承认发送来源） 数据加密 分类 私用密钥（对称密钥） 信息的发送方和接收方使用同一个密钥进行加密和解密 适合对大数据量进行加密，密钥管理困难 公共密钥（非对称密钥） 信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，但加密和解密速度却比对称密钥加密慢得多 能够完成发送方的身份认证和接收方无法伪造报文的功能 通过公钥推算出私钥的算法必须不可能实现 物联网中的加密机制传统的IP网络加密：需要在感知层运行加密/解密算法，需要存储开销，CPU开销，而且需要能量 节点认证机制：PKI（Public Key Infrastructure ）即“公钥基础设施”，是一种遵循既定标准的密钥管理平台,它能够为所有网络应用提供加密和数字签名等密码服务及所必需的密钥和证书管理体系。简单来说，PKI就是利用公钥理论和技术建立的提供安全服务的基础设施 访问控制，由给人授权访问转变为给机器授权访问 态势分析及其他：评估现在以及未来一段时间内的网络运行状态 实现统一的密钥管理系统可以采用两种方式: 一是以互联网为中心的集中式管理方式 二是以各自网络为中心的分布式管理方式 其安全需求体现在 密钥生成或更新算法的安全性 前向私密性 后向私密性或可扩展性 抗同谋攻击 源端认证和新鲜性 第3章 密码与身份认证技术密码学基本概念密码学是主要研究通信安全和保密的学科，他包括两个分支：密码编码学和密码分析学 密码编码学主要研究对信息进行变换，以保护信息在传递过程中不被敌方窃取、解读和利用的方法 密码分析学则于密码编码学相反，它主要研究如何分析和破译密码 使用密码学可以达到以下目的： 保密性：防止用户的标识或数据被读取。 数据完整性：防止数据被更改。 身份验证：确保数据发自特定的一方 加密算法应在公开时不影响明文和密钥的安全 从密码学发展历程来看，可分为： 古典密码（以字符为基本加密单元的密码） 代替密码 单表替换密码 凯撒密码：某字母用右边第k个字母表示，Z后面是A 密钥短语密码 同音替换密码 多字母 组替换 密码 多表替换密码 置换密码 现代密码（以信息块为基本加密单元的密码） 分组密码 流密码 密钥加密系统 对称密码系统的安全性依赖于以下两个因素。 第一，加密算法必须是足够强的，仅仅基于密文本身去解密信息在实践上是不可能的； 第二，加密方法的安全性依赖于密钥的秘密性，而不是算法的秘密性，因此我们没有必要确保算法的秘密性，而需要保证密钥的秘密性 对称密码体制的特点是：对称加密算法使用起来简单快捷，密钥较短，且破译困难。 密钥难于安全传送。 密钥量太大，难于进行管理。 无法满足互不相识的人进行私人谈话时保密要求。 难于解决数字签名验证的问题。 相对于对称密钥密码体系，非对称密钥加密系统最大的特点在于加密和解密使用不同的密钥 非对称密钥技术的优点是：易于实现，使用灵活，密钥较少，可以满足互不相识的人之间进行私人谈话时的保密性要求，可以完成数字签名和数字鉴别。 弱点在于：要取得较好的加密效果和强度，必须使用较长的密钥。 现代加密算法对称加密算法在对称加密算法中，只有一个密钥用来加密和解密信息，即加密和解密采用相同的密钥。常用的算法包括： DES（Data Encryption Standard）： 数据加密标准，速度较快，适用于加密大量数据的场合。 3DES（Triple DES）： 是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。 AES（Advanced Encryption Standard）： AES高级加密标准，是下一代的加密算法标准，速度快，安全级别高 非对称加密算法 RSA：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的； RSA是第一个既能用于数据加密也能用于数字签名的算法 DSA（Digital Signature Algorithm）： 数字签名算法，是一种标准的 DSS（数字签名标准）； 除了加密外，公开密钥密码学最显著的成就是实现了数字签名。 加密算法的选择 我们应该根据自己的使用特点来确定： 由于非对称加密算法的运行速度比对称加密算法的速度慢很多，当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。 对称加密算法不能实现签名，因此签名只能非对称算法。 由于对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。 在实际的操作过程中，我们通常采用的方式是： 采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。 认证与身份证明身份证明系统的组成 示证者P(Prover)，出示证件的人，又称作申请者(Claimant)，提出某种要求； 验证者V(Verifier)，检验示证者提出的证件的正确性和合法性，决定是否满足其要求； 攻击者，可以窃听和伪装示证者骗取验证者的信任。 可信赖者，参与调解纠纷。必要时的第四方 物联网认证与访问控制目前常用的身份识别技术可以分为两大类 一类是基于密码技术的各种电子ID身份鉴别技术； 另一类是基于生物特征识别的识别技术 基于零知识证明的识别技术 零知识洞穴 第4章 RFID系统安全与隐私RFID系统一般由3大部分构成： 标签 标签放置在要识别的物体上，携带目标识别数据，是RFID系统真正的数据载体，由耦合元件以及微电子芯片(包含调制器、编码发生器、时钟及存储器)组成 读写器 用于读或读/写标签数据的装置，由射频模块(发送器和接收器)、控制单元、与标签连接的藕合单元组成 后台数据库 后台服务器包含数据库处理系统，存储和管理标签相关信息，如标签标识、阅读器定位、读取时间等 工作原理 RFID系统的基本工作原理是：阅读器与标签之间通过无线信号建立双方通信的通道，阅读器通过天线发出电磁信号，电磁信号携带了阅读器向标签的查询指令。 当标签处于阅读器工作范围时，标签将从电磁信号中获得指令数据和能量，并根据指令将标签标识和数据以电磁信号的形式发送给阅读器，或根据阅读器的指令改写存储在RFID标签中的数据 阅读器可接收RFID标签发送的数据或向标签发送数据，并能通过标准接口与后台服务器通信网络进行对接，实现数据的通信传输。 根据标签能量获取方式，RFID系统工作方式可分为：近距离的电感耦合方式和远距离的电磁耦合方式 RFID的安全和攻击模式 安全 信息及隐私泄露 RFID的隐私威胁 隐私信息泄露 跟踪 效率和隐私保护的矛盾 攻击模式 窃听 中间人攻击 欺骗、重放、克隆 欺骗(spoofing)：基于已掌握的标签数据通过阅读器 重放(replaying)：将标签的回复记录并回放 克隆(cloning)：形成原来标签的一个副本 拒绝服务攻击(Denial-of-service attack, DoS)拒绝服务攻击是通过不完整的交互请求消耗系统资源，使系统不能正常工作 物理破解(corrupt)物理破解采用如下一些步骤对RFID射频系统进行破坏 篡改信息(modification)进行非授权的修改或擦除标签数据，从而达到篡改信息的目的。 RFID病毒(virus, malware)包括EPC标签在内的RFID标签可以被用来携带病毒，并能攻击电脑系统。 其他隐患：RFID的安全和隐私问题涉及到的其他隐患还包括：电子破坏、屏蔽干扰和拆除等。 RFID系统根据分层模型可划分为3层：应用层、通信层和物理层，ISO／IEC 18000标准定义了读写器与标签之间的双向通信协议，其基本的通信模型如下图。 安全RFID系统的基本特征 机密性 完整性 可用性 真实性 隐私性 第5章 WSN无线传感器网络安全无线传感器网络与安全相关的特点 资源受限，通信环境恶劣。 部署区域的安全无法保证，节点易失效。 网络无基础框架。 部署前地理位置具有不确定性。","tags":[{"name":"物联网安全","slug":"物联网安全","permalink":"https://kpl0111.github.io/blog/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"},{"name":"复习","slug":"复习","permalink":"https://kpl0111.github.io/blog/tags/%E5%A4%8D%E4%B9%A0/"}]},{"title":"编译系统原理复习提纲","date":"2022-01-01T07:31:41.000Z","path":"2022/0178868943.html","text":"编译系统原理[toc] 内容过多，未完全整理 题型设计 单项选择（12*2） 编译阶段所做事情考察 编译器和解释器的区分 ϵ是空符号串 正则表达式本质上表述的是符号串集合 NFA，DFA和CFG 设计题（6*4） 正则表达式表示的含义 设计正则表达式 设计上下文无关文法 解答题 Thompson构造法 子集构造法 终结符，非终结符，开始符号 消除左递归 构造预测分析表 流图 三地址码 优化 真题C++编译器检查数组下标越界是在_____阶段?ϵ为空符号串 概述广义的编译器：浏览器 分析-综合模型两个基本部分 分析：将源程序分解为基本组成部分，生成中间表示形式 中间表示形式：树 节点-操作 孩子-参数 综合：从中间表示形式构建目标程序 源程序分析的三个阶段 线性分析/词法分析/扫描 由左至右扫描源程序字符序列➔token，单词（记号）——具有组合意义的字符序列 忽略空格、回车等，将字符组合为单词 层次分析/语法分析 单词序列➔有意义的集合，语法单位 将词法分析产生的单词组合为语法短语 语法分析树：内部节点-运算符，叶节点-运算对象 语义分析 检查程序各部分是否正确符合语义 语法结构的递归定义 表达式 标识符是表达式 数是表达式 若expression1和expression2是表达式，则expression1 + expression2 、expression1 * expression2、( expression1 )也是表达式 1、2——基本规则，3——递归定义 文法（grammar） 语句（statement）定义 若identifier1是一个标识符，expression2是一个表达式，则identifier1 := expression2是一个语句 若expression1是一个表达式，statement2是一个语句，则while ( expression1 ) do statement2和if ( expression1 ) then statement2也是语句 文法：处理token相互关系和结构的一组规则 程序优化技术现状 CPU上的过程内优化基本成熟 过程间优化能力仍然受限 面向GPU等新型体系结构的编译优化还有空间 一个简单的编译器字符流 → 词法分析器 → 单词流 → 语法制导翻译器 → 中间表示形式 语法制导翻译器：语法分析 + 中间代码生成 语法定义上下文无关文法：描述语言的语法结构 组成： 一组终结符号，单词，基本符号 一组非终结符号（语法变量），语法范畴，语法概念 一组产生式，定义语法范畴 产生式：A→α A—一个非终结符，左部 α—终结符或/与非终结符串，右部 一个特定的非终结符——开始符号，start symbol 几个概念 Σ：有穷字母表，元素——符号 符号串：Σ中符号构成的有穷序列 空字：不含任何符号的序列，ε Σ*：符号串全体，包括空字 φ：空集{}，区分ε，{}，{ε} Σ*的子集U、V的积（连接）{ αβ|α ∈ U 且 β ∈ V} UV≠VU，(UV)W=U(VW) V自身的n次积（连接）记为$V^{n}$ $V^{0}={ε}$ V的闭包（closure） $V* = V^{0} ⋃ V^{1} ⋃ V^{2} ⋃ V^{3} ⋃ …$ 每个符号串，都是V中符号串有限次连接 正则闭包，$V^{+}=VV*$ 四元式定义上下文无关文法 $(V_{T}, V_{N}, S, P)$ $V_{T}$：非空有限集，终结符号集合 $V_{N}$：非空有限集，非终结符号集合 S：开始符号 P：产生式集合（有限集） 每个产生式形式A→α，其中 $A ∈ V_{N},α ∈(V_{T} ⋃ V_{N})*$ 关于A的产生式S至少在某个产生式左部出现一次 符号约定 expr → expr + digit expr → expr – digit expr → digit digit → 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 数字、运算符、黑体字符串——终结符 斜体字符串——非终结符 左部相同可合并，‘|’——“或”的意思expr → expr + digit | expr - digit | digit候选式 推导 单词串(string)：0个或多个单词构成的序列 推导(derive) 由开始符号作为推导起点 用产生式右部替换左部非终结符 反复替换，最终得到单词串 语言(language) 语法所定义的语言——可由开始符号推导出的所有单词串的集合 二义性：多个语法分析树生成相同的单词串——多个意义 语法制导翻译 翻译：为生成代码，需保存语言结构的类型、代码位置、代码数量等 属性(attribute)：类型、串、内存位置等 语法制导翻译syntax-directed translation 语法制导定义syntax-directed definition 属性与语法结构相关联➔指明翻译方法 翻译模式，translation scheme 表达式E的后缀形式Postfix(E)如何生成： E为变量或常量：Postfix(E) = E $E = E_{1} op E_{2}$，op—二元运算符，$E_{1}、E_{2}$—子表达式： $Postfix(E) = Postfix(E_{1} op E_{2})= Postfix(E_{1}) Postfix(E_{2}) op$ $E = (E_{1})$： $Postfix(E) = Postfix(E_{1})$ (9 - 5) + 2 ➔9 5 - 2 + 9 - (5 + 2) ➔9 5 2 + - 语法制导定义 基于语言的上下文无关文法 语法符号——一组属性 产生式——一组语义规则(semantic rule)——属性值计算规则 CFG+语义规则➔语法制导定义 语法制导翻译的基本过程（翻译——输入→输出映射过程） 输入单词串x➔语法分析树 节点n标记为X，X.a——X的属性 计算节点n的X.a的值——利用X产生式的语义规则➔ “注释语法分析树”（annotated parse tree） 语法制导定义的实现 树的遍历：计算完所有孩子节点的属性，父节点才能计算自身属性 后序遍历，深度优先 翻译模式 translation scheme 同样基于上下文无关文法 语义动作（semantic action，程序片断）嵌入产生式的右部 语法分析树添加额外节点 指明了语义动作执行顺序 语法分析 确定一个单词串是否可由一个文法生成 构造语法分析树 时间复杂度$O(n^3)➔O(n)$ 自顶向下分析方法，top-down语法树构造——由根向叶适合手工编写语法分析器 自底向上分析方法，bottom-up语法树构造——由叶向根适用更多文法，自动生成工具 自顶向下分析方法 从根节点（标记为开始符号）开始构造语法树，不断重复以下步骤 对标记为NT A的节点n,选择一个关于A的产生式,利用产生式右部构造n的孩子节点 选择下一个没有扩展（构造孩子节点）的节点，对它执行1 平凡算法 初始状态，只有一个根节点，标记为开始符号，输入指针指向第一个单词 对于NT节点 a) 选择产生式（尝试、回溯）构造孩子节点 b) 对孩子节点从左至右继续分析 对于T节点 a) 与当前输入单词进行比较 b) 若匹配，输入指针前移，处理下一个节点 c) 不匹配，可能需要回溯或报告错误","tags":[{"name":"Lex","slug":"Lex","permalink":"https://kpl0111.github.io/blog/tags/Lex/"},{"name":"Yacc","slug":"Yacc","permalink":"https://kpl0111.github.io/blog/tags/Yacc/"},{"name":"编译系统原理","slug":"编译系统原理","permalink":"https://kpl0111.github.io/blog/tags/%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"编译器","slug":"编译器","permalink":"https://kpl0111.github.io/blog/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"计算机网络复习摘要","date":"2021-12-30T20:53:41.000Z","path":"2021/1210d148d4.html","text":"概述IPV4：32位地址IPv6：128位地址 Internet三个重要理念：➢ 互联网的开放理念➢ 互联网的自组织理念➢ 互联网的分享理念 统计多路复用：主机A和B的报文分组没有固定的到达模式，带宽按需共享，这种方式称为统计多路复用(statistical multiplexing) 网络流量具有很强的突发性，即不平稳，每个独立的流的峰值可能出现在不同时间 结论：流越多，网络平均流量越平滑 报文长度P ：单位“位(bit)”链路长度L ：单位“米”传输速率R ：单位“位/秒”传播时延PROP：电磁波在介质上传播的时间，单位“秒” PROP = L/C，其中C为电磁波传播速度 传输时间TRANSP ：发送长度为P的报文所用的时间 TRANSP = P/R，其中R为传输速率 端端时延Latency：发送端开始传送第一位到接收端接收到最后一位所用的时间，在单一链路上计算方法为： Latency = PROP + TRANSP 当报文分组到达时，如果出口链路忙，报文分组需要在路由器缓存中排队等待，会引入排队时延 往返时延RTT (Round-Trip Time)：从发送方发送数据开始，到发送方收到来自接收方的确认，经历的总时间 时延带宽积 时延带宽积= 传播时延×带宽，即按比特计数的链路长度 若发送端连续发送数据，则在发送的第一个bit即将达到终点时，发送端就已经发送了时延带宽积个bit ，而这些bit都在链路上向前移动 如何将端系统连接到边缘路由器？ 有线接入 数字用户线路(xDSL),电话线 混合光纤同轴电缆(HFC)，电视 光纤宽带(FTTH)，光纤 以太网(Ethernet) 无线接入 无线局域网(WiFi) 移动通信网(4G/5G) 注意两个指标：接入网速率、共享或专用 网络协议的组成要素： 语法：数据与控制信息的结构或格式(协议数据单元PDU) 语义：需要发出何种控制信息，完成何种动作以及做出何种响应 时序：事件实现顺序的详细说明 接口层通常包括数据链路层和物理层 应用层协议及网络编程应用协议与进程通信模型应用：可进行通信的、分布式进程➢ 运行于主机的用户空间➢ 通过交换消息(Messages)实现应用之间的交互➢ 例如：Email、Web等 应用层协议：应用层实体之间的通信规范➢ 定义应用交换的消息和收到消息后采取的行动➢ 使用下层协议(TCP、UDP)提供的通信服务 内容： 消息的类型 如请求request、响应response 消息的语法 如消息包含哪些字段、字段之间如何分割等 消息的语义 字段中信息代表的具体含义 消息的处理 进程何时发送消息、收到消息后的动作等 类型： 公共协议 RFC中定义的协议 可相互兼容 例如：HTTP、SMTP等 专有协议 公司或组织专有 例如：Skype、QQ等 服务指标 数据丢失率 音视频等应用可以容忍一定的数据丢失 文件传输、远程登录等应用要求100%的数据可靠 时延 网络电话、交互游戏等应用对时延有一定的要求 带宽 多媒体等应用需要一定的带宽保证 有些应用则是弹性的 主机的地址标识:主机拥有一个唯一的32位的IPv4地址(或128位的IPv6地址)进程标识符：包括IP地址和端口号 端口号举例: Web服务器进程: 80 Email(SMTP)服务器进程: 25 进程间通信进程：主机中运行的程序 在同一台主机中，两个进程之间按照进程间通信方式进行交互通信(操作系统中定义)不同主机上的进程通信，需要通过交换信息来完成 客户/服务器(C/S)模型 客户向服务器发出服务请求，并接收服务器的响应；服务器等待客户的请求并为客户提供服务 例如：Web浏览器/Web服务器；Email客户端/Email服务器 过程 服务器进程 被动等待 长久在线 固定IP地址 利用集群/云提供扩展性 客户进程 启动与服务器的通信 可能为间歇性连接 可能使用动态IP地址 不与其他客户进行直接通信 对等计算(P2P)模型 最小化(或根本不用)专用服务器 例如：Skype, BitTorrent等 过程 无长久在线的服务器 任意的终端系统之间都可能进行直接通信 端系统之间可能间歇性地进行连接 端系统可能使用动态的IP地址 高可扩展性但维护困难 传输层服务对应用层的支持TCP服务: 面向连接：客户与服务器之间需要建立连接 可靠传输：可保证传递数据无差错 流量控制：发送数据不会超过接收端的容纳容量 拥塞控制: 提供拥塞解决方案 不能提供：时延和带宽保证 UDP服务: 不可靠：不可靠的数据投递 不能提供：连接建立、可靠性、流量控制、拥塞控制、时延和带宽保证 一些常见Socket函数： accept():流方式 connect()：流方式 recv()：流方式 sendto()：数据报方式 recvfrom()：数据报方式 常见CPU的字节序 Big-Endian : PowerPC、IBM、Sun Little-Endian : x86、DEC ARM既可工作在Big-Endian，也可工作在Little-endian 网络使用的字节序：网络通信协议都使用Big-Endian编码序 电子邮件系统 用户代理 (接口) 编辑和发送邮件 接收、读取和管理邮件 管理地址簿 无统一标准 邮件服务器 邮箱：保存用户收到的消息 消息输出队列：消息的发送队列 SMTP协议：邮件服务器之间传递邮件使用的协议 smtp客户: 发送邮件端 smtp服务器: 接收邮件端 邮件地址：一对字符串，用于指定邮件接收者 local-part@domain-name domain-name: 域名 local-part: 域名中的邮箱名 SMTP: 向服务器传递邮件 邮件访问协议: 从邮件服务器的邮箱中获取邮件 POP: 邮局协议[RFC 1939] IMAP: Internet邮件访问协议[RFC 2060] HTTP: 超文本传输协议 邮件消息格式 信封 封装消息 内含传输邮件消息所需的一些信息 目的地址、优先级、安全级别等 消息 消息头 包含用户代理所需的一些控制信息 消息体 文件传输服务与协议 基于TCP/IP的文件传输系统 客户/服务器模型 client: 初始化传输(无论上传还是下载) server: 远端 客户使用TCP协议连接远端服务器 FTP进程模型– 双连接 控制连接 带外控制 TCP的21端口 客户和服务器之间维护的一个FTP会话 用于客户和服务器之间交换命令和响应 在整个会话期间保持活跃 数据传输连接 TCP的20端口 用于传输数据 客户可以在一个会话上向服务器传输多个请求 每个文件请求都会建立一个数据连接 数据传输结束后，释放数据连接 域名系统DNS(Domain Name System)互联网中使用IP地址寻址主机 DNS基本思想： 名字和地址映射关系分布式存放，形成具有层次结构的分布式数据库系统(分布式管理) 通过查询分布式数据库，获得名字到地址的映射，或相反 关键： 如何组织分布式数据库 如何在分布式数据库中查找 DNS服务器组织 顶级域名服务器(Top-Level Domain, TLD) 根服务器 负责顶级域名的解析 授权域名服务器 对于名字与地址映射，保留其初始数据来源的服务器 主要区分名字与地址映射是原始的还是被缓存的(非授权) 本地域名服务器(或称默认域名服务器) 一般每个ISP都部署有域名服务器，其用户可将该服务器设置成本地域名服务器(或默认域名服务器) 当进行域名解析时，查询请求首先发送到本地域名服务器(即查询的起点) 域名解析：名字到地址映射(通过名字查地址) 分布式：层级的服务器组织，协同实现解析 有效性：大多数解析可以在本地完成，一部分会产生互联网流量 可靠性：通过冗余设置，避免单点失效 解析方式 反复解析 递归解析 主机缓存 基本方法 在启动时从本地域名服务器下载名字-地址映射数据库 定期获取新的映射 缓存最近用过的名字和地址映射 优点 无需访问域名服务器，名字解析速度快 本地服务器的故障不影响名字解析 减低服务器的负载 缺点？ DNS包括query和reply两种报文 域名格式压缩？ 客户-服务器模式 域名服务器： 保存名字到地址映射关系(数据库) 接收客户端请求，并给出响应 域名解析器(客户端)： 请求域名解析的客户进程 向域名服务器发起解析请求，并等待服务器的响应 Web服务与HTTP协议 服务器 Web页面(HTML文档)：包含到多种对象的链接 对象：可以是 HTML文档、图像文件、视频文件、声音文件、脚本文件等 对象用URL(统一资源定位符)编址：协议类型://主机名//路径和文件名 客户端 发出请求、接收响应、解释HTML文档并显示 有些对象需要浏览器安装插件 HTTP(HyperText Transfer Protocol) 传输层通常使用TCP协议，缺省使用TCP的80端口 HTTP为无状态协议，服务器端不保留之前请求的状态信息 无状态协议：效率低、但简单 有状态协议：维护状态相对复杂，需要维护历史信息，在客户端或服务器出现故障时，需要保持状态的一致性等 HTTP标准 HTTP/1.0: RFC 1945(1996年) 每请求一个文件都要建立连接和断开 eg:请求一个index.html，里面包含3张jpg图片，先发送html文件，后重新建立三次连接发送图片 HTTP/1.1: RFC 2616(1999年) HTTP 1.1的问题 队头阻塞问题 基于文本协议的问答有序模式，先请求的必须先响应 传输效率问题 文本格式、冗长重复的头部等 HTTP 1.1队头阻塞的解决策略 浏览器建立多个TCP连接 一般最多可以建立6个TCP连接 通过不同TCP连接传送的请求没有响应顺序的要求 耗费较多的计算和存储资源 HTTP/2: RFC 7540(2015年)、RFC 8740(2020年) 二进制分帧传输 不改变HTTP原有的语义 将HTTP请求和响应分割成帧，采用二进制编码 帧为最小传输单位 最常用的HTTP 请求/ 响应的帧形式 TCP连接复用：提高连接利用率，解决HTTP的队头阻塞问题 消息(Message)：HTTP一次请求或响应，包含一个或多个帧 流(Stream)：简单看成一次请求和应答，包含多个帧 每个TCP连接中可以承载多个流，不同流的帧可以交替穿插传输 流的创建与标识 Stream ID：标识一个流。客户端创建的流，ID为奇数；服务器创建的流，ID为偶数；0x00和0x01用于特定场景；Stream ID 不能重复使用，如果一条连接上ID分配完，会新建一条连接。接收端通过Stream ID进行消息的组装。 流创建：发送和接收到HEADERS帧(包含新Stream ID)时创建 流优先级：可以依据重要性为流设置不同的优先级(1~256)，在HEADERS帧中承载 服务器推送：提高响应速度 服务器在请求之前先推送响应信息到客户端，推送的响应信息可以在客户端被缓存 HTTP头压缩(HPACK) 请求头由大量的键值组成，多个请求的键值重复程度很高 静态表：定义通用HTTP头域，常用键值无需重复传送，直接引用内部字典的整数索引 动态表：两边交互发现新的头域，添加到动态表 自定义键值：采用Huffman编码 http测试 HTTP 2.0协议解决的问题 通过引入流机制，解决了HTTP队头阻塞问题，提高了传输效率 通过二进制编码、头压缩机制提高了网络带宽利用率 通过服务器推送，加快了页面响应速度 HTTP 2.0协议没有解决的问题 TCP+TLS的多次交互，造成启动延迟问题 对移动主机和多宿主机的连接迁移问题 TCP队头阻塞问题 HTTP报文类型 HTTP两种报文：请求(request)、响应(response) HTTP请求报文：采用ASCII，数据部分采用MIME格式 HTTP响应报文：数据部分采用MIME格式 几个比较典型的状态码 200 OK 请求成功，被请求的对象包含在该响应的数据部分 301 Moved Permanently 请求的对象被移走，新的位置在响应中通过Location: 给出 400 Bad Request 服务器不能解释请求报文 404 Not Found 服务器中找不到请求的文档 505 HTTP Version Not Supported 服务器不支持相应的HTTP版本 用户-服务器交互：认证 认证：控制对服务器内容的访问 认证方法：通常使用“名字-口令” 无状态：客户端需要在每个请求中携带认证信息 每个请求头中包含authorization: 如果请求头中无authorization:，则服务器拒绝访问，并在响应头中包含WWW authenticate： 用户-服务器状态：Cookies 服务器使用cookies保持状态 HTTP响应头中使用set-cookie： 选择的cookie号具有唯一性 后继的HTTP请求中使用cookie： Cookie文件保存在用户的主机中，由用户主机中的浏览器管理 Web服务器建立后端数据库，记录用户信息 例如： Set-Cookie: SID=31d4d96e407aad42; Path=/; Domain=example.com Cookie: SID=31d4d96e407aad42 Web缓存机制：客户端缓存 目标：如果被请求的对象在客户端缓存有最近版本，则不需要发送该对象 客户端：在发送的HTTP请求中指定缓存的时间，请求头包含 If-modified-since: &lt; date &gt; 服务器：如果缓存的对象是最新的，在响应时无需包含该对象，响应头包含 HTTP/1.1 304 Not Modified Web缓存机制：代理服务器缓存 目标：由代理服务器进行缓存，尽量减少原始服务器参与 用户设置浏览器：通过代理服务器进行Web访问 浏览器将所有的HTTP请求发送到代理服务器 如果缓存中有被请求的对象，则直接返回对象 否则，代理服务器向原始服务器请求对象，再将对象返回给客户端 优点：降低时延，减少网络流量 HTTP发展现状 内容分发网络CDN(Content Distribution Network)基本思想源于MIT对Web服务瞬间拥塞问题的解决(1998) 一种Web缓存系统，靠近网络边缘(用户)提供内容服务 目前提供更丰富的服务，包括静态内容、流媒体、用户上传视频等 主要优点 降低响应时延，避免网络拥塞 避免原始服务器过载及防止DDoS攻击 分布式架构，具有良好的可扩展性 对用户透明，无需用户感知 DNS辅助 负载均衡DNS负责决策CDN服务器选择 负载均衡DNS需要收集CDN服务器的位置和负载情况 如果找不到被请求的对象，需要从原始服务器获取 动态自适应流媒体协议DASHDynamic Adaptive Streaming over HTTP)(重点)基本思想： 完整视频被拆分为固定时长(2s-10s)、不同码率的视频片段(segment) 视频片段与媒体表示描述(Media Presentation Description, MPD) 文件一同存放于DASH服务器 客户端根据自身设备性能、当前网络条件、客户端缓冲大小等自适应选择一种视频码率进行下载 例如：HTTP服务器中保存有高中低三种质量的视频片段，DASH客户端评估网络状况，通常在保证视频流畅的前提下，获取最高质量的视频片段 自适应码率(Adaptive bitrate，ABR)规则 传输层协议传输层需要解决的基本问题 网络层：将IP数据包从源主机传送到目的主机，提供无连接不可靠服务 数据包传输存在的问题：延迟、乱序、出错、丢失等 传输层解决的问题之一：可靠性，向应用层提供可靠服务 应用层运行多个应用进程 共享单一的网络层协议(IP)和网络接口 传输层解决的问题之二：复用(Multiplexing)和分用(Demultiplexing) TCP/IP体系结构中传输层协议与服务传输层协议的基本功能 复用和分用 可靠性保证 传输层实体执行的动作 发送端：将应用层的消息封装成传输层的数据单元，传递到网络层 接收端：将从网络层接收的传输层数据单元，处理后交给应用层 传输控制协议TCP(Transport Control Protocol) 为进程间通信提供面向连接的、可靠的传输服务 实现复用分用、差错检测、确认重传、流量控制等传输层功能 用户数据报协议UDP(User Datagram Protocol) 为进程间通信提供非连接的、不可靠的传输服务 实现复用分用、差错检测等传输层功能 用户数据报协议(UDP)UDP协议特点 发送方和接收方不需要握手过程 每个UDP数据单元(数据报)独立传输 提供复用分用功能和可选的差错检测功能 支持组播通信(点到多点通信) 不提供可靠性保证：无确认重传、可能有出错、丢失、乱序等现象 UDP数据报格式 长度：包含头部、以字节计数 校验和：为可选项，用于差错检测 进程标识：目的IP地址+目的端口号 UDP数据报的差错检测 可选项，利用数据报中携带冗余位(校验和域段)来检测数据报传输过程中出现的差错 发送端：利用自己产生的伪首部和发送的UDP数据报计算校验和 接收端：利用自己产生的伪首部和接收的UDP数据报计算校验和 伪首部：包含源IP地址、目的IP地址、协议类型等域段 UDP校验和计算几点说明 IPv4中UDP校验和是可选项，IPv6中变成强制项 0无，非0有(如果计算结果为0，则以全1代替) UDP校验和覆盖的范围超出了UDP数据报本身，使用伪首部的目的是检验UDP数据报是否到达真正的目的地 正确的目的地包括了特定的主机和该主机上特定的端口 伪首部不随用户数据报一起传输，接收方需自己形成伪首部进行校验 伪首部的使用破坏了层次划分的基本前提，即每一层的功能独立 目的主机的IP地址UDP通常知道，源IP的使用需要通过路由选择决定 1234567891011u_short cksum(u_short *buf, int count){ register u_long sum = 0; while (count--){ sum += *buf++; if (sum &amp; 0XFFFF0000){ sum &amp;= 0XFFFF; sum++; } } Return ~(sum &amp; 0XFFFF);} IP首部、ICMP、UDP、TCP都需要计算校验和，方法类似 使用UDP服务的应用： 流媒体应用(实时音频和视频)通常使用UDP服务 能够容忍一定的丢失 对时延敏感 其他使用UDP服务的应用，如： DNS SNMP 需要在UDP之上实现可靠传输，即在应用层增加可靠机制 为什么提供UDP服务？ 不需要建立连接，建立连接需要增加延时，特别对于简单的交互应用 协议简单：在发送端和接收端不需要维护连接状态 数据报头部短，额外开销小 无拥塞控制 可靠数据传输rdt：reliable data transfer protocol(可靠数据传输协议) 停等机制：发送端发送一个分组，然后等待接收端响应 两种典型的流水线协议： 回退N：Go-Back-N (GBN) 允许发送端发出N个未得到确认的分组 需要增加序列号范围 分组首部中增加k位的序列号，序列号空间为[0, $2^{k-1}$] 采用累积确认，只确认连续正确接收分组的最大序列号 可能接收到重复的ACK 发送端设置定时器，定时器超时时，重传所有未确认的分组 选择重传：Selective Repeat (SR) 接收端独立确认每个正确接收的分组，必要时缓存分组，对高层按序交付 每个分组独立定时，发送端只重传未收到ACK的分组 过程 发送端 接收上层数据：如果发送窗口中有可用的序号，则发送分组 超时(n)：重传分组n，重启定时器 接收ACK(n)：n在[send_base, send_base+N-1]区间，将分组n标记为已接收，如果是窗口中最小的未确认的分组，则窗口向前滑动，基序号为下一个未确认分组的序号 接收端：接收分组n： n在[rcv_base, rcv_base+N-1]区间，发送ACK(n)，缓存失序分组，按序到达的分组交付给上层，窗口向前滑动 n在[rcv_base-N, rcv_base-1]区间，发送ACK(n) 传输控制协议(TCP)TCP协议特点提供可靠服务：按序、可靠交付 提供字节流服务，不识别消息边界可靠传输机制 提供差错检测(校验和)功能，正确接收返回确认 使用序列号检测丢失和乱序 超时重传机制，解决出错、丢失问题 支持流水线机制，自适应窗口 面向连接：发送数据之前发送方和接收方之间需要握手 三次握手建立连接 初始化所需的参数及分配缓冲区 提供复用分用功能 只提供点对点通信 具有流量控制和拥塞控制功能 头长度：四个字节为计数单位，包含选项部分 接收窗口通告：指示接收缓冲区可接收的字节数 标志位：URG, ACK, PUSH, RESET, SYN, FIN 选项格式：Kind(1字节)|Length(1字节)|Info(n字节) TCP连接与复用、分用机制 通信之前通过三次握手建立TCP连接 分配缓冲区、协商参数(初始序号、接收缓冲区大小、最大段尺寸等) 连接标识(四元组)：源IP地址、目的IP地址、源端口号、目的端口号 通过建立的TCP连接为应用进程提供可靠的字节流服务 事件 TCP接收端动作 期望序号的报文段按序到达，之前的报文段均已被确认 延迟发送ACK，等待下一个报文段到达；等500毫秒，仍未收到下一个报文段，则发送ACK 期望序号的报文段按序到达，之前有一个延迟确认的报文段 发送ACK，确认两个按序到达的报文段 报文段未按序到达，到达的报文段序号高于期望的序号，数据流不连续 发送重复ACK，确认序号中包含期望接收的序号 到达的报文段填补了之前数据流不连续部分 发送ACK，确认序号中包含期望接收的序号 TCP采用自适应方法计算重传超时时间(原因？) 基于往返时间(RTT)确定重传超时间(RTO) 问题：如何准确估算 上一次RTT可以测得，下一次RTT需要估算 网络拥塞和路由变化，每次往返时间可能不同，有时会有较大变化 流量控制的目的：避免发送端发送数据过快，接收端不能及时处理，造成接收缓冲区溢出 增加流控功能后，发送窗口还需要受接收能力的约束 可变的滑动窗口：接收端利用“接收窗口通告”域段告知发送端接收端缓冲区剩余的空间，发送端依据该通告调整发送窗口的大小 接收窗口大小对性能的影响 较小的缓冲区会影响网络的吞吐率 过大的缓冲区会浪费主机的存储资源 连接的半打开状态：连接的一端存在、而另一端不存在 当一个进程终止连接未能通知到另一方时，例如：掉电、异常关闭等 TCP定时器: 连接建立定时器(75秒) 重传定时器(RTO) 延迟ACK定时器(500毫秒) 持续定时器(避免0窗口死锁) 保活定时器(避免半打开) 静默定时器(避免端口号重用等) 理解网络拥塞拥塞控制方法：两种广泛使用的拥塞控制方法 端到端拥塞控制 网络中无明确的反馈 端系统通过观察丢失、延迟推断是否发生拥塞 TCP采用的拥塞控制策略 网络辅助的拥塞控制 路由器提供到端系统的反馈 例如：可以使用1位指示拥塞(如X.25, ATM) TCP拥塞控制机制带宽探测：接收到ACK提高传输速率，发生丢失事件降低传输速率 ACK返回：说明网络并未拥塞，可以继续提高发送速率 丢失事件：假设所有丢失是由于拥塞造成的，降低发送速率 TCP拥塞控制控制窗口：采用基于窗口的方法，通过拥塞窗口的增大或减小控制发送速率 实际发送窗口取决于接收通告窗口和拥塞控制窗口中较小值 TCP拥塞控制 慢启动阶段 初始拥塞窗口：cwnd=1(MSS) 每个RTT，cwnd翻倍(指数增长) 每接收到一个ACK，cwnd增1(MSS) 当连接初始建立或报文段超时未得到确认时，TCP拥塞控制进入慢启动阶段 特点：初始值小，增长速度快 拥塞避免阶段 阈值ssthresh：拥塞窗口达到该阈值时，慢启动阶段结束，进入拥塞避免阶段 每个RTT，cwnd增1(线性增长) 注意：TCP使用字节计数，当收到ACK时，拥塞窗口计算如下： $cwnd = cwnd + MSS \\times \\frac{MSS}{cwnd}$ 丢失检测 通过超时检测丢失： 阈值ssthresh = cwnd/2 cwnd=1，进入慢启动阶段 通过三次重复ACK检测丢失(TCP RENO算法)： 阈值ssthresh = cwnd/2 cwnd= ssthresh+3，进入线性增长(拥塞避免阶段) 注：重复ACK指明网络仍可以交付一些报文段(拥塞不严重) TCP Tahoe算法对于两种丢失情况均将cwnd设成1，并进入慢启动阶段 网络层协议网络层功能网络层功能部署 网络层在每台主机和路由器中实现 发送端：将传输层数据单元封装在数据包中 接收端：解析接收的数据包中，取出传输层数据单元，交付给传输层 路由器：检查数据包首部，转发数据包 网络层关键功能 路由(控制面): 决定数据包从源主机到目的主机的路径核心：路由算法与路由协议 转发(数据面): 将数据包从路由器的输入接口送到输出接口的过程 IP协议- IP服务IP层服务 面向无连接的数据报服务 不需要提前建立连接 数据包基于目的主机地址进行转发 数据包独立转发，相同源-目的的数据包可能经过不同的路径 尽力而为(Best-effort)的不可靠服务 数据包可能会产生较长的时延 数据包可能会丢失、失序、重复 IPv4IPv4地址 IP地址：32位二进制逻辑地址(四部分，0~255)，实现互联网络统一编址，标识主机和路由器的接口 接口：将主机和路由器连接到物理网络 路由器一般有多个接口 主机可以有一个或多个接口 IP与物理接口绑定 IP地址表示：点分割的十进制，如：223.1.1.1 IP地址层次： 网络号部分(net-id) 主机号部分(host-id) 什么是一个IP网络： 位于同一个物理网络 设备接口的IP地址的网络号部分相同，主机号部分不同 IPv4地址：如何获取 公有IP地址要求全球唯一，由区域互联网注册机构(RIR，Regional Internet Registry)或ISP分配 静态设定： 申请固定IP地址，手工设定 动态获取： 使用DHCP协议或其他动态配置协议 当主机加入IP网络，允许主机从DHCP服务器动态获取IP地址 可以有效利用IP地址，方便移动主机的地址获取 路由器转发IP数据包过程：总结 路由器确定IP数据包中目的地址的网络号 如果目的主机与路由器属于相同的IP网络，则直接转发到目的主机 如果目的主机与路由器不属于相同的IP网络，则查找路由表，确定下一跳路由器地址 如果存在相应的路由信息，则转发 如果没有相应的路由信息，则丢弃 减小TTL值，修改首部的校验和 将数据包转发到相应的接口 无类地址划分CIDR: Classless Inter-Domain Routing IP地址分为前缀和后缀两部分 一个前缀不一定标识一个物理网络 前缀可以是任意长度，前缀和后缀长度用32位掩码标识 也可以表示成：a.b.c.d /x，x为前缀长度 私有IP地址和NAT 私有IP地址的使用 可以在私有网络(本地网络)中自由使用，但不能出现在公网上 如果数据包要进入公网，需要进行私有地址到公有地址的转换 承担地址转换的设备称为NAT(Network Address Translation) 本地网络使用私有IP地址，NAT 面向公网侧使用公网IP地址 只需要一个或少量的公网IP地址 公网IP地址变化，不影响本地网络地址配置 安全性增强 NAT 的基本实现方法离开本地网络的数据包：用(NAT 的IP地址+新端口号)代替(源IP地址+端口号)，远端的主机返回的数据包将使用(NAT 的IP地址+新端口号)作为目的IP地址和目的端口 NAT 在转换表中记录(NAT 的IP地址+新端口号)到(源IP地址+端口号)的映射 进入本地网络的数据包：用转换表中的(源IP地址+端口号)替换数据包中的目的IP地址和端口号(NAT 的IP地址+新端口号) IPv6IPv6互联网的优势 解决地址耗尽问题：更大的地址空间(32位→128位) 340,282,366,920,938,463,463,374,607,431,768,211,456个IP地址 地球上每平方米范围：6.67×1023个IP地址 自动配置的支持(即插即用) 无状态地址自动配置 有状态地址自动配置：对DHCP协议改进和扩展，网络管理更加方便和快捷 改善网络性能 IP包头的合理改善，提高了路由器对数据包的处理速率 路由聚合，使路由表更小，提高转发效率 方便各项业务开展 无需使用NAT 设备 IPv6数据包由一个IPv6基本头、多个扩展头和上层数据单元组成 IPv6基本头：40字节固定长度，包含了发送和转发该数据包必须处理的一些字段 IPv6数据包可以包含0个或多个扩展头，扩展头位于基本头之后 基本头和扩展头中“下一包头”字段指出下一个扩展头的类型。最后一个扩展头中的“下一包头”字段指出高层协议的类型 128位地址：由冒号分开的8组十六进制字段组成 完全形式：1080:0000:0000:0000:0008:0800:200C:417A 圧缩形式：1080:0:0:0:8:800:200C:417A / 1080::8:800:200C:417A 地址段中有时会出现连续的几组0，这时这些0可以用“::”代替，但一个地址中只能出现一次“::“，例如：FF01:0:0:0:0:0:0:101=FF01::101，0:0:0:0:0:0:0:1=::1 内嵌IPv4地址的IPv6地址：0:0:0:0:0:0:61.1.133.1 或::61.1.133.1 URL的IPv6地址表示：https://[2001:410:0:1:250:fcee:e450:33ab]:8443/abc.html ICMP协议ICMP: 互联网控制消息协议 路由算法目标：确定从源主机到目的主机的最优路径 最优路径：一般为代价最小的路径 代价：有不同的定义方法，例如：距离、时延、费用、拥塞等 路由算法的分布式实现 路由器之间交互路由信息或链路状态信息 每台路由器独立计算最优路径 相对于数据包转发，所有路由协议的开销都属于额外管理开销 网络结构的图抽象 路由器：图中的点 物理链路：图中的边 代价：图中边的权值 用G = (N, E) 表示图 N = { u, v, w, x, y, z }，路由器集合 E = { (u, v), (u, x), (v, x), (v, w), (x, w),(x,y), (w,y), (w,z), (y,z) } ，链路的集合 链路代价：相邻节点之间的代价值，表示为$c(x_i,x_j)$ 如果xi和xj不相邻，链路代价记为无穷 例如, c(w, z) = 5 路径代价：路径上所有链路代价和 例如，路径$(x_1, x_2,x_3,…, x_p)的代价= c(x_1,x_2) + c(x_2,x_3) + … + c(x_{p-1},x_p)$ Dijkstra算法详解 Bellman-Ford公式假设：$D_x$(y) = 从x到y最小代价路径的代价值则：$D_x$(y) = min { c(x,m) + Dm(y) } m为x的邻居 距离向量路由算法 算法符号定义 $D_x$(y) = 从x到y最小代价路径的代价值节点x可以获知到每个邻居的链路代价c(x, m) 节点x维护自己的距离向量$D_x = [D_x$(y): y єN ] 节点x维护其邻居的距离向量，对于每个邻居m，x维护$D_m = [D_m$(y): y єN ] 基本思想 当节点的距离向量值发生变化时，向邻居节点发送自己的距离向量 如果节点x接收到邻居节点发送的距离向量，使用Bellman-Ford公式重新计算到所有其他节点的路径代价 $D_x(y) ← min {c(x,m) + D_m(y)}$ 每个节点y ∊N 经过反复迭代，$D_x(y)$会逐渐收敛到实际的最小路径代价值 互联网路由协议扩展性问题 络路由表庞大，存储、查找困难 路由信息交互量大，额外开销高 管理的自治问题 互联网由大量自治域构成 每个自治域独立管理，每个自治域可能运行不同的路由协议 层次化路由 自治域内路由 相同的自治域中的所有路由器运行相同的自治域内路由协议 不同的自治域的路由器可以运行不同的自治域内路由协议 网关路由器(或边界路由器)：与其他自治域的路由器相连接的路由器 自治域间路由 不同自治域网关路由器(或边界路由器)之间运行的路由协议 网关路由器：既执行自治域内的路由协议，也执行路由器之间的路由协议 路由表由自治域内和自治域间路由算法产生 运行协议 自治域内路由：也称为内部网关协议IGP 路由信息协议RIP: Routing Information Protocol 使用距离向量法 两种基本的报文类型 请求报文 响应报文 定期发送通告：相邻路由器每隔30秒发送一次响应报文 IP目的地址：255.255.255.255(本地广播地址) 跳步数定义：直接相连=1 每个通告可以最多携带25个目的网络 触发更新：如果发现链路失效或变化，立即发送响应报文 如果超过180秒没有接收到邻居通告，则认为链路失效 通过邻居的路径失效 向邻居发送通告 如果邻居的路由表项发生变化，则继续通告 链路失效信息会传播到整个网络 使用毒性逆转可以防止暂时环路的产生 设置16跳为无穷值，提高收敛速度 RIP协议在应用层实现 路由器中运行守候进程(routed) 使用UDP的520端口 发送和接收RIP报文，管理路由表 开放最短路径优先协议OSPF: Open Shortest Path First 几个概念 邻居(Neighbor)：两台路由器属于相同的IP网络，并通过交换Hello报文协商成功，则可以成为邻居 邻接关系(Adjacency)：形成邻居关系后，如果两台路由器成功交换DBD(数据库描述)报文以及LSA，则建立邻接关系 链路状态通告(Link State Advertisement，LSA)：每台路由器会在所有形成邻接关系的邻居之间发送LSA，LSA描述了路由器的链路、接口、邻居等信息 链路状态数据库(LSDB)：路由器将收到的LSA记录在LSDB中，并发送LSA拷贝给该路由器的其他所有邻居。当LSA传播到整个区域后，区域内所有的路由器都会形成同样的LSDB OSPF直接运行在IP协议之上，OSPF报文由IP数据包直接承载，协议类型为89 三张表 邻居列表：列出全部已经建立邻接关系的邻居路由器 链路状态数据库：列出网络中其他路由器的信息，由此显示全网的网络拓扑 路由表：列出通过最短路径优先算法计算出到达每个相连网络的最佳路径 OSPF工作过程 邻居发现 通过Hello报文发现并形成邻居关系，建立邻居表 路由通告 邻接路由器之间通过LSU洪泛LSA，通告链路状态信息，最终区域内所有路由器的LSDB完全相同，即实现同步 通过DBD、LSR、LSACK辅助LSA的同步 路由计算 LSDB同步后，每台路由器独立计算最优路由，将最优路由信息写入路由表 中间系统到中间系统路由协议IS-IS：Intermediate System-to-Intermediate System (ISO) 内部网关路由协议IGRP: Interior Gateway Routing Protocol (Cisco) 自治域间路由 边界网关协议BGP-4: Border Gateway Protocol 目前互联网中唯一实际运行的自治域间的路由协议 BGP功能 eBGP: 从相邻的AS获得网络可达信息 iBGP: 将网络可达信息传播给AS内的路由器 基于网络可达信息和策略决定到其他网络的“最优”路由 BGP报文 BGP通过TCP的179端口交换报文 BGP报文包括: Open报文：用于建立BGP对等体（peer）之间的会话连接，协商BGP参数（该过程需要认证） Update报文：用于在对等体之间交换路由信息 Keepalive报文：用于保持BGP会话连接 Notification报文：用于差错报告和关闭BGP连接 软件定义网络(SDN)软件定义网络核心思想 解耦： 将控制平面和数据平面进行分离，解决传统网络中控制平面和数据平面在物理上紧耦合导致的问题解决的问题 控制平面和数据平面之间不需要相互依赖，只需要遵循一定的开放接口即可进行通信 控制平面：负责决策控制，由软件实现，灵活 数据平面：专注数据转发，可有由通用硬件实现 抽象： 转发抽象：将数据平面抽象为通用的转发模型，如Openflow的交换机模型，各种转发表项，如MAC地址表、路由表、NAT 转换表等，抽象为统一的流表 分布状态抽象：控制层将设备的分布状态，抽象成全局的网络视图，从而实现逻辑的集中控制，具体可以通过网络操作系统来实现 网络操作系统（NOS）：下发控制命令，收集设备和链路状态，为上层应用提供全局网络视图 配置抽象：网络行为的表达通过编程语言实现，将抽象配置映射为物理配置，利用控制器提供的API，通过控制器配置全局设备 接口层原理与协议 接口层提供同一物理网络中各节点之间的连接和通信 同一个物理网络必须执行相同的接口层协议 不同的物理网络接口层协议可以不同 接口层基础物理网络连接方式：节点到节点连接、共享式连接、交换式连接 接口层功能 物理层：提供位流服务 传输介质和拓扑结构定义 编码与解码(数据→信号) 信号的发送与接收 时钟同步 数据链路层：提供可靠或不可靠的传输服务 数据单元及寻址方式定义 链路层差错检测 链路层的复用和分用 可靠数据传输 共享式连接：提供介质访问控制方法 交换式连接：数据单元转发 接口层技术分类 有多种接口层技术，传统上大致可以分成三类 局域网技术(LAN, Local Area Network ) 如：以太网(Ethernet)、无线局域网(WiFi) 城域网技术(MAN, Metropolitan Area Network) 如：FDDI、交换式Ethernet 广域网技术Wide Area Network (WAN) 如：ATM 其他接口技术 个人区域网 如：蓝牙技术(Bluetooth) 无线传感网络 如：Zigbee技术 局域网体系结构与组网方法介质访问控制层(Medium Access Control ) 物理节点寻址 差错控制 介质访问控制（共享式连接） 逻辑链路控制层（Logical Link Control） 链路层的复用和分用 可靠数据传输 共享式局域网 网络中任一节点发送的信息会被网络中所有节点收到（广播传输） 例如，共享式以太网，无线局域网，FDDI等 需要协调节点对共享介质的访问 介质访问控制方法 交换式局域网 链路采用点到点连接 例如，交换式以太网 交换机成为网络连接的核心 完成链路层数据单元的转发 通常采用统计多路复用 MAC地址—物理地址 32位IP地址: 网络层地址（逻辑地址）：标识主机或路由器的一个接口 主要用于IP数据包的路由转发 48位MAC地址（物理地址）: 物理地址：在相同的物理网络中，标识一个节点 对于大多数局域网，采用48位MAC地址 位于网卡的ROM或EPROM中 扁平地址，无层次，需要唯一 局域网编址与ARP协议ARP协议ARP: Address Resolution Protocol 局域网的每个IP节点（主机或路由器）都有ARP表 ARP表缓存IP地址和MAC地址的映射关系 链路层差错控制在数据链路层中，广泛使用循环冗余校验（Cyclic Redundancy Check ）CRC校验码计算方法 设原始数据D为k位二进制位模式 如果要产生n位CRC校验码，事先选定一个n+1位二进制位模式G（称为生成多项式），G的最高位为1 将原始数据D乘以$2^n$ （相当于在D后面添加n 个0），产生k+n位二进制位模式，用G对该位模式做模2除，得到余数R（n位，不足n位前面用0补齐）即为CRC校验码 共享式与交换式以太网共享式以太网：连接方式与功能 连接方式 方式1：通过同轴电缆连接（10Mbps以太网） 方式2：通过双绞线、光纤与集线器连接 服务：面向非连接的不可靠服务 功能 物理层 信号编码、时钟同步等，如差分曼彻斯特编码 介质访问控制层 介质访问控制：CSMA/CD 差错检测 逻辑链路控制层 复用与分用 虚拟局域网基于端口的VLAN: 交换机的端口被分组，单个物理交换机能够作为多个虚拟交换机运行 基于端口VLAN原理： 隔离通信流量: 来自于或到达端口1-8的流量只能到达1-8 也可以基于MAC地址定义VLAN 动态配置: 端口能够在VLAN之间动态配置 VLAN之间转发:类似独立的交换机，通过路由进行转发 无线局域网802.11无线局域网组网模式 基础架构模式： 站点（STA） 访问点（AP） 基本服务器（BSS） 扩展服务器（ESS） 注：每个BSS中的站点和AP共享同一无线信道；站点通过AP转发数据 自组织模式： 站点（STA） 独立基本服务器（IBSS） 站点之间直接通信 共享同一无线信道 注：每个站点在某个时刻只能工作在一种模式","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://kpl0111.github.io/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"LightSensor","date":"2021-04-23T19:31:03.000Z","path":"2021/0420210424.html","text":"光线传感器实验目的本次实验的目的是让大家了解Android中光线传感器的基本知识，掌握Android中光线传感器的使用方法。 实验要求 了解Android中光线传感器基本知识 掌握Android中光线传感器使用方法 基础知识光线传感器基础 光线传感器的好处是可以根据手机所处环境的光线来调节手机屏幕的亮度和键盘灯。例如在光线充足的地方屏幕会很亮，键盘灯就会关闭。相反如果在暗处，键盘灯就会亮，屏幕较暗（与屏幕亮度的设置也有关系），这样既保护了眼睛又节省了电量。光线传感器在进入睡眠模式时候会发出蓝色周期性闪动的光，非常美观。在本节的内容中，将详细讲解Android系统光线传感器的基本知识。光线传感器介绍在Android设备中，光线传感器通常位于前摄像头旁边的一个小点，如果在光线充足的情况下（室外或者是灯光充足的室内），大约在2～3秒之后键盘灯会自动熄灭，即使再操作机器键盘灯也不会亮，除非到了光线比较暗的地方才会自动地亮起来。如果在光线充足的情况下用手将光线感应器遮上，在2～3秒后键盘灯会自动亮起来，在此过程中光线感应器起到了一个节电的功能。要想在Android设备中监听光线传感器，需要掌握如下所示的监听方法。 registerListenr(SensorListenerlistenr,int sensors,int rate)：已过时。 registerListenr(SensorListenerlistenr,int sensors)：已过时。 registerListenr(SensorEventListenerlistenr,Sensor sensors,int rate)。 registerListenr(SensorEventListenerlistenr,Sensor sensors,int rate,Handlerhandler)：因为SensorListener已经过时，所以相应的注册方法也过时了。 在上述方法中，各个参数的具体说明如下所示。 Listener：相应监听器的引用。 Sensor：相应的感应器引用。 Rate：感应器的反应速度，这个必须是系统提供的4个常量之一。 SENSOR_DELAY_NORMAL：匹配屏幕方向的变化。 SENSOR_DELAY_UI：匹配用户接口。 SENSOR_DELAY_GAME：匹配游戏。 SENSOR_DELAY_FASTEST.：匹配所能达到的最快。 实验内容按照实验的内容进行操作，掌握Android中光线传感器的使用方法等内容。完成实验内容后，设计一个光线传感器的app，至少包含如下功能： 显示当前光线传感器的光照强度； 显示当前光线传感器的名称，耗电量，以及最大测量范围。 获取上述参数方法如下： myS = mySm.getDefaultSensor(Sensor.TYPE_LIGHT); 名称：myS.getName() ; 耗电量（mA）：myS.getPower(); 最大测量范围：myS.getMaximumRange() 实验过程 利用Android studio创建一个工程，并利用实体机或者安卓虚拟机进行测试（这里我先利用逍遥模拟器进行测试，成功之后，连接真机进行测试） 修改activity_main.yml文件，新建一个静态文本控件用来输出我们要输出的亮度传感器的有关信息，这里新建工程初始化时会自动生成一个文本控件，文本内容默认为“Hello World！”，所以只需在其基础上进行修改即可 123456789&lt;TextView android:id=\"@+id/textView1\"//为控件添加编号textView1 android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\"//初始化文本内容 app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; 修改Mainactivity.java文件对传感器进行控制并进行文本输出 12345678910111213141516171819202122232425//这里仅展示所需主要代码。具体代码见工程文件public class MainActivity extends Activity implements SensorEventListener { private SensorManager sensor;//定义一个传感器管理器 private TextView text;//定义一个文本控件 @Override protected void onCreate(Bundle savedInstanceState) {//项目初始化函数 super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sensor = (SensorManager)getSystemService(SENSOR_SERVICE);//调用getSystemService函数来获取传感器控制权 text = (TextView)findViewById(R.id.textView1);//通过控件ID将实体文本控件与代码连接起来 } @Override public void onSensorChanged(SensorEvent event) { // 在传感器控制函数里面实现我们的功能 float[] values = event.values; //定义变量来获取事件的值 int sensorType = event.sensor.TYPE_LIGHT; //定义值为事件发生时的传感器变量值 if(sensorType==Sensor.TYPE_LIGHT){//如果对应系统中的亮度传感器，则证明是亮度发生变化 String detail=\"\\n传感器名称：\"+(event.sensor.getType()==Sensor.TYPE_LIGHT?(event.sensor.getName()+\"\\n中文名称：光照传感器\"):\"\")+\"\\n耗电量：\"+event.sensor.getPower()+\"\\n最大测量范围：\"+event.sensor.getMaximumRange();//定义字符串来实现输出，调用getName，getPower，getMaximumRange函数来获取传感器参数 text.setText(detail+\"\\n当前光照强度：\"+String.valueOf(values[0])+\"Lux\\n\");//将静态文本控件内容更新为传感器信息 text.setTextSize(30);//设置字体大小 text.setTextColor(Color.parseColor(\"#ff5e9cff\"));//#7E0C6E设置字体颜色 } }} 软件效果展示","tags":[{"name":"Android","slug":"Android","permalink":"https://kpl0111.github.io/blog/tags/Android/"},{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"}]},{"title":"Ucore_lab1","date":"2021-04-13T08:26:17.000Z","path":"2021/0420210413.html","text":"说明在解压后的ucroe源码包中使用make命令即可以生成所需的目标文件,例如在本次实验中 1user@system:~../lab1$ make 之后就会在bin文件夹生成一系列的目标文件： user.img : 被qemu访问的虚拟硬盘文件 kernel : ELF格式的toy ucore kernel执行文，嵌入到了ucore.img中 bootblock : 虚拟的硬盘主引导扇区(512字节)，包含了bootloader执行代码，同样嵌入了 sign : 外部执行程序，用来生成虚拟的硬盘主引导扇区还有其他文件，不一一列举。 如果要对修改后的ucore代码和ucore 源码进行比较，可以使用diff命令。 1user@system:~../lab1$ diff 目标文件 源文件 练习11. 操作系统镜像文件ucore.img如何生成？ 执行指令 1user@system:~../lab1$ make \"V=\" 可以获得Makefile中执行的具体指令，详细信息如下（仅列举有关ucore.img文件生成相关指令）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 + cc kern/init/init.c gcc -c kern/init/init.c -o obj/kern/init/init.o+ cc kern/libs/readline.c gcc -c kern/libs/readline.c -o obj/kern/libs/readline.o+ cc kern/libs/stdio.c gcc -c kern/libs/stdio.c -o obj/kern/libs/stdio.o+ cc kern/debug/kdebug.c gcc -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o+ cc kern/debug/kmonitor.c gcc -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o+ cc kern/debug/panic.c gcc -c kern/debug/panic.c -o obj/kern/debug/panic.o+ cc kern/driver/clock.c gcc -c kern/driver/clock.c -o obj/kern/driver/clock.o+ cc kern/driver/console.c gcc -c kern/driver/console.c -o obj/kern/driver/console.o+ cc kern/driver/intr.c gcc -c kern/driver/intr.c -o obj/kern/driver/intr.o+ cc kern/driver/picirq.c gcc -c kern/driver/picirq.c -o obj/kern/driver/picirq.o+ cc kern/trap/trap.c gcc -c kern/trap/trap.c -o obj/kern/trap/trap.o+ cc kern/trap/trapentry.S gcc -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o+ cc kern/trap/vectors.S gcc -c kern/trap/vectors.S -o obj/kern/trap/vectors.o+ cc kern/mm/pmm.c gcc -c kern/mm/pmm.c -o obj/kern/mm/pmm.o+ cc libs/printfmt.c gcc -c libs/printfmt.c -o obj/libs/printfmt.o+ cc libs/string.c gcc -c libs/string.c -o obj/libs/string.o+ ld bin/kernel ld -o bin/kernel obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o obj/libs/printfmt.o obj/libs/string.o+ cc boot/bootasm.S //编译bootasm.S gcc -c boot/bootasm.S -o obj/boot/bootasm.o+ cc boot/bootmain.c //编译bootmain.c gcc -c boot/bootmain.c -o obj/boot/bootmain.o+ cc tools/sign.c //编译sign.c gcc -c tools/sign.c -o obj/sign/tools/sign.o gcc -O2 obj/sign/tools/sign.o -o bin/sign+ ld bin/bootblock //根据sign规范生成bootblock ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o 在makefile文件中搜索ucore.img可以找到 1234567#create ucore.imgUCOREIMG :=$(call totarget,ucore.img)$(UCOREIMG):$(kernel)$(bootblock) $ $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc$(call create_target,ucore.img) 可以看出ucore.img镜像文件是由kernel和bootblock文件生成的。 12$(V)dd if=/dev/zero of=$@count=100000 这句语句可以看到UCOREIMG分配了一定空间。 1(V)dd if=$(bootblock) of=$@ conv=notrunc 这句语句将bootblock复制到上面分配的空间当中。 1$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc 该语句将kernel复制到分配的空间当中。 1.kernel生成12kernel = $(call totarget,kernel)$(kernel): tools/kernel.ld 通过链接来生成kernel目标文件 1$(kernel): $(KOBJS) kernel的生成还依赖KOBJS 123456@echo + ld $@ $(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) @$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel) @$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; $(call symfile,kernel)$(call symfile,kernel)kernel = $(call totarget,kernel) 2.bootblock生成1bootfiles = $(call listf_cc,boot) 用boot替换listf_cc里面的变量，将listf_cc的返回值赋给bootfiles,也就是滤出.c,.s文件 1$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc)) 编译bookfiles 1bootblock = $(call totarget,bootblock) 生成bootblock 1$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign) 生成目标文件bootblock需要依赖于sign和bootfiles 1@echo + ld $@ 将以下文件与bootblock连接起来 123456$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)@$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock) @$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)$(call create_target,bootblock) 3.生成sign工具12$(call add_files_host,tools/sign.c,sign,sign)$(call create_target_host,sign,sign) 由sign工具、bootfile生成bootblock 由KOBJS生成kernel 由kernel和bootblock生成最终的ucore.img 2.一个被系统认为是符合规范的硬盘主引导扇区的特征是什么? 通过查阅资料我们可以知道bootblock区域包含用于引导的最小指令集，而在上一个问题中我们发现bootblock的生成需要依赖于sign.c文件和bootfiles文件，其中bootfiles提供开机启动所需要的文件，而sign.c则代表生成bootblock的规范。 因此，我们去在文件夹中查看sign.c文件。 文件代码如下： 1234567891011char buf[512]; //定义buf数组memset(buf, 0, sizeof(buf)); // 把buf数组的最后两位置为 0x55, 0xAAbuf[510] = 0x55; buf[511] = 0xAA;FILE *ofp = fopen(argv[2], \"wb+\");size = fwrite(buf, 1, 512, ofp);if (size != 512) { //大小为512字节 fprintf(stderr, \"write '%s' error, size is %d.\\n\", argv[2], size); return -1;} 通过查看这里的代码，我们可以发现sign规范中给buf提供了512个字节的空间，而且bootblock的格式是最后两个字节分别是0x55和0xAA，而这也是操作系统课上提到的两个神奇的数。 练习21.使用qemu调试make文件 在进入lab1文件夹之后，使用命令 make debug 进入调试模式。 （1）在查看了tools文件夹中的gdbinit文件之后，可以看到存在代码 1target remote localhost：1234 这代表着在启动之后会连接qemu和gdb。 （2）在make debug之后输入stepi，可以按照机器指令单步执行。 （3）一开始进入的是init.c程序。提示是init the console。 （4）再执行几次step执行源代码之后，就进入stdio.c文件。 （5）像这样反复执行step/next语句，就可以按照程序源代码一步一步执行了。 2.在初始化位置0x7c00设置实地址断点 在tools文件夹中的gdbinit文件中增加”b*0x7c00”语句，可以在实地址0x7c00位置设置一个断点。 3.单步跟踪反汇编得到的代码与bootasm.s和bootblock.asm进行比较 在位置0x7c00位置之后单步执行机器指令并且查看反汇编语句，和gedit打开的bootblock.asm文件进行对比。可以找到这个位置正好在bootblock.asm文件中。在位置0x7c00这里有着相同的语句。 注意在这里要在gdb中执行如下的指令 123define hook-stopx/i $pcend 这样才可以进入反汇编的状态 同时我们查看bootasm.s文件之后，可以看到这样的代码 1234\\#Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)movl $0x0, %ebpmovl $start, %espcall bootmain 意味着从这里开始跳转到0x7c00. 4.自己找一个bootloader或者内核中的代码位置，设置断点并进行测试 像上个问题一样在gdbinit里面写入*b 0x7c1a，设置断点，然后类似的进行单步调试。 练习3分析bootloader进入保护模式的过程。BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。提示：需要阅读小节“保护模式和分段机制”和lab1/boot/bootasm.S源码，了解如何从实模式切换到保护模式，需要了解：1、为何开启A202、以及如何开启A203、 如何初始化GDT表4、如何使能和进入保护模式 分析首先bootloader从实模式进入保护模式要经过一下几个步骤： 1、开启A20门 2、建立GDT表并对其进行初始化操作 3、设置cr0寄存器的值为1 当寄存器值切换后方可表示模式切换成功初始状态A20地址线被屏蔽所以一直保持为0，我们要进一步访问内存需要A20地址线，需要将其打开。一、开启A20打开A20 Gate的具体步骤大致如下： 1、等待8042 Input buffer为空 2、发送Write 8042 Output Port （P2） 命令到8042 Input buffer 3、等待8042 Input buffer为空 4、将8042 Output Port（P2） 对应字节的第2位置1，然后写入8042 Input buffer 1234567891011121314151617 # 开启A20：通过将键盘控制器上的A20线置于高电位，全部32条地址线可用， # 可以访问4G的内存空间。seta20.1: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.1 movb $0xd1, %al # 0xd1 -&gt; port 0x64 outb %al, $0x64 # 0xd1 means: write data to 8042's P2 portseta20.2: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 0xdf -&gt; port 0x60 outb %al, $0x60 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1 二、建立并初始化GDT,寄存器置为1123456789# Switch from real to protected mode, using a bootstrap GDT# and segment translation that makes virtual addresses# identical to physical addresses, so that the# effective memory map does not change during the switch.# 初始化GDT表：一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可lgdt gdtdescmovl %cr0, %eax #进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式orl $CR0_PE_ON, %eaxmovl %eax, %cr0 完成以后步骤后bootloader已经从实模式进入到了保护模式练习412分析BootLoader加载ELF格式的OS的过程通过阅读bootmain.c,了解bootloader如何加载ELF文件。通过分析代码和通过qemu来运行调试 分析首先看bootmain函数 12345678910111213141516171819202122232425262728void bootmain(void){ //read the 1st page off disk readseg((uintptr_t)ELFHDR,SECTSIZE*8,0); //is this a valid ELF? if (ELFHDR-&gt;e_magic !=ELF_MAGIC){ goto bad; } struct proghdr *ph,*eph; // load each program segment(ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR+ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; for(;ph&lt;eph;ph++){ readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); } // call the entry point from the ELF header // note:does not return ((void(*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();bad: outw(0x8A00,0x8A00); outw(0x8A00,0x8E00); /* do nothing */ while(1);} 先是读磁盘，转入readseg函数 12345678910111213141516static void readseg(uintptr_t va,uint32_t count,uint32_t offset){ uintptr_t end_va = va + count; //round down to sector boundary va -= offset % SECTSIZE ; //translate from bytes to sectors; kernel starts at sector 1 uint32_t secno = (offset / SECTSIZE) + 1; //If this is too slow , we could read lots of sectors at a time. //We'd write more to memory than asked,but it doesn't matter -- //We load in increasing order. for(; va &lt; end_va; va += SECTSIZE, secno ++){ readsect((void*)va,secno); }} 从readseg函数发现又调用了readsect函数 12345678910111213141516static void readsect(void *dst,unit32_t secno){ //wait for disk to be ready waitdisk(); outb(0x1F2, 1);//要读写的扇区数，需要表明要读写几个扇区 outb(0x1F3, secno &amp; 0xFF);//LBA参数的0~7位 outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);//LBA参数的8~15位 outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);//LBA参数的16~23位 outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);//第0~3位：LBA参数的24-27位 第4位：为0主盘；为1从盘 outb(0x1F7,0x20);//状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口 读数据 //wait for disk to be ready waitdisk(); //read a sector insl(0x1F0,dst,SECTSIZE/4);//读取扇区 读一个扇区的流程大致如下： 等待磁盘准备好 发出读取扇区的命令 等待磁盘准备好 把磁盘扇区数据读到指定内存 其中的outb是一个机器指令，是在x86.h中的 123static inline void outb(uint16_t port, unit8_t data){ asm volatile(\"outb %0, %1\" :: \"a\"(data), \"d\"(port));} 用内联汇编实现，用了I0空间寻址方式，能将外部的数据读到内存中来，这也是x86里面的寻址方式 可以发现首先是等磁盘准备好，然后是写入地址和读取磁盘的命令，最后是按照地址读取磁盘扇区（可参考代码中的中文注释） 再接着看main函数，用了一个if语句判断是否为ELF文件，具体判断方式为将ELF header中的一个e_magic和一个特定值进行比较，若不是则转入bad,是则继续执行 123456789101112struct proghdr *ph,*eph; // load each program segment(ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR+ELFHDR-&gt;e_phoff);//将ELF文件的头部文表取出存到ph eph = ph + ELFHDR-&gt;e_phnum; for(;ph&lt;eph;ph++){ #加载ELF文件到内存 readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); } // call the entry point from the ELF header // note:does not return ((void(*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();//ELF文件加载完毕后，将控制权交给ucore去执行 由此完成ELF文件的加载练习51完成kdebug.c中函数print_stackframe的实现，可以通过函数&gt;print_stackframe来跟踪函数调用堆栈中记录的返回地址。 1、函数堆栈的原理 理解函数堆栈最重要的两点是：栈的结构，以及EBP寄存器的作用。 一个函数调用动作可分解为零到多个 PUSH指令（用于参数入栈）和一个 CALL 指令。CALL 指令内部其实还暗含了一个将返回地址压栈的动作，这是由硬件完成的。几乎所有本地编译器都会在每个函数体之前插入类似如下的汇编指令： 12pushl %ebpmovl %esp,%ebp 这两条汇编指令的含义是：首先将ebp 寄存器入栈，然后将栈顶指针 esp 赋值给 ebp。 movl %esp %ebp这条指令表面上看是用esp覆盖 ebp原来的值，其实不然。因为给 ebp赋值之前，原ebp 值已经被压栈（位于栈顶），而新的ebp又恰恰指向栈顶。此时ebp寄存器就已经处于一个非常重要的地位，该寄存器中存储着栈中的一个地址（原 ebp入栈后的栈顶），从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的ebp值。 我们可以直接根据ebp就能读取到各个栈帧的地址和值，一般而言，ss:[ebp+4]处为返回地址，ss:[ebp+8]处为第一个参数值（最后一个入栈的参数值，此处假设其占用 4 字节内存，对应32位系统），ss:[ebp-4]处为第一个局部变量，ss:[ebp]处为上一层 ebp 值。 如图 2、print_stackframe函数的实现 首先我们直接看到print_stackframe函数的注释： 123456789101112131415void print_stackframe(void) { /* LAB1 YOUR CODE : STEP 1 */ /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t); * (2) call read_eip() to get the value of eip. the type is (uint32_t); * (3) from 0 .. STACKFRAME_DEPTH * (3.1) printf value of ebp, eip * (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4] * (3.3) cprintf(\"\\n\"); * (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc. * (3.5) popup a calling stackframe * NOTICE: the calling funciton's return addr eip = ss:[ebp+4] * the calling funciton's ebp = ss:[ebp] */} 这样我们直接根据注释以及之前的相关知识就能比较简单的编写成程序，如下所示： 1234567891011121314void print_stackframe(void) { uint32_t ebp=read_ebp();//(1) call read_ebp() to get the value of ebp. the type is (uint32_t) uint32_t eip=read_eip();//(2) call read_eip() to get the value of eip. the type is (uint32_t) int i; for(i=0;i&lt;STACKFRAME_DEPTH&amp;&amp;ebp!=0;i++){//(3) from 0 .. STACKFRAME_DEPTH cprintf(\"ebp:0x%08x eip:0x%08x \",ebp,eip);//(3.1)printf value of ebp, eip uint32_t *tmp=(uint32_t *)ebp+2; cprintf(\"arg :0x%08x 0x%08x 0x%08x 0x%08x\",*(tmp+0),*(tmp+1),*(tmp+2),*(tmp+3));//(3.2)(uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4] cprintf(\"\\n\");//(3.3) cprintf(\"\\n\"); print_debuginfo(eip-1);//(3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc. eip=((uint32_t *)ebp)[1]; ebp=((uint32_t *)ebp)[0];//(3.5) popup a calling stackframe }} 实验结果截图如下： 练习6：完善中断初始化和处理1、中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？2、请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。3、请编程完善trap.c中的中断处理函数trap,在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统毎遇到100次时钟中断后，调用print_tricks子程序，在屏幕上打印一行文字“100 ticks”。 1、中断描述符表中一个表项占8字节 如上图所示，其中的0-15位是offset的低16位，48-63位是offset的高16位，16-31位是段选择子，用于索引全局描述符表GDT来获取中断处理代码对应的段地址，再加上段内偏移量即可得到中断处理代码的入口。 2、完善初始化函数 （1）根据函数中的注释提示，第一步是声明__vertors[]; (2) 第二步是使用SETGATE填充中段描述符表IDT (3) 第三步是使用lidt指令让CPU加载中断描述符表IDT 具体的代码如下： 123456789void idt_init(void){ extern uintptr_t __vecors[]; int i; for(i=0; i &lt; 256; i++){ SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL); } SETGATE(idt[T_SWITCH_TOK],0,GD_KTEXT,__vectors[T_SWITCH_TOK],DPL_USER); lidt(&amp;idit_pd);} 其中宏SETGATE的定义为 1#define SETGATE(gate, istrap, sel, off, dpl) GD_KTEXT和DPL_KERNEL的定义在memlayout.h中 gate表示处理函数的入口地址，此处即idt[]数组中的内容istrap表示1为异常门，0为中断门sel表示段选择子off表示偏移量，此处即__vectors[]数组中的内容dpl表示设置等级，此处设置为DPL_KERNEL，恒为0 3、编写函数根据提示，需要用一个全局变量记录每次时钟中断，然后用print_ticks()打印“100 ticks”后重新从0开始计数，参照clock.c,写出如下函数： 1234567case IRQ_OFFSET+IRQ_TIMER:ticks=ticks+1;if(ticks==TICK_NUM){ print_ticks(); ticks=0;}break; 其中TICK_NUM已被定义为100 最后的运行结果为下图： Challenge 1&amp;2 新建用户态并进行内核态互换通过编写c++内联汇编函数，来实现用户态和内核态的切换。 已知初始化内核的函数如下： 12345678910static voidswitch_test(void) { print_cur_status(); // print 当前 cs/ss/ds 等寄存器状态 cprintf(\"+++ switch to user mode +++\\n\"); switch_to_user(); // switch to user mode print_cur_status(); cprintf(\"+++ switch to kernel mode +++\\n\"); switch_to_kernel(); // switch to kernel mode print_cur_status();} 而在init.c里面没有switch_to_user函数的内容以及switch_to_kernel函数的内容，因此这些部分需要编程。 1.调到用户态 通过编写switch_to_user的内容来使在内核初始化的时候可以切换到用户态。 1234567asm volatile ( \"sub $0x8, %%esp \\n\" \"int %0 \\n\" \"movl %%ebp, %%esp\" : : \"i\"(T_SWITCH_TOU)); 通过编写内联汇编语句来实现切换，用中断处理int 0来实现，需要输入的“i”也就是T_SWITCH_TOU。调整栈顶指针和栈底指针开辟程序空间之后，进行中断来实现切换。 在trap.c中要修改t_switch_tou的内容 12345678910case T_SWITCH_TOU: if (tf-&gt;tf_cs != USER_CS) { switchk2u = *tf; switchk2u.tf_cs = USER_CS; switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS; switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe) - 8; switchk2u.tf_eflags |= FL_IOPL_MASK; *((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u; } break; 这段代码可以使原来的状态不是用户态时候，将原来的状态修改成用户态。 12switchk2u.tf_eflags |= FL_IOPL_MASK;*((uint32_t*)tf - 1) = (uint32_t)&amp;switchk2u; 将这里的标记确认成为用户态，并且中断返回到正确的栈。 2.用户态到内核态 用类似的内联汇编处理。 123456asm volatile ( \"int %0 \\n\" \"movl %%ebp, %%esp \\n\" : : \"i\"(T_SWITCH_TOK)); 因为切换到的是内核态，不需要更多空间，所以相比内核到用户的内联汇编不再需要在栈指针减去一个值来开辟空间。 然后我们同样需要在trap.c中修改T_SWITCH_TOK的内容 123456789case T_SWITCH_TOK: if (tf-&gt;tf_cs != KERNEL_CS) { tf-&gt;tf_cs = KERNEL_CS; tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS; tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK; switchu2k = (struct trapframe *)(tf-&gt;tf_esp (sizeof(struct trapframe) - 8)); memmove(switchu2k, tf, sizeof(struct trapframe) - 8); *((uint32_t *)tf - 1) = (uint32_t)switchu2k; } 跟之前切换的修改类似 3.实现切换123456789101112131415161718case IRQ_OFFSET + IRQ_KBD: c = cons_getc(); cprintf(\"kbd [%03d] %c\\n\", c, c); if(c == '0' &amp;&amp; (tf-&gt;tf_cs &amp; 3) != 0) { cprintf(\"Input 0......switch to kernel\\n\"); tf-&gt;tf_cs = KERNEL_CS; tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS; tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK; } else if (c == '3' &amp;&amp; (tf-&gt;tf_cs &amp; 3) != 3) { cprintf(\"Input 3......switch to user\\n\"); tf-&gt;tf_cs = USER_CS; tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS; tf-&gt;tf_eflags |= FL_IOPL_MASK; } break; 修改完代码之后执行 1make qemu 键盘输入0或3即可实现切换 最终评分","tags":[{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"},{"name":"OS","slug":"OS","permalink":"https://kpl0111.github.io/blog/tags/OS/"}]},{"title":"可视化第一次作业","date":"2021-04-09T17:52:16.000Z","path":"2021/042021410.html","text":"作业内容1．编程实现消息测试程序，满足以下要求： 按下键盘任意字符键（至少识别两个功能键），客户区中显示按键信息（字符或功能键内容）； 单击鼠标左键，消息对话框中显示鼠标信息（鼠标左键+坐标）； 假设鼠标右键失灵，用Ctrl+鼠标左键代替，消息对话框中显示鼠标信息（鼠标右键+坐标）； 自定义WM_MY_MESSAGE消息，带10和100两个参数，由“#”（不是“3”）键激活，客户区中显示相应信息（自定义消息+参数）。 2．编程实现SmallBall程序，满足以下要求： 黑色小球，从左上角开始，沿着45度方向移动，遇到边界反弹； 通过两个菜单项（加速与减速），调节小球的移动幅度（递增或递减）； 通过两个工具栏按钮，控制小球停止与再次启动。 展示Key 常规按键 功能键 单击鼠标左键 Ctrl+鼠标左键替代鼠标右键 自定义Message Ball 加速 减速 暂停 启动 有轨迹 状态栏实现过程Key添加命令在MESSAGE_MAP处添加本项目所需所有打印命令，包括自定义命令。12345678910BEGIN_MESSAGE_MAP(CKeyView, CView) //标准打印命令 ON_COMMAND(ID_FILE_PRINT, &amp;CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_DIRECT, &amp;CView::OnFilePrint) ON_COMMAND(ID_FILE_PRINT_PREVIEW, &amp;CView::OnFilePrintPreview) ON_WM_LBUTTONUP() ON_WM_CHAR() ON_WM_KEYDOWN() ON_MESSAGE(WM_MYMESSAGE, OnMyMessage)END_MESSAGE_MAP() 头文件函数声明在KeyView.h头文件里面声明OnLButtonUp，OnChar，PreTranslateMessages，以及OnMyMessage函数12345protected: afx_msg void OnLButtonUp(UINT nFlags, CPoint point); //添加鼠标左键点击函数，以及按键事件函数 afx_msg void OnChar(UINT nChar, UINT nRedCnt, UINT nFlags); virtual BOOL PreTranslateMessage(MSG* pMsg); afx_msg LRESULT OnMyMessage(WPARAM wParam, LPARAM lParam); void CKeyView::OnLButtonUp(UINT nFlags, CPoint point)本函数主要实现鼠标左键点击以及替代右键功能，利用if语句如果是Ctrl+鼠标左键的话，则输出右键点击，并利用point来获取当前坐标，使用TextOutW来输出，如果if条件不成立，则输出左键点击12345678910void CKeyView::OnLButtonUp(UINT nFlags, CPoint point){ CDC* pDC = GetDC(); CString m_str; if (nFlags &amp; MK_CONTROL)//ctrl+左键代表右键 m_str.Format(L\"X:%d,Y:%d:Right Mouse Button Clicked!\", point.x, point.y); else m_str.Format(L\"X:%d,Y:%d:Left Mouse Button Clicked!\", point.x, point.y); pDC-&gt;TextOutW(point.x, point.y, m_str);} void CKeyView::OnChar(UINT nChar, UINT nRedCnt, UINT nFlags)本函数主要实现常规按键和自定义消息#键（在自定义消息里面讲）的输出，首先获取当前按键的字符，如果不是#，则弹出弹框声明123456789101112void CKeyView::OnChar(UINT nChar, UINT nRedCnt, UINT nFlags){ if (nChar == '#') //按键如果是#则调用自定义消息，其他则调用系统消息 SendMessage(WM_MYMESSAGE, 10, 100); else { CString str; str.Format(L\"%c Key Entered!\", nChar); MessageBox(str); } CView::OnChar(nChar, nRedCnt, nFlags);} BOOL CKeyView::PreTranslateMessage(MSG* pMsg)本函数实现功能按键，主要思路就是通过pMsg的wParam来对应不同功能键，从而进行输出，考虑到shift和ctrl的常用性，并没有对其进行添加，其他功能键也类似123456789101112131415161718192021222324252627BOOL CKeyView::PreTranslateMessage(MSG* pMsg){ if (pMsg-&gt;message == WM_KEYDOWN)//添加功能键，方法类似可添加更多，常用ctrl和shift注释掉了以免影响其他键的操作 { if (pMsg-&gt;wParam == VK_F1) MessageBox(L\"F1 Key Entered!\"); if (pMsg-&gt;wParam == VK_F2) MessageBox(L\"F2 Key Entered!\"); if (pMsg-&gt;wParam == VK_F3) MessageBox(L\"F3 Key Entered!\"); if (pMsg-&gt;wParam == VK_F4) MessageBox(L\"F4 Key Entered!\"); if (pMsg-&gt;wParam == VK_F5) MessageBox(L\"F5 Key Entered!\"); if (pMsg-&gt;wParam == VK_F6) MessageBox(L\"F6 Key Entered!\"); if (pMsg-&gt;wParam == VK_F7) MessageBox(L\"F7 Key Entered!\"); if (pMsg-&gt;wParam == VK_F8) MessageBox(L\"F8 Key Entered!\"); if (pMsg-&gt;wParam == VK_F9) MessageBox(L\"F9 Key Entered!\"); if (pMsg-&gt;wParam == VK_F10) MessageBox(L\"F10 Key Entered!\"); if (pMsg-&gt;wParam == VK_F11) MessageBox(L\"F11 Key Entered!\"); if (pMsg-&gt;wParam == VK_F12) MessageBox(L\"F12 Key Entered!\"); if (pMsg-&gt;wParam == VK_UP) MessageBox(L\"↑ Key Entered!\"); if (pMsg-&gt;wParam == VK_DOWN) MessageBox(L\"↓ Key Entered!\"); if (pMsg-&gt;wParam == VK_LEFT) MessageBox(L\"← Key Entered!\"); if (pMsg-&gt;wParam == VK_RIGHT) MessageBox(L\"→ Key Entered!\"); //if (pMsg-&gt;wParam == VK_CONTROL) MessageBox(L\"Ctrl Key Entered!\"); if (pMsg-&gt;wParam == VK_CAPITAL) MessageBox(L\"CapsLk Key Entered!\"); //if (pMsg-&gt;wParam == VK_SHIFT) MessageBox(L\"Shift Key Entered!\"); } return CView::PreTranslateMessage(pMsg);} 自定义消息 首先声明自己的消息名字和编号1#define WM_MYMESSAGE WM_USER+10 声明一个关于自定义消息的响应函数OnMyMessage 在Onchar里面实现，如果按下#键，则SendMessage，含有两个参数10和10012if (nChar == '#') //按键如果是#则调用自定义消息，其他则调用系统消息SendMessage(WM_MYMESSAGE, 10, 100); 定义主面板名称12cs.style &amp;= ~FWS_ADDTOTITLE; //修改主窗口标题m_strTitle = _T(\"Key\"); Ball小球采用异或方法来实现小球的消除，也可以实现小球的轨迹消除，通过Timer来实现小球的不断移动和刷新，从而造成一种小球运动的现象，声明Ball类变量 123456789101112131415161718public: afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);//声明timer afx_msg void OnDestroy(); afx_msg void OnTimer(UINT_PTR nIDEvent);private: int x; //x，y表示当前坐标，step_num表示步幅倍数，step_x,step_y表示每次移动距离的单位 int y; int step_num; int step_x; int step_y; int size; //小球大小 bool begin_pause; //小球状态 bool trail; //小球轨迹状态public: afx_msg void OnSpeedUp(); //声明加速函数 afx_msg void OnSpeedDown(); //声明减速函数 afx_msg void OnTrail(); //声明轨迹函数 afx_msg void OnBegin_Pause(); //声明状态函数 实现小球运动不断函数调用来实现小球的运动，采用step_num来控制小球的速度，当按下加速键是step_num加1，加速，减速同理，当速度为1是，如果继续减速，将强制停止此操作，并弹出消息提示，暂停功能的实现是通过阶数当前计时器，开始则重新开启一个同样编号的计时器，轨迹的消除通过控制变量trail来实现，如果不需要轨迹，则执行异或操作将轨迹消除，并进行清屏，反之则不执行 12345678910111213141516171819202122232425262728293031323334353637383940414243int CBallView::OnCreate(LPCREATESTRUCT lpCreateStruct){ if (CView::OnCreate(lpCreateStruct) == -1) return -1; // TODO: 在此添加您专用的创建代码 SetTimer(1, 100, NULL);//计时器编号，刷新时间（ms)可以通过刷新时间来实现加速和减速 return 0;}void CBallView::OnDestroy(){ CView::OnDestroy(); KillTimer(1);}void CBallView::OnTimer(UINT_PTR nIDEvent){ if (nIDEvent == 1) { CRect rect; GetClientRect(&amp;rect); CDC* pDC = GetDC(); pDC-&gt;SetROP2(R2_XORPEN); pDC-&gt;Ellipse(x, y, x + size, y + size); x += step_x*step_num; //通过改变步幅倍率来改变速度 y += step_y*step_num; theApp.x_ = x; theApp.y_ = y; if (x&lt;0 || x&gt;rect.right - size) //转向操作 { step_x = 0 - step_x; } if (y&lt;0 || y&gt;rect.bottom - size) { step_y = 0 - step_y; } if (!trail) //是否保留轨迹，不保留则通过异或消除 pDC-&gt;Ellipse(x,y,x+size,y+size); } CView::OnTimer(nIDEvent);} 菜单栏的实现在资源视图中找到主视图进行添加相应部分，并添加事件来响应 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void CBallView::OnSpeedUp() //加速函数，并弹出弹框提示速度信息{ // TODO: 在此添加命令处理程序代码 step_num++; theApp.speed_ = step_num; CString str; str.Format(L\"Current speed:%d\", step_num); MessageBox(str);}void CBallView::OnSpeedDown() //减速函数，并弹出弹框提示速度信息，如果速度为1，仍要减速，则不允许减速，弹出提示消息{ // TODO: 在此添加命令处理程序代码 if (step_num &gt; 1) { step_num--; theApp.speed_ = step_num; CString str; str.Format(L\"Current speed:%d\", step_num); MessageBox(str); } else//速度为1 { CString str; str.Format(L\" Current speed:%d\\n\\dThe current speed is already the minimum.\\n No more deceleration is allowed.\", step_num); MessageBox(str); }}void CBallView::OnTrail()//是否保留轨迹，不保留则通过用白色刷新全屏来实现清屏{ // TODO: 在此添加命令处理程序代码 if (trail) { trail = false; CDC* pDC = GetDC(); CRect rc; GetClientRect(&amp;rc); pDC-&gt;FillSolidRect(&amp;rc, RGB(255, 255, 255)); pDC-&gt;SetROP2(R2_XORPEN); pDC-&gt;Ellipse(x, y, x + size, y + size); ReleaseDC(pDC); } else trail = true; }//void CBallView::OnBegin_Pause()//暂停实现方法一，步幅倍率为0，则一直在原地刷新，小球会一直闪动//{// // TODO: 在此添加命令处理程序代码// if (begin_pause == 0)// {// begin_pause = step_num;// step_num = 0;// }// else// {// step_num = begin_pause;// begin_pause = 0;// }//}void CBallView::OnBegin_Pause()//暂停实现方法二，通过kill掉Timer来实现暂停，开始则重新申请一个Timer{ // TODO: 在此添加命令处理程序代码 if (!begin_pause) { begin_pause = true; KillTimer(1); } else { SetTimer(1, 100, NULL); begin_pause = false; }} 状态栏的实现新建三个状态 速度，位置和时间，并将其添加到indicators数组里面，使用SetPaneInfo函数来设置三个状态的信息以及宽度，然后继续利用Timer来不断刷新，速度和位置采用全局变量来获得，时间则通过CTime::GetCurrentTime()函数实现。 123456789101112131415161718192021m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT)); m_wndStatusBar.SetPaneInfo(4, IDS_INDICATOR_SPEED, SBPS_POPOUT, 50);//设置三个信息的位置和宽度m_wndStatusBar.SetPaneInfo(5, IDS_INDICATOR_MESSAGE, SBPS_POPOUT, 110);m_wndStatusBar.SetPaneInfo(6, IDS_INDICATOR_TIME, SBPS_POPOUT, 50);RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, IDS_INDICATOR_TIME);//添加时间显示函数SetTimer(2, 100, NULL);CTime t1;CString str_1; //对三栏信息进行初始化str_1.Format(L\"Speed:%d\", theApp.speed_);m_wndStatusBar.SetPaneText(4, str_1);CString str_2;str_2.Format(L\"Location(%d,%d)\", theApp.x_, theApp.y_);m_wndStatusBar.SetPaneText(5, str_2);t1 = CTime::GetCurrentTime();m_wndStatusBar.SetPaneText(6, t1.Format(\"%H:%M:%S\")); 123456789101112131415161718void CMainFrame::OnTimer(UINT_PTR nIDEvent)//通过timer来实现刷新{ CTime t1; CString str_1; str_1.Format(L\"Speed:%d\", theApp.speed_); m_wndStatusBar.SetPaneText(4, str_1); CString str_2; str_2.Format(L\"Location(%d,%d)\", theApp.x_, theApp.y_); m_wndStatusBar.SetPaneText(5, str_2); t1 = CTime::GetCurrentTime();//获取当前时间来刷新状态栏 m_wndStatusBar.SetPaneText(6, t1.Format(\"%H:%M:%S\")); CFrameWnd::OnTimer(nIDEvent);} 定义主面板名称12cs.style &amp;= ~FWS_ADDTOTITLE; //修改主窗口标题m_strTitle = _T(\"Ball\"); 实验收获通过本次实验掌握了MFC的基本操作，理解了其实现功能的机制（消息的发送和执行），了解了一些基本函数的使用的，在对其界面优化过程中，通过实践对其理解加深，主要存在困难就是对函数的使用，以及初步接触MFc对其实现机制不太了解，实验过后相信会有所提升。","tags":[{"name":"Homework","slug":"Homework","permalink":"https://kpl0111.github.io/blog/tags/Homework/"},{"name":"MFC","slug":"MFC","permalink":"https://kpl0111.github.io/blog/tags/MFC/"}]},{"title":"Hexo+Github搭建自己的博客","date":"2021-03-27T14:04:17.000Z","path":"2021/03711.html","text":"​ 今天算是把自己的简易博客给搭建了起来，虽然说很丑，很多地方优化还没做好，功能也不太全，但是，做事情嘛，总是要一步步来的，哪有一蹴而就的事情，自己慢慢摸索，踩了许多坑之后，也把这其中的原理摸索了个七七八八，虽然说要我写个主题是天大的难题，但是理解博客的架构，以及github的用法也是很容易的，甚至就连命令也因为出错太多，四处填坑而记得些常用的，所以说做事情别人教给自己的和自己摸索的是完全不一样的，当然这个摸索也是在其他大佬教程和错误修正基础之上摸索的，并不是“白手起家”，废话不多说，进入正题，记录一些我自己的搭建过程，也是那些像我一样的小白提供一个同样水平的教程，绝对包教包会，首先我们先来了解一下他们的工作原理，通俗理解，如有不对，欢迎指正。 关于Github​ 首先关于Github，本质上讲就是一个比较通用的代码托管平台。你可以将自己做的项目之类balabala的都放在里面，取用方便，最重要的是他完全免费，是一个很好的托管平台，做一些比较大的项目也可以多人协作（扯远了），回来说我们的博客，你可以在Github上面建立一个或者多个仓库，名字可以任意取，这些仓库本质没有区别，Github还为每个仓库提供一个页面还有主题（当然主体比较单一，还比较漂亮chou），当然你也可以选择自己搭配喜欢的主题。唯一不同之处就是Github给每个用户提供一个域名（username.github.io），当你的仓库以这个格式命名的时候，他就会默认这个仓库的界面就是你的网站主界面，其他的仓库就是他的子目录，就这么点区别，举个栗子，我的用户名是Test，那么我的网站主界面就是https://Test.github.io， 他所代表的仓库名字就是Test.github.io，如果我还有一个仓库名字是Blog，那么这个仓库的主界面就要用https://Test.github.io/Blog 打开，这样说就很简单易懂了吧，其他区别完全没有，名字你可随便改，当你给哪个仓库命名为username.github.io时，默认打开就是这个仓库主界面（当然站点配置也要改，不然会出错的）。 关于Git​ Git本身就是一个工具，这里我们用它来实现我们的各种命令，大致可以等同于命令行，可以用Git来安装各种插件，实现命令，这里不多介绍，后面过程中你就会明白。 关于Hexo​ 我们所使用的主题以及大部分插件都由Hexo提供，你可以把它理解为一家衣服店铺，我们来挑选我们喜欢的衣服（theme），同时它也提供裁裤腿，钉扣子（插件）服务，这样就可以理解了吧。 流程​ 简单介绍一下流程，非常简单。首先我们建立一个仓库以便我们能够放一些我们主题的配置文件在里面，当然仓库名字就要命名为username.github.io格式了，这样我们的主页面才会使我们配置的那样，然后我们需要在本地也创建一个仓库，在里面把我们平时用的代码等等都放在里面，然后把本地仓库和远程仓库连接，再把本地文件代码上传就可以得到我们想要的简洁漂亮的网站了，是不是很简单呢。 具体步骤仓库搭建仓库搭建可以参考一下这位大佬的博客：超详细Hexo+Github博客搭建小白教程 讲得非常详细，我就不再介绍了，做点其他有用的东西。 网站配置在你的本地文件夹里面会有一个_config.yml文件，这个就是你的网站的配置文件了，可以在里面配置你的网站名字，图标等等，基本上你想到的都可以在里面设置，具体每一项对应那个部分，hexo官网很详细，也不再多补充，可以参考Hexo文档，里面没有的话百度一下，你就知道，总的来说，不难要善用搜索引擎。 主题更换主题选择的话可以从Themes|Hexo上选你喜欢的，具体步骤里面每个主题作者都会介绍，大致过程是一样的，不管你是clone也好，下载zip主题文件也好，要保证你的主题文件夹在themes文件夹下面，然后回到你的网站的文件夹里面找到_config.yml配置文件，在里面找到theme，将其更改为你的主题，比如说我的是Ayer，就是这样 然后基本上就可以了，之后需要做的就是一些优化工作，讲几点大家会遇到的关键的： 会有两个_config.yml文件，一个位于你网站的页面，是你网站的配置文件，另一个是在你的主题文件夹里面，两个名字一样，但是千万不要弄混，不要修改错文件，这两个都是配置文件，所以名字相同，但是配置的对象不一样，这点明白，应该就很简单了。 更换主题的步骤基本上就是theme后面换上你的主题名字，然后在安装你的主题所需要的插件，比如说你的网站想要有一个播放器小图标，但是你不给安装插件，就算主题配置里面作者配置的再全，也不可能有用，所以说要按照主题安装说明安装插件（在网站主页面右键Git Bush Here),然后修改主题配置文件就可以 格式极其重要，修改配置问件事要注意中间要有一个空格才能有效注意注释前也要有空格 最后放两张我的文件夹，以便大家区分两个配置文件，看不懂的话可以看文件夹上方的路径，路径也看不懂那就没办法了 主文件夹 主题页 最后一点：不要怕出错，实践出真知，搞这个东西没错一段时间是没有游戏体验的，你懂的，这也是一个学习的过程，所以不要急，慢慢来，涨涨姿势，等到把雏形弄出来再慢慢搞UI也不迟。 最后欢迎大家补充，有地方不懂得可以留言，也可以发邮件，看到会回复的，祝大家能尽快拥有自己的网站。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kpl0111.github.io/blog/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://kpl0111.github.io/blog/tags/Blog/"},{"name":"Github","slug":"Github","permalink":"https://kpl0111.github.io/blog/tags/Github/"}]}]